{"componentChunkName":"component---src-templates-base-page-js","path":"/idm/v8.1/tuning/cache-connector-properties/","result":{"data":{"pageContent":{"html":"<h2 id=\"overview\">Overview</h2>\n<p>RadiantOne includes capture connectors for databases and directories. A connector is an adapter for one catalog/object per data source that can be configured to listen for changes. Some examples are:</p>\n<ul>\n<li>A SQL Server connector for database/catalog PUBS</li>\n<li>An Oracle connector for database owner SCOTT</li>\n<li>An LDAP connector for the inetOrgPerson object class in the schema</li>\n</ul>\n<p>For databases, there are three capture connector types: Counter, Changelog (Triggers-based), or Timestamp.</p>\n<p>For LDAP directories, there are two connector type options: LDAP (changelog), or Persistent Search.</p>\n<p>For Active Directory, there are three connector type options: AD USNChanged, AD DirSync, and AD Hybrid.</p>\n<p>Capture connectors are used for synchronization and have three main functions.</p>\n<ol>\n<li>Query data sources and collect changed entries.</li>\n<li>Filter unneeded events.</li>\n<li>Publish changed entries with the required information (requested attributes).</li>\n</ol>\n<p>Capture connectors publish change messages to queues. A sync engine receives notification when messages are in a queue, applies transformation to the message (based on attribute mappings and or scripting) and sends the transformed message to the destination.</p>\n<p>A high-level architecture is shown below.</p>\n<p><img src=\"Media/architecture.png\" alt=\"A flow chart of high level architecture\"></p>\n<h3 id=\"reset-connector-cursor--detect-new-changes-only\">Reset connector cursor â€“ detect new changes only</h3>\n<p>Capture connectors use a cursor to maintain information about the last processed change. This allows the connectors to capture only changes that have happened since the last time they processed changes. When the capture connectors start, they automatically attempt to capture all changes that have happened since the last time they checked. If the synchronization process has been stopped for an extended period, you might not want them to capture all missed changes. In this case, you can reset the cursor for the connector. You can reset the cursor from the Classic Control Panel > Synhronization tab, or manually define the cursor value.</p>\n<p><strong>Synhronization tab</strong></p>\n<p>On the Classic Control Panel > Synchronization tab, choose the topology on the left. Select <strong>Configure</strong> next to the pipeline on the right. Choose the <strong>Capture</strong> component and select <strong>Reset Cursor</strong> shown below the properties. An example is shown below.</p>\n<p><img src=\"Media/reset-cursor.png\" alt=\"The Reset Cursor option in the Global Sync tab of the Main Control Panel\"></p>\n<p><strong>Manually update connector cursor</strong></p>\n<p>Each connector stores a cursor to maintain information about the last processed change. In some cases, you may need to edit the cursor value to force the connector to pick up some missed changes (during a disaster recovery scenario where you will start synchronization in another data center), or skip some changes in cases like where <a href=\"#force-sequential-counters\">non-sequential change IDs</a> were detected. Connector configuration is stored in a RadiantOne Directory store mounted at the <code class=\"language-text\">cn=registry</code> naming context.</p>\n<blockquote>\n<p>[!note]\r\nEditing the cursor is supported for connectors that store a number or timestamp value. The AD DirSync and Hybrid connectors use a cookie for a cursor value that you would not know how to set.</p>\n</blockquote>\n<ol>\n<li>Stop the capture connector by suspending the pipeline. You can do this from the Main Control Panel > Global Sync tab, or using the vdsconfig command line utility, <code class=\"language-text\">change-pipeline-state</code> command.</li>\n<li>Connect to RadiantOne with an administrator that has permissions to modify entries in <code class=\"language-text\">cn=registry</code> and browse to the configuration for your capture connector: <code class=\"language-text\">cn=cursor,{PIPELINE_ID},cn=registry</code></li>\n<li>Edit the cursor attribute and enter the value to indicate the point from which the connector should capture changes from. An example for a database changelog connector is shown below.\r\n<img src=\"Media/image3.png\" alt=\"Example of Database Changelog Connector Cursor Settings\"></li>\n<li>Resume the pipeline which redeploys/starts the connector. You can do this from the Main Control Panel > Global Sync tab.</li>\n</ol>\n<h3 id=\"message-size\">Message size</h3>\n<p>Each message published by the connector contains one changed entry. Multiple changed entries are not packaged into a single message. The <a href=\"configure-connector-types-and-properties.md#request-all-attributes\">requested attributes</a> configured for the connector dictate the contents of the message and as a result, the message size.</p>\n<p>To learn more about connectors, please read the document that describes the the high-level process of <a href=\"configure-connector-types-and-properties.md\">configuring connector types and properties</a> that are used by all connectors.</p>\n<h2 id=\"database-changelog\">Database Changelog</h2>\n<p>When a database object is configured as a publisher, triggers are installed on the object and document all changes to a log table. This object name has the syntax <code class=\"language-text\">{TABLE_NAME}_LOG</code>. In the log table, two predefined column names are required: <code class=\"language-text\">RLICHANGEID</code> and <code class=\"language-text\">RLICHANGETYPE</code>. <code class=\"language-text\">RLICHANGEID</code> uniquely identifies one row in the change log table, and <code class=\"language-text\">RLICHANGETYPE</code> identifies the operation (insert, update, delete, abort). The database connector queries the log table to check for changes based on the polling interval.</p>\n<p>The <code class=\"language-text\">RLI_CON</code> user (configurable) is the default owner of the log table. This special user can also prevent a constant loop of changes when the database objects have been configured as both a publisher and subscriber. When this user makes changes to the database objects, the connector knows to ignore the change.</p>\n<h3 id=\"configuration\">Configuration</h3>\n<p>To detect changes using Changelog (triggers), set the connector type in the pipeline configuration by choosing the <strong>Capture</strong> component. In the Core Properties section, select DB Changelog from the drop-down list.</p>\n<p><img src=\"Media/image16.png\" alt=\"The drop-down list for Connector Type with DB Changelog selected, in the Core Properties section of Configure Pipeline\"></p>\n<p>After the DB Changelog connector type has been selected and configured, you can configure the properties in the Core Properties, Advanced Properties, and <a href=\"configure-connector-types-and-properties.md#event-contents\">Event Content</a> sections at the bottom. For properties common to all connectors, see <a href=\"configure-connector-types-and-properties.md#common-properties-for-all-connectors\">Configure capture connector types and properties</a>.</p>\n<h3 id=\"log-table-user\">Log Table User</h3>\n<p>Enter the user name for the connector's dedicated credentials for connecting to the log table. If you do not have the user name, contact your DBA to get the information to use.</p>\n<h3 id=\"log-table-user-password\">Log Table User password</h3>\n<p>The password for the user configured in the Log Table User property. If you do not have the password, contact your DBA to get the credentials.</p>\n<h3 id=\"table-name\">Table name</h3>\n<p>The name of the database table where changes to database entries are logged. You can use an existing table by entering the name in this property. Or enter the name of the table to create using the RadiantOne configuration scripts. Be sure to use the proper syntax for your database vendor (e.g. <code class=\"language-text\">{USER}.{TABLE}_LOG</code>).</p>\n<h3 id=\"apply-configuration-to-database\">Apply configuration to database</h3>\n<p>When you save the connector type configuration, you are prompted to execute the scripts on the database server. An example is shown below.</p>\n<p><img src=\"Media/image17.png\" alt=\"A prompt to execute DB Changelog configure scripts with No and OK buttons\"></p>\n<p>If you choose <strong>OK</strong> to execute the DB Changelog scripts, <code class=\"language-text\">SELECT</code>, <code class=\"language-text\">INSERT</code>, <code class=\"language-text\">UPDATE</code>, and <code class=\"language-text\">DELETE</code> access are granted for PUBLIC to the LOG table. Check with your database administrator if you need to restrict access rights on the log table. You can select the <strong>NO</strong> option and the generated script can be reviewed, modified if needed, and run on the database by a DBA. Click the Download button to download the sql scripts.</p>\n<h3 id=\"sql-filter\">SQL Filter</h3>\n<p>SQL Filter is used as part of the request for entries captured by the timestamp connector. Only changes that match the filter are published by the connector.</p>\n<p>A SQL filter is either a single expression or several single expressions joined by binary operators and brackets ( ). Possible binary operators are:</p>\n<ul>\n<li><code class=\"language-text\">AND</code></li>\n<li><code class=\"language-text\">OR</code></li>\n<li><code class=\"language-text\">NOT</code></li>\n</ul>\n<p>Some examples of valid SQL Filters are:</p>\n<ul>\n<li><code class=\"language-text\">ID='5'</code></li>\n<li><code class=\"language-text\">ID='5' AND NAME='ALLEN'</code></li>\n<li><code class=\"language-text\">ID='5' AND NAME='ALLEN' OR CITY='SAN FRANCISCO'</code></li>\n<li><code class=\"language-text\">ID='5' AND (NAME='ALLEN' OR CITY='SAN FRANCISCO')</code></li>\n<li><code class=\"language-text\">NAME LIKE 'AL%'</code></li>\n<li><code class=\"language-text\">NAME LIKE 'ALLE_'</code></li>\n</ul>\n<p>If the SQL Filter syntax entered in the property is not correct, an error occurs. The connector waits for the length of time specified in the <a href=\"configure-connector-types-and-properties.md#retry-interval-on-error\">Retry Interval on Error</a> and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the <a href=\"configure-connector-types-and-properties.md#max-retries-on-error\">Max Retries on Error</a> property) is exhausted, if the SQL syntax is still invalid, the connector stops. You must either remove or correct the SQL filter before restarting the connector. It is recommended that you set the connector <a href=\"configure-connector-types-and-properties.md#log-level\">Log Level</a> to <code class=\"language-text\">DEBUG</code> and check the connector log for the SQL query (<strong>Executing query:</strong>) that is generated to ensure the value entered in the SQL Filter property is translated properly. The capture connector log is located at <code class=\"language-text\">{RLI_HOME}\\logs\\sync_agents\\{PIPELINE_ID}\\connector.log</code> on the RadiantOne node where the sync agent is running. Go to the Server Control Panel > Log Viewer to download and/or view the log file. See the RadiantOne System Administration Guide for details on the Server Control Panel.</p>\n<p>If the connector should process all changed entries, do not enter a SQL filter.</p>\n<h3 id=\"force-sequential-counters\">Force Sequential Counters</h3>\n<p>This property accepts a value of <code class=\"language-text\">true</code> or <code class=\"language-text\">false</code> and dictates how the connector treats entries it picks up from the LOG table that have non-sequential change IDs. The default is <code class=\"language-text\">true</code> meaning that if the connector detects a non-sequential change ID for an entry in the LOG table, it behaves as if there is an error (non-connection error) and the retry logic based on the Max Retries on Error and Retry Interval on Error properties takes effect. Sometimes rows in the log table are not written in the order of the change ID, and if the connector does not wait for the entries to have sequential IDs, some changes could be missed. The connector waits for the length of time specified in the <a href=\"configure-connector-types-and-properties.md#retry-interval-on-error\">Retry Interval on Error</a> and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the <a href=\"configure-connector-types-and-properties.md#max-retries-on-error\">Max Retries on Error</a> property) is exhausted, if it still detects non-sequential change IDs, the connector stops. You can <a href=\"overview.md#manually-update-connector-cursor\">manually edit the cursor value</a> before restarting the connector to avoid the non-sequential number. Or you can disable the <code class=\"language-text\">Force Sequential Counters</code> property for the connector.</p>\n<p>If the connector should ignore non-sequential change IDs, and process all changes immediately, set the property to <code class=\"language-text\">false</code>.</p>\n<p>To learn more about connectors, please read the document that describes properties specific to the <a href=\"database-timestamp-connector.md\">Database timestamp connector</a>.</p>\n<h2 id=\"database-counter\">Database Counter</h2>\n<p>To support the Database Counter connector, the database table must have an indexed column that contains a sequence-based value that is automatically maintained and modified for each record that is added, updated or deleted. The Database Counter connector uses this column to maintain a cursor to keep track of processed changes.</p>\n<h3 id=\"supported-database-integer-types\">Supported database integer types</h3>\n<p>The counter connector supports database integer data types; more specifically, types which can be converted into Java's long data type (approx. from -9.2*10^18 to 9.2*10^18).</p>\n<h3 id=\"configuration-1\">Configuration</h3>\n<p>To detect changes using the Database Counter connector, set the connector type in the pipeline configuration by choosing the <strong>Capture</strong> component. In the Core Properties section, select <strong>DB Counter</strong> from the drop-down list.</p>\n<p><img src=\"Media/image20.png\" alt=\"The drop-down list for Connector Type with DB Counter selected, in the Core Properties section of Configure Pipeline\"></p>\n<p>After the Database Counter connector type has been selected and configured, configure the properties in the Core Properties, Advanced Properties, and <a href=\"configure-connector-types-and-properties.md#event-contents\">Event Content</a> sections at the bottom. For properties common to all connectors, see <a href=\"configure-connector-types-and-properties.md#common-properties-for-all-connectors\">Configure capture connector types and properties</a>.</p>\n<h3 id=\"change-type-column\">Change Type Column</h3>\n<p>In the Core Properties section, enter a column name in the Change Type Column property. This value is the database table column name that contains the information about the type of change (insert, update or delete). If the column does not have a value, an update operation is assumed.</p>\n<h3 id=\"counter-column\">Counter Column</h3>\n<p>In the Core Properties section, enter a column name in the Counter Column property. This value is the database table column name that contains the value that auto-increments when the row changes.</p>\n<p><img src=\"Media/image21.png\" alt=\"The Counter Column property value in the Core Properties section, which has been set as CHANGECOUNTER\"></p>\n<h3 id=\"sql-filter-1\">SQL Filter</h3>\n<p>SQL filter is used as part of the request for entries captured by the timestamp connector. Only changes that match the filter are published by the connector.</p>\n<p>A SQL filter is either a single expression or several single expressions joined by binary operators and brackets ( ). Possible binary operators\r\nare:</p>\n<ul>\n<li><code class=\"language-text\">AND</code></li>\n<li><code class=\"language-text\">OR</code></li>\n<li><code class=\"language-text\">NOT</code></li>\n</ul>\n<p>Some examples of valid SQL Filters are:</p>\n<ul>\n<li><code class=\"language-text\">ID='5'</code></li>\n<li><code class=\"language-text\">ID='5' AND NAME='ALLEN'</code></li>\n<li><code class=\"language-text\">ID='5' AND NAME='ALLEN' OR CITY='SAN FRANCISCO'</code></li>\n<li><code class=\"language-text\">ID='5' AND (NAME='ALLEN' OR CITY='SAN FRANCISCO')</code></li>\n<li><code class=\"language-text\">NAME LIKE 'AL%'</code></li>\n<li><code class=\"language-text\">NAME LIKE 'ALLE_'</code></li>\n</ul>\n<p>If the SQL Filter syntax entered into the property is not correct, an error occurs. The connector waits for the length of time specified in the <a href=\"configure-connector-types-and-properties.md#retry-interval-on-error\">Retry Interval on Error</a> and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the <a href=\"configure-connector-types-and-properties.md#max-retries-on-error\">Max Retries on Error</a> property) is exhausted, if the SQL syntax is still invalid, the connector stops. You must either remove or correct the SQL filter before restarting the connector. It is recommended that you set the connector <a href=\"configure-connector-types-and-properties.md#log-level\">Log Level</a> to <code class=\"language-text\">DEBUG</code> and check the connector log for the SQL query (<strong>Executing query:</strong>) that is generated to ensure the value entered in the <code class=\"language-text\">SQL Filter</code> property is translated properly. The capture connector log is located at <code class=\"language-text\">{RLI_HOME}\\logs\\sync_agents\\{PIPELINE_ID}\\connector.log</code> on the RadiantOne node where the sync agent is running. Go to the Server Control Panel > Log Viewer to download and/or view the log file. See the RadiantOne System Administration Guide for details on the Server Control Panel.</p>\n<p>If the connector should process all changed entries, do not enter a SQL filter.</p>\n<h3 id=\"force-sequential-counters-1\">Force Sequential Counters</h3>\n<p>This property accepts a value of <code class=\"language-text\">true</code> or <code class=\"language-text\">false</code> and dictates how the connector treats entries it picks up from the LOG table that have non-sequential change IDs. The default is <code class=\"language-text\">true</code> meaning that if the connector detects a non-sequential change ID for an entry in the LOG table, it behaves as if there is an error (non-connection error) and the retry logic based on the Max Retries on Error and Retry Interval on Error properties takes effect. Sometimes rows in the log table are not written in the order of the change ID, and if the connector does not wait for the entries to have sequential IDs, some changes could be missed. The connector waits for the length of time specified in the <a href=\"configure-connector-types-and-properties.md#retry-interval-on-error\">Retry Interval on Error</a> and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the <a href=\"configure-connector-types-and-properties.md#max-retries-on-error\">Max Retries on Error</a> property) is exhausted, if it still detects non-sequential change IDs, the connector stops. You can <a href=\"overview.md#manually-update-connector-cursor\">manually edit the cursor value</a> before restarting the connector to avoid the non-sequential number. Or you can disable the Force Sequential Counters property for the connector.</p>\n<p>If the connector should ignore non-sequential change IDs, and process all changes immediately, set the property to <code class=\"language-text\">false</code>.</p>\n<h2 id=\"database-timestamp\">Database Timestamp</h2>\n<p>For Oracle, SQL Server, MySQL, MariaDB, and Salesforce backends (using the RadiantOne JDBC driver), a timestamp-based change detection mechanism is available. To leverage this mechanism, your database table must have a column that contains a timestamp/date value associated with updates. For Salesforce, this column is <code class=\"language-text\">LastModifiedDate</code>. The column used in the timestamp connector must be indexed for performance.</p>\n<blockquote>\n<p>[!warning]\r\nThis connector type does not detect delete operations. If you have a need to detect and propagate delete operations from the database, you should choose a different connector type. However, for Salesforce backends, delete operations can be detected because a delete operation is detected when the <code class=\"language-text\">isActive</code> attribute is set to <code class=\"language-text\">false</code>.\r\nThis connector type does not differentiate between <code class=\"language-text\">ADD</code> and <code class=\"language-text\">UPDATE</code> operations. All events are processed as <code class=\"language-text\">UPDATE</code> operations. You can customize the transformation logic to dictate how the <code class=\"language-text\">UPDATE</code> operations should be handled on the target (e.g. translated into an <code class=\"language-text\">INSERT</code>,etc.).</p>\n</blockquote>\n<p>For each database object that is a publisher of changes, a new/changed row in the table must have a timestamp column associated with it.</p>\n<h3 id=\"supported-database-date-types\">Supported database date types</h3>\n<p>The timestamp connector has been validated against Oracle, SQL Server, MySQL, and MariaDB databases, and Salesforce only (when accessed using the RadiantOne Salesforce JDBC driver). The timestamp connector time stamp mode supports the following database date types:</p>\n<ul>\n<li>For Oracle DB: <code class=\"language-text\">TIMESTAMP</code>, <code class=\"language-text\">TIMESTAMP WITH TIME ZONE</code>, <code class=\"language-text\">TIMESTAMP WITH LOCAL TIME ZONE</code>, and <code class=\"language-text\">DATE</code>.</li>\n<li>For SQL Server: <code class=\"language-text\">SMALLDATETIME</code>, <code class=\"language-text\">DATETIME</code>, and <code class=\"language-text\">DATETIME2</code></li>\n<li>For Salesforce (using RadiantOne Salesforce JDBC driver): <code class=\"language-text\">LastModifiedDate</code></li>\n<li>For MySQL or MariaDB: <code class=\"language-text\">DATETIME</code> is preferable, but <code class=\"language-text\">TIMESTAMP</code> can also be used. <code class=\"language-text\">DATETIME</code>, <code class=\"language-text\">DATETIME(3)</code>, or <code class=\"language-text\">DATETIME(6)</code> can be used. <code class=\"language-text\">DATETIME(7)</code> is not supported.</li>\n</ul>\n<h3 id=\"configuration-2\">Configuration</h3>\n<p>This connector type can be used for detecting changes in Oracle, SQL Server, MySQL, and MariaDB in addition to Salesforce (when the RadiantOne JDBC driver for Salesforce is used).</p>\n<p>To detect changes using a timestamp, set the connector type in the pipeline configuration by choosing the <strong>Capture</strong> component. In the Core Properties section, select DB Timestamp from the drop-down list.</p>\n<p><img src=\"Media/image18.png\" alt=\"The drop-down list for Connector Type with DB Timestamp selected, in the Core Properties section of Configure Pipeline\"></p>\n<p>After the DB Timestamp connector type has been selected, configure the properties in the Core Properties, Advanced Properties, and <a href=\"configure-connector-types-and-properties.md#event-contents\">Event Contents</a> sections. For properties common to all connectors, see <a href=\"configure-connector-types-and-properties.md#common-properties-for-all-connectors\">Configure capture connector types and properties</a>.</p>\n<h3 id=\"timestamp-column\">Timestamp Column</h3>\n<p>In the Core Properties section, set the Timestamp Column. The value of this property should indicate the exact database column name in your database table that contains either a date/timestamp or a sequence number that indicates when a record has been modified. The value of this column is used by the connector to determine which rows have been modified since the last time it picked up changes from the table.</p>\n<blockquote>\n<p>[!note]\r\nFor detecting changes in Salesforce, the column name should be <code class=\"language-text\">LastModifiedDate</code>.</p>\n</blockquote>\n<p>If an invalid column name is configured, the connector stops.</p>\n<p><img src=\"Media/image19.png\" alt=\"The Timestamp Column property value in the Core Properties section, which has been set as CHANGETIME\"></p>\n<h3 id=\"processing-delay\">Processing Delay</h3>\n<p>This property can be used if there is a need for a delay in the processing of changes by the connector. For example, if there are two or more processes that update the source table at the same time, and they take about 2 minutes each to run, the processing delay can be set at anywhere between 4-6 minutes. This delays the processing and makes sure the connector captures all changes coming from both processes.</p>\n<p>The property value is in seconds, and the default value is <code class=\"language-text\">0</code>. If the value is set to <code class=\"language-text\">&lt;=0</code>, it means that the property is ignored by the connector. If the value is set to be more than <code class=\"language-text\">0</code>, then only the entries between <code class=\"language-text\">last_cursor</code> and <code class=\"language-text\">current_time â€“ processing_delay</code> are processed by the connector. If an invalid, non-numeric value is set for this property, the connector stops.</p>\n<h3 id=\"sql-filter-2\">SQL Filter</h3>\n<p>SQL filter is used as part of the request for entries captured by the timestamp connector. Only changes that match the filter are published by the connector.</p>\n<p>A SQL filter is either a single expression or several single expressions joined by binary operators and brackets ( ). Possible binary operators are:</p>\n<ul>\n<li><code class=\"language-text\">AND</code></li>\n<li><code class=\"language-text\">OR</code></li>\n<li><code class=\"language-text\">NOT</code></li>\n</ul>\n<p>Some examples of valid SQL Filters are:</p>\n<ul>\n<li><code class=\"language-text\">ID='5'</code></li>\n<li><code class=\"language-text\">ID='5' AND NAME='ALLEN'</code></li>\n<li><code class=\"language-text\">ID='5' AND NAME='ALLEN' OR CITY='SAN FRANCISCO'</code></li>\n<li><code class=\"language-text\">ID='5' AND (NAME='ALLEN' OR CITY='SAN FRANCISCO')</code></li>\n<li><code class=\"language-text\">NAME LIKE 'AL%'</code></li>\n<li><code class=\"language-text\">NAME LIKE 'ALLE_'</code></li>\n</ul>\n<p>If the SQL Filter syntax entered into the property is not correct, an error occurs. The connector waits for the length of time specified in the <a href=\"configure-connector-types-and-properties.md#retry-interval-on-error\">Retry Interval on Error</a> and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the <a href=\"configure-connector-types-and-properties.md#max-retries-on-error\">Max Retries on Error</a> property) is exhausted, if the SQL syntax is still invalid, the connector stops. You must either remove or correct the SQL filter before restarting the connector. It is recommended that you set the connector <a href=\"configure-connector-types-and-properties.md#log-level\">Log Level</a> to <code class=\"language-text\">DEBUG</code> and check the connector log for the SQL query (<strong>Executing query:</strong>) that is generated to ensure the value entered in the SQL Filter property is translated properly. The capture connector log is located at <code class=\"language-text\">{RLI_HOME}\\logs\\sync_agents\\{PIPELINE_ID}\\connector.log</code> on the RadiantOne node where the sync agent is running. Go to the Server Control Panel > Log Viewer to download and/or view the log file. See the RadiantOne System Administration Guide for details on the Server Control Panel.</p>\n<p>If the connector should process all changed entries, do not enter a SQL filter.</p>\n<h3 id=\"query-timeout\">Query Timeout</h3>\n<p>The default is 0 (no timeout). This is the length of time (in seconds) that the connector waits to receive a response from the backend database. After this time, the connector discards the query and moves on to the next query. If the query timeout is set to 0, the connector waits indefinitely for a response from the backend database.</p>\n<h3 id=\"force-sequential-counters-2\">Force Sequential Counters</h3>\n<p>This property accepts a value of<code class=\"language-text\">true</code> or <code class=\"language-text\">false</code> and dictates how the connector treats entries it picks up from the LOG table that have non-sequential change IDs. The default is <code class=\"language-text\">true</code> meaning that if the connector detects a non-sequential change ID for an entry in the LOG table, it behaves as if there is an error (non-connection error) and the retry logic based on the Max Retries on Error and Retry Interval on Error properties takes effect. Sometimes rows in the log table are not written in the order of the change ID, and if the connector does not wait for the entries to have sequential IDs, some changes could be missed. The connector waits for the length of time specified in the <a href=\"configure-connector-types-and-properties.md#retry-interval-on-error\">Retry Interval on Error</a> and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the <a href=\"configure-connector-types-and-properties.md#max-retries-on-error\">Max Retries on Error</a> property) is exhausted, if it still detects non-sequential change IDs, the connector stops. You can <a href=\"overview.md#manually-update-connector-cursor\">manually edit the cursor value</a> before restarting the connector to avoid the non-sequential number. Or you can disable the Force Sequential Counters property for the connector.</p>\n<p>If the connector should ignore non-sequential change IDs, and process all changes immediately, set the property to <code class=\"language-text\">false</code>.</p>\n<p>To learn more about connectors, please read the document that describes properties specific to the <a href=\"database-counter-connector.md\">Database Counter connector</a>.</p>\n<h2 id=\"ldap-connectors\">LDAP Connectors</h2>\n<p>There are two types of LDAP connectors: Changelog and Persistent Search. These connector types are described in this document.</p>\n<p><strong>LDAP (Changelog) connector</strong></p>\n<p>Any LDAP directory that offers a changelog can use the LDAP connector type. This includes the RadiantOne service.</p>\n<p>For the changelog functionality, some directories like Oracle ODSEE, must have the changelog and retro changelog plug-in enabled. The connector polls the changelog based on the changelog polling interval parameter. The connector internally keeps track of the last processed change and only processes new changes. If the connector is shut down (either deliberately or due to failure) it can read the changelog and capture all changes that occurred while the connector was offline.</p>\n<p>A special user (that represents the \"connector\" user) must exist in the directory. This user must have sufficient rights for detecting changes (reading the changelog). When defining the data source associated with the LDAP (source) backend, enter this user in the connection parameter.</p>\n<p><strong>LDAP Persistent Search connector</strong></p>\n<p>The Persistent Search connector issues a persistent search and gets notified by the directory server when data changes. For directories that offer persistent search, no special configuration is required to enable this function on the LDAP server. If the connector is shut down (either deliberately or due to failure), the delete operations that occurred on the directory are lost. Once the connector is back online there is no way to retrieve the delete operations that occurred while it was down. The only exception to this is for IBM TDS directories. It stores deleted entries and the capture connector is able to read them, and based on timestamp, determine if the change occurred while the connector was offline.</p>\n<p>Any LDAP directory that offers a persistent search mechanism can use the Persistent Search connector type. Novell eDirectory is an example of an LDAP source that supports persistent search. Others include Red Hat Directory, IBM TDS, and CA Directory.</p>\n<h3 id=\"configuration-3\">Configuration</h3>\n<p>Set the connector type in the pipeline configuration by choosing the <strong>Capture</strong> component. In the Core Properties section, select the connector type from the drop-down list.</p>\n<p><img src=\"Media/image8.png\" alt=\"The drop-down list for Connector Type with LDAP selected, in the Core Properties section of Configure Pipeline\"></p>\n<p>After selecting the Connector Type, configure the connector properties. For properties common to all connectors, see <a href=\"configure-connector-types-and-properties.md#common-properties-for-all-connectors\">Configure capture connector types and properties</a>. The general properties for LDAP connectors are configured in the Core Properties section. Properties related to filtering of events are configured in the Event Filtering section. Properties related to the contents of the messages published by the connector are configured in the <a href=\"configure-connector-types-and-properties.md#event-contents\">Event Content</a> section. All other properties are configured in the Advanced Properties section. <a href=\"configure-connector-types-and-properties.md#polling-interval\">Polling interval</a>is not required for the LDAP Persistent Search connector. For properties that determine how the connector filters events that are not needed, configure the LDAP Filter, Included Branches and Excluded Branches in the Event Filtering section. These properties are described below.</p>\n<h3 id=\"ldap-filter\">LDAP Filter</h3>\n<p>To further condition the entries that are published, you can indicate the desired criteria in the LDAP Filter property. This is a post filter, used to qualify which entries are published by the connector. You must enter a valid LDAP filter in the property.</p>\n<p>This property can be used to avoid publishing unwanted information.</p>\n<p>If a captured entry matches the criteria indicated in the LDAP filter property, it is published by the connector. If it does not, the entry is not published.</p>\n<p>If the captured change type is delete, and not enough information is known about the entry, the LDAP filter is not used and the entry is published by the connector. For example, if the LDAP filter property contained a value of <code class=\"language-text\">(l=Novato)</code> and the captured entry did not contain an <code class=\"language-text\">l</code> attribute, the LDAP filter is not applied and the entry is published.</p>\n<p>If the captured change type is not delete (e.g. insert, update, move, etc.), and not enough information is known about the entry, the LDAP filter is still used and the entry is not published. For example, if the LDAP filter property contained a value of <code class=\"language-text\">(l=Novato)</code> and the captured entry did not contain an <code class=\"language-text\">l</code> attribute, the LDAP filter is still applied and the entry is not published by the connector.</p>\n<blockquote>\n<p>[!note]\r\nIf a change is made to this property while the connector is running, it must be restarted for the new value to take effect.</p>\n</blockquote>\n<h3 id=\"excluded-branches\">Excluded Branches</h3>\n<p>To further condition the entries that are published, you can indicate one or more branches to exclude. In the Excluded Branches property, enter one or more suffixes associated with entries that should not be published by the connector. Select <strong>Enter</strong> after each suffix. An example is shown below.</p>\n<p><img src=\"Media/image9.png\" alt=\"Two suffixes entered in the Excluded Branches property\"></p>\n<p>If the changed entry DN contains a suffix that matches the excluded branches value, or is a change in the exact entry that is listed (e.g. <code class=\"language-text\">ou=dept1,ou=com</code>), this entry is not published by the connector. Otherwise, the entry is published. This can avoid publishing unwanted information.</p>\n<blockquote>\n<p>[!note]\r\nIf both included and excluded branches are used, an entry must satisfy the conditions defined in both settings to be included in the message. The included branches condition(s) is checked first.</p>\n</blockquote>\n<p>If a change is made to this property while the connector is running, the new value is taken into account once the connector re-initializes which happens automatically every 20 seconds.</p>\n<h3 id=\"included-branches\">Included Branches</h3>\n<p>To further condition the entries that are published, you can indicate one or more branches to include. In the Included Branches property, enter one or more suffixes associated with entries that should be published by the connector. Select <strong>Enter</strong> after each suffix. An example is shown below.</p>\n<p><img src=\"Media/image10.png\" alt=\"Two suffixes entered in the Included Branches property\"></p>\n<p>If the changed entry DN contains a suffix that matches the included branches value, or is a change in the exact entry that is listed (e.g. <code class=\"language-text\">ou=dept1,ou=com</code>), this entry is published by the connector. Otherwise, the entry is not published. This can avoid publishing unwanted\r\ninformation.</p>\n<blockquote>\n<p>[!note]\r\nIf both included and excluded branches are used, an entry must satisfy the conditions defined in both settings to be included in the message. The included branches condition(s) is checked first.\r\nIf you set this value using the vdsconfig command line utility on Windows, separate the branches with a comma. E.g. <code class=\"language-text\">C:\\radiantone\\vds\\bin>vdsconfig.bat set-connector-property -connectorname o_sead_pcache_proxy__dc_seradiant_dc_dom__seradiantad -propertyid includedBranches</code>\r\n<code class=\"language-text\">-propertyvalue \"[\\\"cn=users,dc=seradiant,dc=dom\\\",\\\"cn=domaingroups,dc=seradiant,dc=dom\\\"]\"</code></p>\n</blockquote>\n<p>If a change is made to this property while the connector is running, the new value is taken into account once the connector re-initializes which happens automatically every 20 seconds.</p>\n<h3 id=\"switch-to-primary-server-in-polling-intervals\">Switch to Primary Server (in polling intervals)</h3>\n<p>This option is relevant for the LDAP changelog connector type.</p>\n<p>This option, working in conjunction with the Polling Interval property, allows you to configure how often, if at all, the connector attempts to switch back to the primary server after failover.</p>\n<p>To configure the connector to attempt to switch to the primary server, set Switch to Primary Server to a value of <code class=\"language-text\">4</code> or greater. You can set the value to less than <code class=\"language-text\">4</code>, but attempting to connect back to the primary server can be time consuming and therefore not recommended to do frequently. For example, if this value is set to <code class=\"language-text\">1</code>, the connector makes an attempt every polling interval. If the Switch to Primary Server value is <code class=\"language-text\">3</code>, the connector makes an attempt every third polling interval.</p>\n<p>To disable attempts to reconnect to the primary server, set this value to <code class=\"language-text\">zero</code>. This is the default value.</p>\n<p>Changes made to this property's value while the connector is running are immediately taken into account. When the connector starts or restarts and the property value is <code class=\"language-text\">1</code> or higher, the connector attempts to switch to the primary server immediately.</p>\n<p><img src=\"Media/image11.png\" alt=\"The Switch to Primary Server (in polling intervals) property with a value set to 0\"></p>\n<h3 id=\"failover-algorithm\">Failover Algorithm</h3>\n<p>This option is relevant for the LDAP changelog connector type.</p>\n<p>When a failover happens, the changelog capture connector attempts to find a new cursor. Since this process is inexact, and changenumber sequence can vary across some replica servers, some events may be replayed or lost. The changelog connector maintains a cursor that indicates information related to the last change processed by the connector along with information about possible replica servers in case failover is needed. During failover, the connector searches the changelog of the replica servers and determines minimum and maximum changenumbers across them. Assume that the last processed changenumber stored by the connector is 100 and there are 2 replica servers defined for the backend. During failover, the connector determines the current changenumbers for each of the replicas by searching their changelogs. Assume that replica 1 has changenumber 99 and replica 2 has changenumber 97. When the connector needs to failover, it must decide whether to start processing changes using changenumber 100 (its current last processed change), 97 (changenumber from replica 2), or 99 (changenumber from replica 1).</p>\n<p>The Failover Algorithm property allows you to determine how the cursor value gets set during failover, and ultimately determine the quantity of events that are replayed. The property supports values between <code class=\"language-text\">1</code> and <code class=\"language-text\">4</code>. The meaning of each is outlined in the table below.</p>\n<p><img src=\"Media/image12.png\" alt=\"The Failover Algorithm property with a value set to 1\"></p>\n<table>\n<thead>\n<tr>\n<th>Value</th>\n<th>Function</th>\n<th>Set this value if...</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Sets cursor to the minimum changenumber based on the current changelog numbers of the replica servers. In the example described above, changenumber of 97 is used. This is the default setting.</td>\n<td>You do not want to lose any events. This may result in many events being replayed.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Sets cursor to maximum changenumber based on the current changelog numbers of the replica servers. In the example described above, changenumber of 99 is used.</td>\n<td>You want to minimize the replaying of events during failover. This may result in some events being lost.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>The cursor is not changed. The exact last processed changed stored in the connector cursor would be used. In the example described above, changenumber of 100 is used.</td>\n<td>You know that the LDAP servers in the replica have the same changeNumber in <code class=\"language-text\">cn=changelog</code>. For example, all RadiantOne nodes in a cluster have the same changeNumber in <code class=\"language-text\">cn=changelog</code>.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Sets cursor to the last changenumber of the failover server. In the example described above, if replica 1 is the failover server that gets used, changenumber of 99 is used. If replica 2 is the failover server, changenumber of 97 is used.</td>\n<td>You do not want to replay any events during failover. This may result in the loss of many events.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"active-directory-connectors\">Active Directory Connectors</h2>\n<p>There are three types of Active Directory connectors: USNChanged, DirSync and Hybrid. These connector types are described in this document.</p>\n<blockquote>\n<p>[!note]\r\nThe Active Directory USNChanged connector supports AD LDS.</p>\n</blockquote>\n<p>The decision tree below can help guide you on the Active Directory connector type to use.</p>\n<p><img src=\"Media/image13.png\" alt=\"A decision tree that can guide you on the Active Directory connector type to use\"></p>\n<p><strong>Active Directory USNChanged connector</strong></p>\n<p>Active Directory keeps track of changes that happen to entries in the directory (by incrementing the <code class=\"language-text\">uSNChanged</code> attribute for the entry). Based on a polling interval configured, the connector connects with the user and password configured in the connection string/data source and checks the list of changes stored by Active Directory. The connector internally maintains the last processed change number (<code class=\"language-text\">uSNChanged</code> value) and this allows for the recovery of all changes that occur even if the connector is down (deliberately or due to failure).</p>\n<blockquote>\n<p>[!note]\r\nThis is the connector type that must be used if the backend is an Active Directory Global Catalog. The Active Directory DirSync connector should not be used because it is unable to detect events in sub-domains.**\r\nAlso, If you are pointing the Active Directory connector to the Global Catalog, when a deleted entry is detected, the connector receives only the DN of the deleted entry in the context of the <code class=\"language-text\">CN=Deleted Objects</code> container (e.g. <code class=\"language-text\">CN=u1\\0ADEL:2ca20e8c-1748-4e7d-9044-45e64ab8105b,CN=Deleted Objects,DC=t1,DC=f6,DC=rli</code>). Transformation logic needs to address how to find the corresponding entry in the target(s) to remove or update them accordingly.**</p>\n</blockquote>\n<p>If the sequence of events is critical, use the <a href=\"#active-directory-dirsync-connector\">DirSync connector</a> because it processes events in the order in which they occur instead of prioritizing and processing inserts and updates before deletes.</p>\n<blockquote>\n<p>[!warning]\r\nTo detect delete events, the service account used by RadiantOne to connect to the backend Active Directory (configured in the connection string of the RadiantOne data source) must have permissions to search the tombstone objects. More specifically, the LIST CONTENTS and READ PROPERTY permissions to the<code class=\"language-text\"> CN=Deleted Objects</code> branch are required. Generally, a member of the Administrators group is sufficient. However, some Active Directory servers may require a member of the Domain Admins group. Check with your Active Directory permissions to determine the appropriate credentials required.</p>\n</blockquote>\n<p><strong>Active Directory DirSync connector</strong></p>\n<p>The Active Directory DirSync capture connector retrieves changes that occur to entries in a directory by passing a cookie that identifies the directory state at the time of the previous DirSync search. The first time the DirSync capture connector is started, it stores a cookie in a cursor file. At the next polling interval, the connector performs a DirSync search to detect changes by sending the current cookie. These changes include only the objects and attributes that have changed since the previous state identified by the current cookie. Because it retrieves only changed objects and attributes, the Active Directory DirSync capture connector avoids propagating irrelevant attributes, reducing message size and potentially reducing network congestion. After retrieving changes, a new cookie is obtained, and the cursor file is updated.</p>\n<blockquote>\n<p>[!warning]\r\nDo not use this connector type if your backend is an Active Directory Global Catalog because it is unable to detect events in sub-domains. Use the <a href=\"overview.md#manually-update-connector-cursor\">Active Directory (USNChanged)</a> connector instead.\r\nTo detect delete events, the service account used by RadiantOne to connect to the backend Active Directory (configured in the connection string of the RadiantOne data source) must have permissions to search the tombstone objects. Generally, a member of the Administrators group is sufficient. However, some Active Directory servers may require a member of the Domain Admins group. Check with your Active Directory permissions to determine the appropriate credentials required.</p>\n</blockquote>\n<p>The DirSync capture connector is recommended for environments where the sequence of events is critical. The DirSync capture connector processes events in the order in which they occur, unlike the <a href=\"overview.md#manually-update-connector-cursor\">Active Directory USNChanged connector</a> which prioritizes inserts and updates before deletes.</p>\n<p>To use the DirSync control, the Bind DN connecting to the directory must have the DS-Replication-Get-Changes extended right, which can be enabled with the <strong>Replicating Directory Changes</strong> permission, on the root of the partition being monitored. By default, this right is assigned to the Administrator and LocalSystem accounts on domain controllers.</p>\n<blockquote>\n<p>[!warning]\r\nThe DirSync capture connector does NOT capture changes to calculated attributes such as the <code class=\"language-text\">memberOf</code> attribute or moved entries (<code class=\"language-text\">modDN</code> or <code class=\"language-text\">modRDN</code> operations).</p>\n</blockquote>\n<p><strong>Active Directory Hybrid connector</strong></p>\n<p>The Active Directory hybrid capture connector uses a combination of the uSNChanged and DirSync change detection mechanisms. The first time the connector starts, it gets a new cookie and the highest <code class=\"language-text\">uSNchanged</code> number. When the connector gets a new change (modify or delete), it makes an additional search using the DN of the entry and fetches the entry from AD. The fetched entry contains the <code class=\"language-text\">uSNChanged</code> attribute, so the connector updates the cursor values for both for the cookie and the last processed <code class=\"language-text\">uSNchanged</code> number.</p>\n<blockquote>\n<p>[!warning]\r\nIf you are virtualizing and detecting changes from a Global Catalog, then you must use the Active Directory USNChanged changed connector because the Hybrid connector cannot detect change events on sub-domains.</p>\n</blockquote>\n<p>When the connector restarts, uSNChanged detection catches the entries that have been modified or deleted while the connector was stopped. The LDAP search uses the last processed uSN to catch up. After the connector processes all entries, it requests a new cookie from AD (not from the cursor) and switches to DirSync change detection.</p>\n<h3 id=\"active-directory-connector-failover\">Active Directory Connector Failover</h3>\n<p>All Active Directory connectors have the ability to failover to a replica if the primary server is unavailable and the number of failure exceptions exceeds either the <a href=\"configure-connector-types-and-properties.md#max-retries-on-error\">Maximum Retries on Error</a> or <a href=\"configure-connector-types-and-properties.md#max-retries-on-connection-error\">Maximum Retries on Connection Error</a> value. This mechanism leverages the Active Directory replication vectors <code class=\"language-text\">[replUpToDateVector]</code>, and the failover servers configured at the level of the RadiantOne data source associated with Active Directory, to determinate which server(s) the connector switches to in case of failure. Since the replication vector contains all domains, in addition to some possibly retired domains, the connector narrows down the list of possible failover candidates to only the ones listed as failover servers in the RadiantOne data source associated with the Active Directory backend. If there are no failover server defined for the data source, all domains in the replication vector are possible candidates for failover.</p>\n<blockquote>\n<p>[!warning]\r\nWhen defining the RadiantOne data source associated with Active Directory, do not use Host Discovery or Load Balancers. You must use the fully qualified machine names for the primary server and failover servers. Do not use IP addresses. Also, it is highly recommended that you list your desired failover servers at the level of the data source. Not only does this make the failover logic more efficient, but it also avoids delays in synchronization.</p>\n</blockquote>\n<p><code class=\"language-text\">[replUpToDateVector]</code> definition: The non-replicated attribute <code class=\"language-text\">replUpToDateVector</code> is an optional attribute on the naming context root of every naming context replica. If this vector is unavailable, the connector is suspended.</p>\n<p>The ReplUpToDateVector type is a tuple with the following fields:</p>\n<ul>\n<li><code class=\"language-text\">uuidDsa</code>: The invocation ID of the DC that assigned <code class=\"language-text\">usnHighPropUpdate</code>.</li>\n<li><code class=\"language-text\">usnHighPropUpdate</code>: A USN at which an update was applied on the DC\r\nidentified by <code class=\"language-text\">uuidDsa</code>.</li>\n<li><code class=\"language-text\">timeLastSyncSuccess</code>: The time at which the last successful replication occurred from the DC identified by <code class=\"language-text\">uuidDsa</code>; for replication latency reporting only.</li>\n</ul>\n<p><code class=\"language-text\">[replUpToDateVector]</code> example:</p>\n\n          <codeblockcopytag>01ca6e90-7d20-4f9c-ba7b-823a72fc459e @ USN 2210490 @ Time 2005-08-21\r\n15:54:21\r\n\r\n1d9bb4b6-054a-440c-aedf-7a3f28837e7f @ USN 26245013 @ Time 2007-02-27\r\n10:17:33\r\n\r\n24980c9d-39fa-44d7-a153-c0c5c27f0577 @ USN 4606302 @ Time 2006-08-20\r\n23:33:09</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">01ca6e90-7d20-4f9c-ba7b-823a72fc459e @ USN <span class=\"token number\">2210490</span> @ Time <span class=\"token number\">2005</span>-08-21\r\n<span class=\"token number\">15</span>:54:21\r\n\r\n1d9bb4b6-054a-440c-aedf-7a3f28837e7f @ USN <span class=\"token number\">26245013</span> @ Time <span class=\"token number\">2007</span>-02-27\r\n<span class=\"token number\">10</span>:17:33\r\n\r\n24980c9d-39fa-44d7-a153-c0c5c27f0577 @ USN <span class=\"token number\">4606302</span> @ Time <span class=\"token number\">2006</span>-08-20\r\n<span class=\"token number\">23</span>:33:09</code></pre></div>\n<p>For more information on Active Directory replication please read <a href=\"http://technet.microsoft.com/en-us/library/cc772726(WS.10).aspx\">how the Active Directory replication model works</a> and this <a href=\"http://technet.microsoft.com/en-us/magazine/2007.10.replication.aspx\">guide to Active Directory replication</a>.</p>\n<p>At run-time, the connector retrieves the entire list of servers defined in the replication vector and reduces the number of possible failover candidates based on failover servers defined in the RadiantOne data source (if any). The list of potential failover servers is stored at each polling interval. When the current server fails, and retries are exhausted, the connector decides to switch to the closest candidate by selecting the server with the maximum timestamp from the up-to-dateness vector. The capture connector's cursor is assigned the value from the up-to-dateness vector for the failover server. If the closest candidate fails as well, the connector tries with a second closest candidate and so on.</p>\n<p>Important things to keep in mind about the different Active Directory connector types:</p>\n<ul>\n<li>Active Directory USNChanged connector - Due to the lack of Active Directory replication for the <code class=\"language-text\">USNChanged</code> attribute, some changes could be missed or replayed on failover.</li>\n<li>For AD LDS backends, a special user for the connector must exist under the <code class=\"language-text\">CN=Configuration</code>, <code class=\"language-text\">CN={...}</code> naming context. This account must be configured in the RadiantOne LDAP data source associated with the AD LDS backend. This user must have permissions to read everything under the Root DSE, (e.g. <code class=\"language-text\">CN=Configuration</code>, <code class=\"language-text\">CN={...}</code>), and the AD LDS branch that the connector is monitoring for changes. All AD LDS instances must run on different computers and must listen on the same ports.</li>\n<li>Active Directory DirSync connector â€“ When the connector fails over to another DC replica, the connector may receive all objects and attributes instead of just the delta since the last request. Therefore, you may notice the number of entries published by the connector is more than you were expecting. This behavior is dictated by the Active Directory server and is out of the control of the connector. Keep this in mind when you define the Max Retries and Retry Intervals for the connector properties. The smaller the number of retries, the higher the chance the connector will failover and the greater potential of receiving all objects and attributes (a full sync) from the domain controller.</li>\n<li>Active Directory Hybrid connector â€“ leverages a mix of both USNChanged and DirSync functionalities during failover. After the failover server is found, uSNChanged detection catches the entries that have been modified or deleted since the connector's failure. The LDAP search uses the last processed <code class=\"language-text\">uSNChanged</code> number to catch up. After the connector processes all entries, it requests a new cookie from Active Directory and switches to DirSync change detection.</li>\n</ul>\n<h3 id=\"ldap-filter-1\">LDAP Filter</h3>\n<p>This is used for event filtering. To further condition the entries that are published, you can indicate the desired criteria in the LDAP Filter property. This is a post filter, used to qualify which entries are included in the message published by the connector. You must enter a valid LDAP filter in the property.</p>\n<p>This property can be used to reduce the size of the message by only including desired entries (that match the filter). This can also help reduce the amount of transformation logic needed because you can easily avoid synchronizing certain entries without needing the logic to abort them in the transformation script.</p>\n<p>If a captured entry matches the criteria indicated in the LDAP filter property, it is published in the message by the connector. If it does not, the entry is not published in the message. Information about the skipped entries is in the connector log (with log level 4).</p>\n<p>If the captured change type is delete, and not enough information is known about the entry, the LDAP filter is not used and the entry is published in the message. For example, if the LDAP filter property contained a value of <code class=\"language-text\">(l=Novato)</code> and the captured entry did not contain an <code class=\"language-text\">l</code> attribute, the LDAP filter is not applied and the entry is published in the message.</p>\n<p>If the captured change type is not delete (e.g. insert, update, move, etc.), and not enough information is known about the entry, the LDAP filter is still used and the entry is not published into the message. For example, if the LDAP filter property contained a value of <code class=\"language-text\">(l=Novato)</code> and the captured entry did not contain an <code class=\"language-text\">l</code> attribute, the LDAP filter is still applied and the entry is not published in the message.</p>\n<blockquote>\n<p>[!note]\r\nThis property can be updated while the connector is running and takes effect without restarting the connector.</p>\n</blockquote>\n<h3 id=\"excluded-branches-1\">Excluded Branches</h3>\n<p>This is used for event filtering. To further condition the entries that are published, you can indicate one or more branches to exclude. In the Excluded Branches property, enter one or more suffixes associated with entries that should not be published by the connector. Select <strong>Enter</strong> after each suffix. An example is shown below.</p>\n<p><img src=\"Media/image9.png\" alt=\"Two suffixes entered in the Excluded Branches property\"></p>\n<p>If the changed entry DN contains a suffix that matches the excluded branches value, or is a change in the exact entry that is listed (e.g. <code class=\"language-text\">ou=dept1,ou=com</code>), this entry is not published by the connector. Otherwise, the entry is published. This can avoid publishing unwanted information.</p>\n<blockquote>\n<p>[!note]\r\nIf both included and excluded branches are used, an entry must satisfy the conditions defined in both settings to be included in the message. The included branches condition(s) is checked first.</p>\n</blockquote>\n<p>If a change is made to this property while the connector is running, the new value is taken into account once the connector re-initializes which happens automatically every 20 seconds.</p>\n<h3 id=\"included-branches-1\">Included Branches</h3>\n<p>This is used for event filtering. To further condition the entries that are published, you can indicate one or more branches to include. In the Included Branches property, enter one or more suffixes associated with entries that should be published by the connector. Select <strong>Enter</strong> after each suffix. An example is shown below.</p>\n<p><img src=\"Media/image10.png\" alt=\"Two suffixes entered in the Included Branches property\"></p>\n<p>If the changed entry DN contains a suffix that matches the included branches value, or is a change in the exact entry that is listed (e.g. <code class=\"language-text\">ou=dept1,ou=com</code>), this entry is published by the connector. Otherwise, the entry is not published. This can avoid publishing unwanted information.</p>\n<blockquote>\n<p>[!note]\r\nIf both included and excluded branches are used, an entry must satisfy the conditions defined in both settings to be included in the message. The included branches condition(s) is checked first.</p>\n</blockquote>\n<p>If a change is made to this property while the connector is running, the new value is taken into account once the connector re-initializes which happens automatically every 20 seconds.</p>\n<h3 id=\"determine-move-operations\">Determine Move Operations</h3>\n<p>By default, the connector handles changes associated with LDAP modify DN and RDN operations, which change the distinguished name (DN)/relative distinguished name (RDN) of an entry, as an update operation. In the case of modify DN/RDN operations, Active Directory does not provide information about the old DN of the entry making it impossible for the connector to propagate a delete operation for the old DN/entry.</p>\n<p>If you require DN/RDN changes to be processed by the connector as a <code class=\"language-text\">modDN/modRDN</code> operation (so the target data source(s) get the change as a <code class=\"language-text\">modDN/modRDN</code>), set the Determine Move Operations property to: <code class=\"language-text\">true</code></p>\n<blockquote>\n<p>[!warning]\r\nThe connector must be restarted for this property to take effect.</p>\n</blockquote>\n<p>When the Determine Move Operations property is enabled, the connector maintains a cache mapping the objectGUID to DN for each Active Directory entry. This allows the connector to detect and propagate the event as a <code class=\"language-text\">modDN/modRDN</code> (move) operation. All entries from Active Directory must be read the first time when the connector starts/restarts to populate the cache. This increases the amount of time it takes for the connector to start and be able to capture changes.</p>\n<blockquote>\n<p>[!warning]\r\nWhen defining the data source for the backend Active Directory, check the Paged Results Control option to ensure that all entries can be retrieved from the backend. This is required for the connector to get all entries in the cache to map objectGUID to DN and support <code class=\"language-text\">modDN/modRDN</code> operations.</p>\n</blockquote>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{"id":"overview"},"children":[{"type":"text","value":"Overview"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"RadiantOne includes capture connectors for databases and directories. A connector is an adapter for one catalog/object per data source that can be configured to listen for changes. Some examples are:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"A SQL Server connector for database/catalog PUBS"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"An Oracle connector for database owner SCOTT"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"An LDAP connector for the inetOrgPerson object class in the schema"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For databases, there are three capture connector types: Counter, Changelog (Triggers-based), or Timestamp."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For LDAP directories, there are two connector type options: LDAP (changelog), or Persistent Search."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For Active Directory, there are three connector type options: AD USNChanged, AD DirSync, and AD Hybrid."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Capture connectors are used for synchronization and have three main functions."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Query data sources and collect changed entries."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Filter unneeded events."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Publish changed entries with the required information (requested attributes)."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Capture connectors publish change messages to queues. A sync engine receives notification when messages are in a queue, applies transformation to the message (based on attribute mappings and or scripting) and sends the transformed message to the destination."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A high-level architecture is shown below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/architecture.png","alt":"A flow chart of high level architecture"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"reset-connector-cursor--detect-new-changes-only"},"children":[{"type":"text","value":"Reset connector cursor â€“ detect new changes only"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Capture connectors use a cursor to maintain information about the last processed change. This allows the connectors to capture only changes that have happened since the last time they processed changes. When the capture connectors start, they automatically attempt to capture all changes that have happened since the last time they checked. If the synchronization process has been stopped for an extended period, you might not want them to capture all missed changes. In this case, you can reset the cursor for the connector. You can reset the cursor from the Classic Control Panel > Synhronization tab, or manually define the cursor value."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Synhronization tab"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On the Classic Control Panel > Synchronization tab, choose the topology on the left. Select "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Configure"}]},{"type":"text","value":" next to the pipeline on the right. Choose the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Capture"}]},{"type":"text","value":" component and select "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Reset Cursor"}]},{"type":"text","value":" shown below the properties. An example is shown below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/reset-cursor.png","alt":"The Reset Cursor option in the Global Sync tab of the Main Control Panel"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Manually update connector cursor"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Each connector stores a cursor to maintain information about the last processed change. In some cases, you may need to edit the cursor value to force the connector to pick up some missed changes (during a disaster recovery scenario where you will start synchronization in another data center), or skip some changes in cases like where "},{"type":"element","tagName":"a","properties":{"href":"#force-sequential-counters"},"children":[{"type":"text","value":"non-sequential change IDs"}]},{"type":"text","value":" were detected. Connector configuration is stored in a RadiantOne Directory store mounted at the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"cn=registry"}]},{"type":"text","value":" naming context."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nEditing the cursor is supported for connectors that store a number or timestamp value. The AD DirSync and Hybrid connectors use a cookie for a cursor value that you would not know how to set."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Stop the capture connector by suspending the pipeline. You can do this from the Main Control Panel > Global Sync tab, or using the vdsconfig command line utility, "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"change-pipeline-state"}]},{"type":"text","value":" command."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Connect to RadiantOne with an administrator that has permissions to modify entries in "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"cn=registry"}]},{"type":"text","value":" and browse to the configuration for your capture connector: "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"cn=cursor,{PIPELINE_ID},cn=registry"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Edit the cursor attribute and enter the value to indicate the point from which the connector should capture changes from. An example for a database changelog connector is shown below.\r\n"},{"type":"element","tagName":"img","properties":{"src":"Media/image3.png","alt":"Example of Database Changelog Connector Cursor Settings"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Resume the pipeline which redeploys/starts the connector. You can do this from the Main Control Panel > Global Sync tab."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"message-size"},"children":[{"type":"text","value":"Message size"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Each message published by the connector contains one changed entry. Multiple changed entries are not packaged into a single message. The "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#request-all-attributes"},"children":[{"type":"text","value":"requested attributes"}]},{"type":"text","value":" configured for the connector dictate the contents of the message and as a result, the message size."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To learn more about connectors, please read the document that describes the the high-level process of "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md"},"children":[{"type":"text","value":"configuring connector types and properties"}]},{"type":"text","value":" that are used by all connectors."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"database-changelog"},"children":[{"type":"text","value":"Database Changelog"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When a database object is configured as a publisher, triggers are installed on the object and document all changes to a log table. This object name has the syntax "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"{TABLE_NAME}_LOG"}]},{"type":"text","value":". In the log table, two predefined column names are required: "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"RLICHANGEID"}]},{"type":"text","value":" and "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"RLICHANGETYPE"}]},{"type":"text","value":". "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"RLICHANGEID"}]},{"type":"text","value":" uniquely identifies one row in the change log table, and "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"RLICHANGETYPE"}]},{"type":"text","value":" identifies the operation (insert, update, delete, abort). The database connector queries the log table to check for changes based on the polling interval."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"RLI_CON"}]},{"type":"text","value":" user (configurable) is the default owner of the log table. This special user can also prevent a constant loop of changes when the database objects have been configured as both a publisher and subscriber. When this user makes changes to the database objects, the connector knows to ignore the change."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"configuration"},"children":[{"type":"text","value":"Configuration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To detect changes using Changelog (triggers), set the connector type in the pipeline configuration by choosing the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Capture"}]},{"type":"text","value":" component. In the Core Properties section, select DB Changelog from the drop-down list."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image16.png","alt":"The drop-down list for Connector Type with DB Changelog selected, in the Core Properties section of Configure Pipeline"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"After the DB Changelog connector type has been selected and configured, you can configure the properties in the Core Properties, Advanced Properties, and "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#event-contents"},"children":[{"type":"text","value":"Event Content"}]},{"type":"text","value":" sections at the bottom. For properties common to all connectors, see "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#common-properties-for-all-connectors"},"children":[{"type":"text","value":"Configure capture connector types and properties"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"log-table-user"},"children":[{"type":"text","value":"Log Table User"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Enter the user name for the connector's dedicated credentials for connecting to the log table. If you do not have the user name, contact your DBA to get the information to use."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"log-table-user-password"},"children":[{"type":"text","value":"Log Table User password"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The password for the user configured in the Log Table User property. If you do not have the password, contact your DBA to get the credentials."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"table-name"},"children":[{"type":"text","value":"Table name"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The name of the database table where changes to database entries are logged. You can use an existing table by entering the name in this property. Or enter the name of the table to create using the RadiantOne configuration scripts. Be sure to use the proper syntax for your database vendor (e.g. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"{USER}.{TABLE}_LOG"}]},{"type":"text","value":")."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"apply-configuration-to-database"},"children":[{"type":"text","value":"Apply configuration to database"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When you save the connector type configuration, you are prompted to execute the scripts on the database server. An example is shown below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image17.png","alt":"A prompt to execute DB Changelog configure scripts with No and OK buttons"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you choose "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"OK"}]},{"type":"text","value":" to execute the DB Changelog scripts, "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"SELECT"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"INSERT"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"UPDATE"}]},{"type":"text","value":", and "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DELETE"}]},{"type":"text","value":" access are granted for PUBLIC to the LOG table. Check with your database administrator if you need to restrict access rights on the log table. You can select the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"NO"}]},{"type":"text","value":" option and the generated script can be reviewed, modified if needed, and run on the database by a DBA. Click the Download button to download the sql scripts."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"sql-filter"},"children":[{"type":"text","value":"SQL Filter"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"SQL Filter is used as part of the request for entries captured by the timestamp connector. Only changes that match the filter are published by the connector."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A SQL filter is either a single expression or several single expressions joined by binary operators and brackets ( ). Possible binary operators are:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"AND"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"OR"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"NOT"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Some examples of valid SQL Filters are:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ID='5'"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ID='5' AND NAME='ALLEN'"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ID='5' AND NAME='ALLEN' OR CITY='SAN FRANCISCO'"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ID='5' AND (NAME='ALLEN' OR CITY='SAN FRANCISCO')"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"NAME LIKE 'AL%'"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"NAME LIKE 'ALLE_'"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the SQL Filter syntax entered in the property is not correct, an error occurs. The connector waits for the length of time specified in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#retry-interval-on-error"},"children":[{"type":"text","value":"Retry Interval on Error"}]},{"type":"text","value":" and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#max-retries-on-error"},"children":[{"type":"text","value":"Max Retries on Error"}]},{"type":"text","value":" property) is exhausted, if the SQL syntax is still invalid, the connector stops. You must either remove or correct the SQL filter before restarting the connector. It is recommended that you set the connector "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#log-level"},"children":[{"type":"text","value":"Log Level"}]},{"type":"text","value":" to "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DEBUG"}]},{"type":"text","value":" and check the connector log for the SQL query ("},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Executing query:"}]},{"type":"text","value":") that is generated to ensure the value entered in the SQL Filter property is translated properly. The capture connector log is located at "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"{RLI_HOME}\\logs\\sync_agents\\{PIPELINE_ID}\\connector.log"}]},{"type":"text","value":" on the RadiantOne node where the sync agent is running. Go to the Server Control Panel > Log Viewer to download and/or view the log file. See the RadiantOne System Administration Guide for details on the Server Control Panel."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the connector should process all changed entries, do not enter a SQL filter."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"force-sequential-counters"},"children":[{"type":"text","value":"Force Sequential Counters"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This property accepts a value of "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"true"}]},{"type":"text","value":" or "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"false"}]},{"type":"text","value":" and dictates how the connector treats entries it picks up from the LOG table that have non-sequential change IDs. The default is "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"true"}]},{"type":"text","value":" meaning that if the connector detects a non-sequential change ID for an entry in the LOG table, it behaves as if there is an error (non-connection error) and the retry logic based on the Max Retries on Error and Retry Interval on Error properties takes effect. Sometimes rows in the log table are not written in the order of the change ID, and if the connector does not wait for the entries to have sequential IDs, some changes could be missed. The connector waits for the length of time specified in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#retry-interval-on-error"},"children":[{"type":"text","value":"Retry Interval on Error"}]},{"type":"text","value":" and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#max-retries-on-error"},"children":[{"type":"text","value":"Max Retries on Error"}]},{"type":"text","value":" property) is exhausted, if it still detects non-sequential change IDs, the connector stops. You can "},{"type":"element","tagName":"a","properties":{"href":"overview.md#manually-update-connector-cursor"},"children":[{"type":"text","value":"manually edit the cursor value"}]},{"type":"text","value":" before restarting the connector to avoid the non-sequential number. Or you can disable the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Force Sequential Counters"}]},{"type":"text","value":" property for the connector."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the connector should ignore non-sequential change IDs, and process all changes immediately, set the property to "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"false"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To learn more about connectors, please read the document that describes properties specific to the "},{"type":"element","tagName":"a","properties":{"href":"database-timestamp-connector.md"},"children":[{"type":"text","value":"Database timestamp connector"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"database-counter"},"children":[{"type":"text","value":"Database Counter"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To support the Database Counter connector, the database table must have an indexed column that contains a sequence-based value that is automatically maintained and modified for each record that is added, updated or deleted. The Database Counter connector uses this column to maintain a cursor to keep track of processed changes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"supported-database-integer-types"},"children":[{"type":"text","value":"Supported database integer types"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The counter connector supports database integer data types; more specifically, types which can be converted into Java's long data type (approx. from -9.2*10^18 to 9.2*10^18)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"configuration-1"},"children":[{"type":"text","value":"Configuration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To detect changes using the Database Counter connector, set the connector type in the pipeline configuration by choosing the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Capture"}]},{"type":"text","value":" component. In the Core Properties section, select "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"DB Counter"}]},{"type":"text","value":" from the drop-down list."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image20.png","alt":"The drop-down list for Connector Type with DB Counter selected, in the Core Properties section of Configure Pipeline"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"After the Database Counter connector type has been selected and configured, configure the properties in the Core Properties, Advanced Properties, and "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#event-contents"},"children":[{"type":"text","value":"Event Content"}]},{"type":"text","value":" sections at the bottom. For properties common to all connectors, see "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#common-properties-for-all-connectors"},"children":[{"type":"text","value":"Configure capture connector types and properties"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"change-type-column"},"children":[{"type":"text","value":"Change Type Column"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In the Core Properties section, enter a column name in the Change Type Column property. This value is the database table column name that contains the information about the type of change (insert, update or delete). If the column does not have a value, an update operation is assumed."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"counter-column"},"children":[{"type":"text","value":"Counter Column"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In the Core Properties section, enter a column name in the Counter Column property. This value is the database table column name that contains the value that auto-increments when the row changes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image21.png","alt":"The Counter Column property value in the Core Properties section, which has been set as CHANGECOUNTER"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"sql-filter-1"},"children":[{"type":"text","value":"SQL Filter"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"SQL filter is used as part of the request for entries captured by the timestamp connector. Only changes that match the filter are published by the connector."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A SQL filter is either a single expression or several single expressions joined by binary operators and brackets ( ). Possible binary operators\r\nare:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"AND"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"OR"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"NOT"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Some examples of valid SQL Filters are:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ID='5'"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ID='5' AND NAME='ALLEN'"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ID='5' AND NAME='ALLEN' OR CITY='SAN FRANCISCO'"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ID='5' AND (NAME='ALLEN' OR CITY='SAN FRANCISCO')"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"NAME LIKE 'AL%'"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"NAME LIKE 'ALLE_'"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the SQL Filter syntax entered into the property is not correct, an error occurs. The connector waits for the length of time specified in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#retry-interval-on-error"},"children":[{"type":"text","value":"Retry Interval on Error"}]},{"type":"text","value":" and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#max-retries-on-error"},"children":[{"type":"text","value":"Max Retries on Error"}]},{"type":"text","value":" property) is exhausted, if the SQL syntax is still invalid, the connector stops. You must either remove or correct the SQL filter before restarting the connector. It is recommended that you set the connector "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#log-level"},"children":[{"type":"text","value":"Log Level"}]},{"type":"text","value":" to "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DEBUG"}]},{"type":"text","value":" and check the connector log for the SQL query ("},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Executing query:"}]},{"type":"text","value":") that is generated to ensure the value entered in the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"SQL Filter"}]},{"type":"text","value":" property is translated properly. The capture connector log is located at "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"{RLI_HOME}\\logs\\sync_agents\\{PIPELINE_ID}\\connector.log"}]},{"type":"text","value":" on the RadiantOne node where the sync agent is running. Go to the Server Control Panel > Log Viewer to download and/or view the log file. See the RadiantOne System Administration Guide for details on the Server Control Panel."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the connector should process all changed entries, do not enter a SQL filter."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"force-sequential-counters-1"},"children":[{"type":"text","value":"Force Sequential Counters"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This property accepts a value of "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"true"}]},{"type":"text","value":" or "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"false"}]},{"type":"text","value":" and dictates how the connector treats entries it picks up from the LOG table that have non-sequential change IDs. The default is "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"true"}]},{"type":"text","value":" meaning that if the connector detects a non-sequential change ID for an entry in the LOG table, it behaves as if there is an error (non-connection error) and the retry logic based on the Max Retries on Error and Retry Interval on Error properties takes effect. Sometimes rows in the log table are not written in the order of the change ID, and if the connector does not wait for the entries to have sequential IDs, some changes could be missed. The connector waits for the length of time specified in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#retry-interval-on-error"},"children":[{"type":"text","value":"Retry Interval on Error"}]},{"type":"text","value":" and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#max-retries-on-error"},"children":[{"type":"text","value":"Max Retries on Error"}]},{"type":"text","value":" property) is exhausted, if it still detects non-sequential change IDs, the connector stops. You can "},{"type":"element","tagName":"a","properties":{"href":"overview.md#manually-update-connector-cursor"},"children":[{"type":"text","value":"manually edit the cursor value"}]},{"type":"text","value":" before restarting the connector to avoid the non-sequential number. Or you can disable the Force Sequential Counters property for the connector."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the connector should ignore non-sequential change IDs, and process all changes immediately, set the property to "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"false"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"database-timestamp"},"children":[{"type":"text","value":"Database Timestamp"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For Oracle, SQL Server, MySQL, MariaDB, and Salesforce backends (using the RadiantOne JDBC driver), a timestamp-based change detection mechanism is available. To leverage this mechanism, your database table must have a column that contains a timestamp/date value associated with updates. For Salesforce, this column is "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"LastModifiedDate"}]},{"type":"text","value":". The column used in the timestamp connector must be indexed for performance."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nThis connector type does not detect delete operations. If you have a need to detect and propagate delete operations from the database, you should choose a different connector type. However, for Salesforce backends, delete operations can be detected because a delete operation is detected when the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"isActive"}]},{"type":"text","value":" attribute is set to "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"false"}]},{"type":"text","value":".\r\nThis connector type does not differentiate between "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ADD"}]},{"type":"text","value":" and "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"UPDATE"}]},{"type":"text","value":" operations. All events are processed as "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"UPDATE"}]},{"type":"text","value":" operations. You can customize the transformation logic to dictate how the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"UPDATE"}]},{"type":"text","value":" operations should be handled on the target (e.g. translated into an "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"INSERT"}]},{"type":"text","value":",etc.)."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For each database object that is a publisher of changes, a new/changed row in the table must have a timestamp column associated with it."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"supported-database-date-types"},"children":[{"type":"text","value":"Supported database date types"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The timestamp connector has been validated against Oracle, SQL Server, MySQL, and MariaDB databases, and Salesforce only (when accessed using the RadiantOne Salesforce JDBC driver). The timestamp connector time stamp mode supports the following database date types:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"For Oracle DB: "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"TIMESTAMP"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"TIMESTAMP WITH TIME ZONE"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"TIMESTAMP WITH LOCAL TIME ZONE"}]},{"type":"text","value":", and "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DATE"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"For SQL Server: "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"SMALLDATETIME"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DATETIME"}]},{"type":"text","value":", and "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DATETIME2"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"For Salesforce (using RadiantOne Salesforce JDBC driver): "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"LastModifiedDate"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"For MySQL or MariaDB: "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DATETIME"}]},{"type":"text","value":" is preferable, but "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"TIMESTAMP"}]},{"type":"text","value":" can also be used. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DATETIME"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DATETIME(3)"}]},{"type":"text","value":", or "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DATETIME(6)"}]},{"type":"text","value":" can be used. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DATETIME(7)"}]},{"type":"text","value":" is not supported."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"configuration-2"},"children":[{"type":"text","value":"Configuration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This connector type can be used for detecting changes in Oracle, SQL Server, MySQL, and MariaDB in addition to Salesforce (when the RadiantOne JDBC driver for Salesforce is used)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To detect changes using a timestamp, set the connector type in the pipeline configuration by choosing the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Capture"}]},{"type":"text","value":" component. In the Core Properties section, select DB Timestamp from the drop-down list."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image18.png","alt":"The drop-down list for Connector Type with DB Timestamp selected, in the Core Properties section of Configure Pipeline"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"After the DB Timestamp connector type has been selected, configure the properties in the Core Properties, Advanced Properties, and "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#event-contents"},"children":[{"type":"text","value":"Event Contents"}]},{"type":"text","value":" sections. For properties common to all connectors, see "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#common-properties-for-all-connectors"},"children":[{"type":"text","value":"Configure capture connector types and properties"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"timestamp-column"},"children":[{"type":"text","value":"Timestamp Column"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In the Core Properties section, set the Timestamp Column. The value of this property should indicate the exact database column name in your database table that contains either a date/timestamp or a sequence number that indicates when a record has been modified. The value of this column is used by the connector to determine which rows have been modified since the last time it picked up changes from the table."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nFor detecting changes in Salesforce, the column name should be "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"LastModifiedDate"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If an invalid column name is configured, the connector stops."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image19.png","alt":"The Timestamp Column property value in the Core Properties section, which has been set as CHANGETIME"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"processing-delay"},"children":[{"type":"text","value":"Processing Delay"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This property can be used if there is a need for a delay in the processing of changes by the connector. For example, if there are two or more processes that update the source table at the same time, and they take about 2 minutes each to run, the processing delay can be set at anywhere between 4-6 minutes. This delays the processing and makes sure the connector captures all changes coming from both processes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The property value is in seconds, and the default value is "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"0"}]},{"type":"text","value":". If the value is set to "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"<=0"}]},{"type":"text","value":", it means that the property is ignored by the connector. If the value is set to be more than "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"0"}]},{"type":"text","value":", then only the entries between "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"last_cursor"}]},{"type":"text","value":" and "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"current_time â€“ processing_delay"}]},{"type":"text","value":" are processed by the connector. If an invalid, non-numeric value is set for this property, the connector stops."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"sql-filter-2"},"children":[{"type":"text","value":"SQL Filter"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"SQL filter is used as part of the request for entries captured by the timestamp connector. Only changes that match the filter are published by the connector."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A SQL filter is either a single expression or several single expressions joined by binary operators and brackets ( ). Possible binary operators are:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"AND"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"OR"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"NOT"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Some examples of valid SQL Filters are:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ID='5'"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ID='5' AND NAME='ALLEN'"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ID='5' AND NAME='ALLEN' OR CITY='SAN FRANCISCO'"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ID='5' AND (NAME='ALLEN' OR CITY='SAN FRANCISCO')"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"NAME LIKE 'AL%'"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"NAME LIKE 'ALLE_'"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the SQL Filter syntax entered into the property is not correct, an error occurs. The connector waits for the length of time specified in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#retry-interval-on-error"},"children":[{"type":"text","value":"Retry Interval on Error"}]},{"type":"text","value":" and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#max-retries-on-error"},"children":[{"type":"text","value":"Max Retries on Error"}]},{"type":"text","value":" property) is exhausted, if the SQL syntax is still invalid, the connector stops. You must either remove or correct the SQL filter before restarting the connector. It is recommended that you set the connector "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#log-level"},"children":[{"type":"text","value":"Log Level"}]},{"type":"text","value":" to "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DEBUG"}]},{"type":"text","value":" and check the connector log for the SQL query ("},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Executing query:"}]},{"type":"text","value":") that is generated to ensure the value entered in the SQL Filter property is translated properly. The capture connector log is located at "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"{RLI_HOME}\\logs\\sync_agents\\{PIPELINE_ID}\\connector.log"}]},{"type":"text","value":" on the RadiantOne node where the sync agent is running. Go to the Server Control Panel > Log Viewer to download and/or view the log file. See the RadiantOne System Administration Guide for details on the Server Control Panel."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the connector should process all changed entries, do not enter a SQL filter."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"query-timeout"},"children":[{"type":"text","value":"Query Timeout"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The default is 0 (no timeout). This is the length of time (in seconds) that the connector waits to receive a response from the backend database. After this time, the connector discards the query and moves on to the next query. If the query timeout is set to 0, the connector waits indefinitely for a response from the backend database."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"force-sequential-counters-2"},"children":[{"type":"text","value":"Force Sequential Counters"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This property accepts a value of"},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"true"}]},{"type":"text","value":" or "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"false"}]},{"type":"text","value":" and dictates how the connector treats entries it picks up from the LOG table that have non-sequential change IDs. The default is "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"true"}]},{"type":"text","value":" meaning that if the connector detects a non-sequential change ID for an entry in the LOG table, it behaves as if there is an error (non-connection error) and the retry logic based on the Max Retries on Error and Retry Interval on Error properties takes effect. Sometimes rows in the log table are not written in the order of the change ID, and if the connector does not wait for the entries to have sequential IDs, some changes could be missed. The connector waits for the length of time specified in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#retry-interval-on-error"},"children":[{"type":"text","value":"Retry Interval on Error"}]},{"type":"text","value":" and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#max-retries-on-error"},"children":[{"type":"text","value":"Max Retries on Error"}]},{"type":"text","value":" property) is exhausted, if it still detects non-sequential change IDs, the connector stops. You can "},{"type":"element","tagName":"a","properties":{"href":"overview.md#manually-update-connector-cursor"},"children":[{"type":"text","value":"manually edit the cursor value"}]},{"type":"text","value":" before restarting the connector to avoid the non-sequential number. Or you can disable the Force Sequential Counters property for the connector."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the connector should ignore non-sequential change IDs, and process all changes immediately, set the property to "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"false"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To learn more about connectors, please read the document that describes properties specific to the "},{"type":"element","tagName":"a","properties":{"href":"database-counter-connector.md"},"children":[{"type":"text","value":"Database Counter connector"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"ldap-connectors"},"children":[{"type":"text","value":"LDAP Connectors"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are two types of LDAP connectors: Changelog and Persistent Search. These connector types are described in this document."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"LDAP (Changelog) connector"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Any LDAP directory that offers a changelog can use the LDAP connector type. This includes the RadiantOne service."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For the changelog functionality, some directories like Oracle ODSEE, must have the changelog and retro changelog plug-in enabled. The connector polls the changelog based on the changelog polling interval parameter. The connector internally keeps track of the last processed change and only processes new changes. If the connector is shut down (either deliberately or due to failure) it can read the changelog and capture all changes that occurred while the connector was offline."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A special user (that represents the \"connector\" user) must exist in the directory. This user must have sufficient rights for detecting changes (reading the changelog). When defining the data source associated with the LDAP (source) backend, enter this user in the connection parameter."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"LDAP Persistent Search connector"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The Persistent Search connector issues a persistent search and gets notified by the directory server when data changes. For directories that offer persistent search, no special configuration is required to enable this function on the LDAP server. If the connector is shut down (either deliberately or due to failure), the delete operations that occurred on the directory are lost. Once the connector is back online there is no way to retrieve the delete operations that occurred while it was down. The only exception to this is for IBM TDS directories. It stores deleted entries and the capture connector is able to read them, and based on timestamp, determine if the change occurred while the connector was offline."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Any LDAP directory that offers a persistent search mechanism can use the Persistent Search connector type. Novell eDirectory is an example of an LDAP source that supports persistent search. Others include Red Hat Directory, IBM TDS, and CA Directory."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"configuration-3"},"children":[{"type":"text","value":"Configuration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Set the connector type in the pipeline configuration by choosing the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Capture"}]},{"type":"text","value":" component. In the Core Properties section, select the connector type from the drop-down list."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image8.png","alt":"The drop-down list for Connector Type with LDAP selected, in the Core Properties section of Configure Pipeline"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"After selecting the Connector Type, configure the connector properties. For properties common to all connectors, see "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#common-properties-for-all-connectors"},"children":[{"type":"text","value":"Configure capture connector types and properties"}]},{"type":"text","value":". The general properties for LDAP connectors are configured in the Core Properties section. Properties related to filtering of events are configured in the Event Filtering section. Properties related to the contents of the messages published by the connector are configured in the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#event-contents"},"children":[{"type":"text","value":"Event Content"}]},{"type":"text","value":" section. All other properties are configured in the Advanced Properties section. "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#polling-interval"},"children":[{"type":"text","value":"Polling interval"}]},{"type":"text","value":"is not required for the LDAP Persistent Search connector. For properties that determine how the connector filters events that are not needed, configure the LDAP Filter, Included Branches and Excluded Branches in the Event Filtering section. These properties are described below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"ldap-filter"},"children":[{"type":"text","value":"LDAP Filter"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To further condition the entries that are published, you can indicate the desired criteria in the LDAP Filter property. This is a post filter, used to qualify which entries are published by the connector. You must enter a valid LDAP filter in the property."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This property can be used to avoid publishing unwanted information."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If a captured entry matches the criteria indicated in the LDAP filter property, it is published by the connector. If it does not, the entry is not published."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the captured change type is delete, and not enough information is known about the entry, the LDAP filter is not used and the entry is published by the connector. For example, if the LDAP filter property contained a value of "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"(l=Novato)"}]},{"type":"text","value":" and the captured entry did not contain an "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"l"}]},{"type":"text","value":" attribute, the LDAP filter is not applied and the entry is published."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the captured change type is not delete (e.g. insert, update, move, etc.), and not enough information is known about the entry, the LDAP filter is still used and the entry is not published. For example, if the LDAP filter property contained a value of "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"(l=Novato)"}]},{"type":"text","value":" and the captured entry did not contain an "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"l"}]},{"type":"text","value":" attribute, the LDAP filter is still applied and the entry is not published by the connector."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nIf a change is made to this property while the connector is running, it must be restarted for the new value to take effect."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"excluded-branches"},"children":[{"type":"text","value":"Excluded Branches"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To further condition the entries that are published, you can indicate one or more branches to exclude. In the Excluded Branches property, enter one or more suffixes associated with entries that should not be published by the connector. Select "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Enter"}]},{"type":"text","value":" after each suffix. An example is shown below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image9.png","alt":"Two suffixes entered in the Excluded Branches property"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the changed entry DN contains a suffix that matches the excluded branches value, or is a change in the exact entry that is listed (e.g. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ou=dept1,ou=com"}]},{"type":"text","value":"), this entry is not published by the connector. Otherwise, the entry is published. This can avoid publishing unwanted information."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nIf both included and excluded branches are used, an entry must satisfy the conditions defined in both settings to be included in the message. The included branches condition(s) is checked first."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If a change is made to this property while the connector is running, the new value is taken into account once the connector re-initializes which happens automatically every 20 seconds."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"included-branches"},"children":[{"type":"text","value":"Included Branches"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To further condition the entries that are published, you can indicate one or more branches to include. In the Included Branches property, enter one or more suffixes associated with entries that should be published by the connector. Select "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Enter"}]},{"type":"text","value":" after each suffix. An example is shown below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image10.png","alt":"Two suffixes entered in the Included Branches property"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the changed entry DN contains a suffix that matches the included branches value, or is a change in the exact entry that is listed (e.g. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ou=dept1,ou=com"}]},{"type":"text","value":"), this entry is published by the connector. Otherwise, the entry is not published. This can avoid publishing unwanted\r\ninformation."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nIf both included and excluded branches are used, an entry must satisfy the conditions defined in both settings to be included in the message. The included branches condition(s) is checked first.\r\nIf you set this value using the vdsconfig command line utility on Windows, separate the branches with a comma. E.g. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"C:\\radiantone\\vds\\bin>vdsconfig.bat set-connector-property -connectorname o_sead_pcache_proxy__dc_seradiant_dc_dom__seradiantad -propertyid includedBranches"}]},{"type":"text","value":"\r\n"},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"-propertyvalue \"[\\\"cn=users,dc=seradiant,dc=dom\\\",\\\"cn=domaingroups,dc=seradiant,dc=dom\\\"]\""}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If a change is made to this property while the connector is running, the new value is taken into account once the connector re-initializes which happens automatically every 20 seconds."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"switch-to-primary-server-in-polling-intervals"},"children":[{"type":"text","value":"Switch to Primary Server (in polling intervals)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This option is relevant for the LDAP changelog connector type."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This option, working in conjunction with the Polling Interval property, allows you to configure how often, if at all, the connector attempts to switch back to the primary server after failover."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To configure the connector to attempt to switch to the primary server, set Switch to Primary Server to a value of "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"4"}]},{"type":"text","value":" or greater. You can set the value to less than "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"4"}]},{"type":"text","value":", but attempting to connect back to the primary server can be time consuming and therefore not recommended to do frequently. For example, if this value is set to "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"1"}]},{"type":"text","value":", the connector makes an attempt every polling interval. If the Switch to Primary Server value is "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"3"}]},{"type":"text","value":", the connector makes an attempt every third polling interval."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To disable attempts to reconnect to the primary server, set this value to "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"zero"}]},{"type":"text","value":". This is the default value."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Changes made to this property's value while the connector is running are immediately taken into account. When the connector starts or restarts and the property value is "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" or higher, the connector attempts to switch to the primary server immediately."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image11.png","alt":"The Switch to Primary Server (in polling intervals) property with a value set to 0"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"failover-algorithm"},"children":[{"type":"text","value":"Failover Algorithm"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This option is relevant for the LDAP changelog connector type."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When a failover happens, the changelog capture connector attempts to find a new cursor. Since this process is inexact, and changenumber sequence can vary across some replica servers, some events may be replayed or lost. The changelog connector maintains a cursor that indicates information related to the last change processed by the connector along with information about possible replica servers in case failover is needed. During failover, the connector searches the changelog of the replica servers and determines minimum and maximum changenumbers across them. Assume that the last processed changenumber stored by the connector is 100 and there are 2 replica servers defined for the backend. During failover, the connector determines the current changenumbers for each of the replicas by searching their changelogs. Assume that replica 1 has changenumber 99 and replica 2 has changenumber 97. When the connector needs to failover, it must decide whether to start processing changes using changenumber 100 (its current last processed change), 97 (changenumber from replica 2), or 99 (changenumber from replica 1)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The Failover Algorithm property allows you to determine how the cursor value gets set during failover, and ultimately determine the quantity of events that are replayed. The property supports values between "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" and "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"4"}]},{"type":"text","value":". The meaning of each is outlined in the table below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image12.png","alt":"The Failover Algorithm property with a value set to 1"},"children":[]}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Value"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Function"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Set this value if..."}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"1"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Sets cursor to the minimum changenumber based on the current changelog numbers of the replica servers. In the example described above, changenumber of 97 is used. This is the default setting."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"You do not want to lose any events. This may result in many events being replayed."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"2"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Sets cursor to maximum changenumber based on the current changelog numbers of the replica servers. In the example described above, changenumber of 99 is used."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"You want to minimize the replaying of events during failover. This may result in some events being lost."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"3"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"The cursor is not changed. The exact last processed changed stored in the connector cursor would be used. In the example described above, changenumber of 100 is used."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"You know that the LDAP servers in the replica have the same changeNumber in "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"cn=changelog"}]},{"type":"text","value":". For example, all RadiantOne nodes in a cluster have the same changeNumber in "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"cn=changelog"}]},{"type":"text","value":"."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"4"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Sets cursor to the last changenumber of the failover server. In the example described above, if replica 1 is the failover server that gets used, changenumber of 99 is used. If replica 2 is the failover server, changenumber of 97 is used."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"You do not want to replay any events during failover. This may result in the loss of many events."}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"active-directory-connectors"},"children":[{"type":"text","value":"Active Directory Connectors"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are three types of Active Directory connectors: USNChanged, DirSync and Hybrid. These connector types are described in this document."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nThe Active Directory USNChanged connector supports AD LDS."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The decision tree below can help guide you on the Active Directory connector type to use."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image13.png","alt":"A decision tree that can guide you on the Active Directory connector type to use"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Active Directory USNChanged connector"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Active Directory keeps track of changes that happen to entries in the directory (by incrementing the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"uSNChanged"}]},{"type":"text","value":" attribute for the entry). Based on a polling interval configured, the connector connects with the user and password configured in the connection string/data source and checks the list of changes stored by Active Directory. The connector internally maintains the last processed change number ("},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"uSNChanged"}]},{"type":"text","value":" value) and this allows for the recovery of all changes that occur even if the connector is down (deliberately or due to failure)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nThis is the connector type that must be used if the backend is an Active Directory Global Catalog. The Active Directory DirSync connector should not be used because it is unable to detect events in sub-domains.**\r\nAlso, If you are pointing the Active Directory connector to the Global Catalog, when a deleted entry is detected, the connector receives only the DN of the deleted entry in the context of the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"CN=Deleted Objects"}]},{"type":"text","value":" container (e.g. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"CN=u1\\0ADEL:2ca20e8c-1748-4e7d-9044-45e64ab8105b,CN=Deleted Objects,DC=t1,DC=f6,DC=rli"}]},{"type":"text","value":"). Transformation logic needs to address how to find the corresponding entry in the target(s) to remove or update them accordingly.**"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the sequence of events is critical, use the "},{"type":"element","tagName":"a","properties":{"href":"#active-directory-dirsync-connector"},"children":[{"type":"text","value":"DirSync connector"}]},{"type":"text","value":" because it processes events in the order in which they occur instead of prioritizing and processing inserts and updates before deletes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nTo detect delete events, the service account used by RadiantOne to connect to the backend Active Directory (configured in the connection string of the RadiantOne data source) must have permissions to search the tombstone objects. More specifically, the LIST CONTENTS and READ PROPERTY permissions to the"},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":" CN=Deleted Objects"}]},{"type":"text","value":" branch are required. Generally, a member of the Administrators group is sufficient. However, some Active Directory servers may require a member of the Domain Admins group. Check with your Active Directory permissions to determine the appropriate credentials required."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Active Directory DirSync connector"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The Active Directory DirSync capture connector retrieves changes that occur to entries in a directory by passing a cookie that identifies the directory state at the time of the previous DirSync search. The first time the DirSync capture connector is started, it stores a cookie in a cursor file. At the next polling interval, the connector performs a DirSync search to detect changes by sending the current cookie. These changes include only the objects and attributes that have changed since the previous state identified by the current cookie. Because it retrieves only changed objects and attributes, the Active Directory DirSync capture connector avoids propagating irrelevant attributes, reducing message size and potentially reducing network congestion. After retrieving changes, a new cookie is obtained, and the cursor file is updated."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nDo not use this connector type if your backend is an Active Directory Global Catalog because it is unable to detect events in sub-domains. Use the "},{"type":"element","tagName":"a","properties":{"href":"overview.md#manually-update-connector-cursor"},"children":[{"type":"text","value":"Active Directory (USNChanged)"}]},{"type":"text","value":" connector instead.\r\nTo detect delete events, the service account used by RadiantOne to connect to the backend Active Directory (configured in the connection string of the RadiantOne data source) must have permissions to search the tombstone objects. Generally, a member of the Administrators group is sufficient. However, some Active Directory servers may require a member of the Domain Admins group. Check with your Active Directory permissions to determine the appropriate credentials required."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The DirSync capture connector is recommended for environments where the sequence of events is critical. The DirSync capture connector processes events in the order in which they occur, unlike the "},{"type":"element","tagName":"a","properties":{"href":"overview.md#manually-update-connector-cursor"},"children":[{"type":"text","value":"Active Directory USNChanged connector"}]},{"type":"text","value":" which prioritizes inserts and updates before deletes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To use the DirSync control, the Bind DN connecting to the directory must have the DS-Replication-Get-Changes extended right, which can be enabled with the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Replicating Directory Changes"}]},{"type":"text","value":" permission, on the root of the partition being monitored. By default, this right is assigned to the Administrator and LocalSystem accounts on domain controllers."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nThe DirSync capture connector does NOT capture changes to calculated attributes such as the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"memberOf"}]},{"type":"text","value":" attribute or moved entries ("},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"modDN"}]},{"type":"text","value":" or "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"modRDN"}]},{"type":"text","value":" operations)."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Active Directory Hybrid connector"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The Active Directory hybrid capture connector uses a combination of the uSNChanged and DirSync change detection mechanisms. The first time the connector starts, it gets a new cookie and the highest "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"uSNchanged"}]},{"type":"text","value":" number. When the connector gets a new change (modify or delete), it makes an additional search using the DN of the entry and fetches the entry from AD. The fetched entry contains the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"uSNChanged"}]},{"type":"text","value":" attribute, so the connector updates the cursor values for both for the cookie and the last processed "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"uSNchanged"}]},{"type":"text","value":" number."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf you are virtualizing and detecting changes from a Global Catalog, then you must use the Active Directory USNChanged changed connector because the Hybrid connector cannot detect change events on sub-domains."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When the connector restarts, uSNChanged detection catches the entries that have been modified or deleted while the connector was stopped. The LDAP search uses the last processed uSN to catch up. After the connector processes all entries, it requests a new cookie from AD (not from the cursor) and switches to DirSync change detection."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"active-directory-connector-failover"},"children":[{"type":"text","value":"Active Directory Connector Failover"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"All Active Directory connectors have the ability to failover to a replica if the primary server is unavailable and the number of failure exceptions exceeds either the "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#max-retries-on-error"},"children":[{"type":"text","value":"Maximum Retries on Error"}]},{"type":"text","value":" or "},{"type":"element","tagName":"a","properties":{"href":"configure-connector-types-and-properties.md#max-retries-on-connection-error"},"children":[{"type":"text","value":"Maximum Retries on Connection Error"}]},{"type":"text","value":" value. This mechanism leverages the Active Directory replication vectors "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"[replUpToDateVector]"}]},{"type":"text","value":", and the failover servers configured at the level of the RadiantOne data source associated with Active Directory, to determinate which server(s) the connector switches to in case of failure. Since the replication vector contains all domains, in addition to some possibly retired domains, the connector narrows down the list of possible failover candidates to only the ones listed as failover servers in the RadiantOne data source associated with the Active Directory backend. If there are no failover server defined for the data source, all domains in the replication vector are possible candidates for failover."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nWhen defining the RadiantOne data source associated with Active Directory, do not use Host Discovery or Load Balancers. You must use the fully qualified machine names for the primary server and failover servers. Do not use IP addresses. Also, it is highly recommended that you list your desired failover servers at the level of the data source. Not only does this make the failover logic more efficient, but it also avoids delays in synchronization."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"[replUpToDateVector]"}]},{"type":"text","value":" definition: The non-replicated attribute "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"replUpToDateVector"}]},{"type":"text","value":" is an optional attribute on the naming context root of every naming context replica. If this vector is unavailable, the connector is suspended."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The ReplUpToDateVector type is a tuple with the following fields:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"uuidDsa"}]},{"type":"text","value":": The invocation ID of the DC that assigned "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"usnHighPropUpdate"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"usnHighPropUpdate"}]},{"type":"text","value":": A USN at which an update was applied on the DC\r\nidentified by "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"uuidDsa"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"timeLastSyncSuccess"}]},{"type":"text","value":": The time at which the last successful replication occurred from the DC identified by "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"uuidDsa"}]},{"type":"text","value":"; for replication latency reporting only."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"[replUpToDateVector]"}]},{"type":"text","value":" example:"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"01ca6e90-7d20-4f9c-ba7b-823a72fc459e @ USN 2210490 @ Time 2005-08-21\n15:54:21\n\n1d9bb4b6-054a-440c-aedf-7a3f28837e7f @ USN 26245013 @ Time 2007-02-27\n10:17:33\n\n24980c9d-39fa-44d7-a153-c0c5c27f0577 @ USN 4606302 @ Time 2006-08-20\n23:33:09"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"sh"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-sh"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-sh"]},"children":[{"type":"text","value":"01ca6e90-7d20-4f9c-ba7b-823a72fc459e @ USN "},{"type":"element","tagName":"span","properties":{"className":["token","number"]},"children":[{"type":"text","value":"2210490"}]},{"type":"text","value":" @ Time "},{"type":"element","tagName":"span","properties":{"className":["token","number"]},"children":[{"type":"text","value":"2005"}]},{"type":"text","value":"-08-21\n"},{"type":"element","tagName":"span","properties":{"className":["token","number"]},"children":[{"type":"text","value":"15"}]},{"type":"text","value":":54:21\n\n1d9bb4b6-054a-440c-aedf-7a3f28837e7f @ USN "},{"type":"element","tagName":"span","properties":{"className":["token","number"]},"children":[{"type":"text","value":"26245013"}]},{"type":"text","value":" @ Time "},{"type":"element","tagName":"span","properties":{"className":["token","number"]},"children":[{"type":"text","value":"2007"}]},{"type":"text","value":"-02-27\n"},{"type":"element","tagName":"span","properties":{"className":["token","number"]},"children":[{"type":"text","value":"10"}]},{"type":"text","value":":17:33\n\n24980c9d-39fa-44d7-a153-c0c5c27f0577 @ USN "},{"type":"element","tagName":"span","properties":{"className":["token","number"]},"children":[{"type":"text","value":"4606302"}]},{"type":"text","value":" @ Time "},{"type":"element","tagName":"span","properties":{"className":["token","number"]},"children":[{"type":"text","value":"2006"}]},{"type":"text","value":"-08-20\n"},{"type":"element","tagName":"span","properties":{"className":["token","number"]},"children":[{"type":"text","value":"23"}]},{"type":"text","value":":33:09"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For more information on Active Directory replication please read "},{"type":"element","tagName":"a","properties":{"href":"http://technet.microsoft.com/en-us/library/cc772726(WS.10).aspx"},"children":[{"type":"text","value":"how the Active Directory replication model works"}]},{"type":"text","value":" and this "},{"type":"element","tagName":"a","properties":{"href":"http://technet.microsoft.com/en-us/magazine/2007.10.replication.aspx"},"children":[{"type":"text","value":"guide to Active Directory replication"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"At run-time, the connector retrieves the entire list of servers defined in the replication vector and reduces the number of possible failover candidates based on failover servers defined in the RadiantOne data source (if any). The list of potential failover servers is stored at each polling interval. When the current server fails, and retries are exhausted, the connector decides to switch to the closest candidate by selecting the server with the maximum timestamp from the up-to-dateness vector. The capture connector's cursor is assigned the value from the up-to-dateness vector for the failover server. If the closest candidate fails as well, the connector tries with a second closest candidate and so on."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Important things to keep in mind about the different Active Directory connector types:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Active Directory USNChanged connector - Due to the lack of Active Directory replication for the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"USNChanged"}]},{"type":"text","value":" attribute, some changes could be missed or replayed on failover."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"For AD LDS backends, a special user for the connector must exist under the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"CN=Configuration"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"CN={...}"}]},{"type":"text","value":" naming context. This account must be configured in the RadiantOne LDAP data source associated with the AD LDS backend. This user must have permissions to read everything under the Root DSE, (e.g. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"CN=Configuration"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"CN={...}"}]},{"type":"text","value":"), and the AD LDS branch that the connector is monitoring for changes. All AD LDS instances must run on different computers and must listen on the same ports."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Active Directory DirSync connector â€“ When the connector fails over to another DC replica, the connector may receive all objects and attributes instead of just the delta since the last request. Therefore, you may notice the number of entries published by the connector is more than you were expecting. This behavior is dictated by the Active Directory server and is out of the control of the connector. Keep this in mind when you define the Max Retries and Retry Intervals for the connector properties. The smaller the number of retries, the higher the chance the connector will failover and the greater potential of receiving all objects and attributes (a full sync) from the domain controller."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Active Directory Hybrid connector â€“ leverages a mix of both USNChanged and DirSync functionalities during failover. After the failover server is found, uSNChanged detection catches the entries that have been modified or deleted since the connector's failure. The LDAP search uses the last processed "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"uSNChanged"}]},{"type":"text","value":" number to catch up. After the connector processes all entries, it requests a new cookie from Active Directory and switches to DirSync change detection."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"ldap-filter-1"},"children":[{"type":"text","value":"LDAP Filter"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This is used for event filtering. To further condition the entries that are published, you can indicate the desired criteria in the LDAP Filter property. This is a post filter, used to qualify which entries are included in the message published by the connector. You must enter a valid LDAP filter in the property."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This property can be used to reduce the size of the message by only including desired entries (that match the filter). This can also help reduce the amount of transformation logic needed because you can easily avoid synchronizing certain entries without needing the logic to abort them in the transformation script."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If a captured entry matches the criteria indicated in the LDAP filter property, it is published in the message by the connector. If it does not, the entry is not published in the message. Information about the skipped entries is in the connector log (with log level 4)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the captured change type is delete, and not enough information is known about the entry, the LDAP filter is not used and the entry is published in the message. For example, if the LDAP filter property contained a value of "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"(l=Novato)"}]},{"type":"text","value":" and the captured entry did not contain an "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"l"}]},{"type":"text","value":" attribute, the LDAP filter is not applied and the entry is published in the message."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the captured change type is not delete (e.g. insert, update, move, etc.), and not enough information is known about the entry, the LDAP filter is still used and the entry is not published into the message. For example, if the LDAP filter property contained a value of "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"(l=Novato)"}]},{"type":"text","value":" and the captured entry did not contain an "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"l"}]},{"type":"text","value":" attribute, the LDAP filter is still applied and the entry is not published in the message."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nThis property can be updated while the connector is running and takes effect without restarting the connector."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"excluded-branches-1"},"children":[{"type":"text","value":"Excluded Branches"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This is used for event filtering. To further condition the entries that are published, you can indicate one or more branches to exclude. In the Excluded Branches property, enter one or more suffixes associated with entries that should not be published by the connector. Select "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Enter"}]},{"type":"text","value":" after each suffix. An example is shown below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image9.png","alt":"Two suffixes entered in the Excluded Branches property"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the changed entry DN contains a suffix that matches the excluded branches value, or is a change in the exact entry that is listed (e.g. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ou=dept1,ou=com"}]},{"type":"text","value":"), this entry is not published by the connector. Otherwise, the entry is published. This can avoid publishing unwanted information."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nIf both included and excluded branches are used, an entry must satisfy the conditions defined in both settings to be included in the message. The included branches condition(s) is checked first."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If a change is made to this property while the connector is running, the new value is taken into account once the connector re-initializes which happens automatically every 20 seconds."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"included-branches-1"},"children":[{"type":"text","value":"Included Branches"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This is used for event filtering. To further condition the entries that are published, you can indicate one or more branches to include. In the Included Branches property, enter one or more suffixes associated with entries that should be published by the connector. Select "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Enter"}]},{"type":"text","value":" after each suffix. An example is shown below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"Media/image10.png","alt":"Two suffixes entered in the Included Branches property"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the changed entry DN contains a suffix that matches the included branches value, or is a change in the exact entry that is listed (e.g. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ou=dept1,ou=com"}]},{"type":"text","value":"), this entry is published by the connector. Otherwise, the entry is not published. This can avoid publishing unwanted information."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nIf both included and excluded branches are used, an entry must satisfy the conditions defined in both settings to be included in the message. The included branches condition(s) is checked first."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If a change is made to this property while the connector is running, the new value is taken into account once the connector re-initializes which happens automatically every 20 seconds."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"determine-move-operations"},"children":[{"type":"text","value":"Determine Move Operations"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"By default, the connector handles changes associated with LDAP modify DN and RDN operations, which change the distinguished name (DN)/relative distinguished name (RDN) of an entry, as an update operation. In the case of modify DN/RDN operations, Active Directory does not provide information about the old DN of the entry making it impossible for the connector to propagate a delete operation for the old DN/entry."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you require DN/RDN changes to be processed by the connector as a "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"modDN/modRDN"}]},{"type":"text","value":" operation (so the target data source(s) get the change as a "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"modDN/modRDN"}]},{"type":"text","value":"), set the Determine Move Operations property to: "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"true"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nThe connector must be restarted for this property to take effect."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When the Determine Move Operations property is enabled, the connector maintains a cache mapping the objectGUID to DN for each Active Directory entry. This allows the connector to detect and propagate the event as a "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"modDN/modRDN"}]},{"type":"text","value":" (move) operation. All entries from Active Directory must be read the first time when the connector starts/restarts to populate the cache. This increases the amount of time it takes for the connector to start and be able to capture changes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nWhen defining the data source for the backend Active Directory, check the Paged Results Control option to ensure that all entries can be retrieved from the backend. This is required for the connector to get all entries in the cache to map objectGUID to DN and support "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"modDN/modRDN"}]},{"type":"text","value":" operations."}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fileAbsolutePath":"/home/runner/work/developer-site/developer-site/.cache/gatsby-source-git/idm/v8.1/documentation/tuning/cache-connector-properties.md","frontmatter":{"title":"Connector Properties"},"headings":[{"id":"overview","value":"Overview","depth":2},{"id":"reset-connector-cursor--detect-new-changes-only","value":"Reset connector cursor â€“ detect new changes only","depth":3},{"id":"message-size","value":"Message size","depth":3},{"id":"database-changelog","value":"Database Changelog","depth":2},{"id":"configuration","value":"Configuration","depth":3},{"id":"log-table-user","value":"Log Table User","depth":3},{"id":"log-table-user-password","value":"Log Table User password","depth":3},{"id":"table-name","value":"Table name","depth":3},{"id":"apply-configuration-to-database","value":"Apply configuration to database","depth":3},{"id":"sql-filter","value":"SQL Filter","depth":3},{"id":"force-sequential-counters","value":"Force Sequential Counters","depth":3},{"id":"database-counter","value":"Database Counter","depth":2},{"id":"supported-database-integer-types","value":"Supported database integer types","depth":3},{"id":"configuration-1","value":"Configuration","depth":3},{"id":"change-type-column","value":"Change Type Column","depth":3},{"id":"counter-column","value":"Counter Column","depth":3},{"id":"sql-filter-1","value":"SQL Filter","depth":3},{"id":"force-sequential-counters-1","value":"Force Sequential Counters","depth":3},{"id":"database-timestamp","value":"Database Timestamp","depth":2},{"id":"supported-database-date-types","value":"Supported database date types","depth":3},{"id":"configuration-2","value":"Configuration","depth":3},{"id":"timestamp-column","value":"Timestamp Column","depth":3},{"id":"processing-delay","value":"Processing Delay","depth":3},{"id":"sql-filter-2","value":"SQL Filter","depth":3},{"id":"query-timeout","value":"Query Timeout","depth":3},{"id":"force-sequential-counters-2","value":"Force Sequential Counters","depth":3},{"id":"ldap-connectors","value":"LDAP Connectors","depth":2},{"id":"configuration-3","value":"Configuration","depth":3},{"id":"ldap-filter","value":"LDAP Filter","depth":3},{"id":"excluded-branches","value":"Excluded Branches","depth":3},{"id":"included-branches","value":"Included Branches","depth":3},{"id":"switch-to-primary-server-in-polling-intervals","value":"Switch to Primary Server (in polling intervals)","depth":3},{"id":"failover-algorithm","value":"Failover Algorithm","depth":3},{"id":"active-directory-connectors","value":"Active Directory Connectors","depth":2},{"id":"active-directory-connector-failover","value":"Active Directory Connector Failover","depth":3},{"id":"ldap-filter-1","value":"LDAP Filter","depth":3},{"id":"excluded-branches-1","value":"Excluded Branches","depth":3},{"id":"included-branches-1","value":"Included Branches","depth":3},{"id":"determine-move-operations","value":"Determine Move Operations","depth":3}]},"toc":{"html":"<ul>\n<li><a href=\"#\">Limits</a>\n<ul>\n<li><a href=\"tuning-limits#global-limits\">Global</a></li>\n<li><a href=\"tuning-limits#custom-limits\">Custom</a></li>\n<li><a href=\"tuning-limits#access-regulation\">Access Regulation</a></li>\n</ul>\n</li>\n<li><a href=\"#\">Identity Views</a>\n<ul>\n<li><a href=\"optimize-views.md\">Optimize the Views</a></li>\n<li><a href=\"persistent-cache.md\">Persistent Cache</a></li>\n</ul>\n</li>\n<li><a href=\"directory-stores.md\">Directory Stores</a></li>\n<li><a href=\"log-settings.md\">Log Settings</a></li>\n</ul>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"#"},"children":[{"type":"text","value":"Limits"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"tuning-limits#global-limits"},"children":[{"type":"text","value":"Global"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"tuning-limits#custom-limits"},"children":[{"type":"text","value":"Custom"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"tuning-limits#access-regulation"},"children":[{"type":"text","value":"Access Regulation"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"#"},"children":[{"type":"text","value":"Identity Views"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"optimize-views.md"},"children":[{"type":"text","value":"Optimize the Views"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"persistent-cache.md"},"children":[{"type":"text","value":"Persistent Cache"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"directory-stores.md"},"children":[{"type":"text","value":"Directory Stores"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"log-settings.md"},"children":[{"type":"text","value":"Log Settings"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fileAbsolutePath":"/home/runner/work/developer-site/developer-site/.cache/gatsby-source-git/idm/v8.1/documentation/tuning/TOC.md","frontmatter":{"title":"Tuning"}}},"pageContext":{"urlPrefix":"idm/v8.1","absolutePath":"/home/runner/work/developer-site/developer-site/.cache/gatsby-source-git/idm/v8.1/documentation/tuning/cache-connector-properties.md","tocRegex":"/(idm/)(v8.1/)?(documentation/)?(tuning/)?(cache-connector-properties.md/)?(TOC.md)/ig","versions":[{"name":"v8.1","displayName":"v8.1"},{"name":"v8.0","displayName":"v8.0"},{"name":"v7.4","displayName":"v7.4"}],"currentRepo":{"name":"idm","displayName":"Identity Data Management","description":"Integrates identity data: contextual, dynamic, and consistent data for administrative and access decisions.","links":[{"text":"SEE ADMIN DOCUMENTATION","href":"/idm/v8.1/#0"},{"text":"SEE DEVELOPER DOCUMENTATION","href":"/idm/v8.1/#1"}],"remote":"https://github.com/radiantlogic-v8/documentation-new.git","patterns":["home-pages/**","documentation/**","javadoc/**"],"deployBranches":[{"name":"v8.1","displayName":"v8.1"},{"name":"v8.0","displayName":"v8.0"},{"name":"v7.4","displayName":"v7.4"}]},"currentRepoWebLink":"https://github.com/radiantlogic-v8/documentation-new","currentVersion":{"name":"v8.1","displayName":"v8.1"},"title":"Connector Properties","description":"Learn about capture connector properties.","tocForCurrentSection":{"textElement":"Tuning","href":null,"children":[{"textElement":"Cache capture connectors","href":"tuning/cache-capture-connectors","children":[]},{"textElement":"Cache connector properties","href":"tuning/cache-connector-properties","children":[]},{"textElement":"Directory stores","href":"tuning/directory-stores","children":[]},{"textElement":"Log settings","href":"tuning/log-settings","children":[]},{"textElement":"Optimize views","href":"tuning/optimize-views","children":[]},{"textElement":"Persistent cache","href":"tuning/persistent-cache","children":[]},{"textElement":"T O C","href":"tuning/TOC","children":[]},{"textElement":"Tuning limits","href":"tuning/tuning-limits","children":[]}]}}},"staticQueryHashes":["63159454"],"slicesMap":{"footer":"footer","header":"header"}}