{"componentChunkName":"component---src-templates-base-page-js","path":"/hardware-sizing-guide/hardware-sizing-guide/","result":{"data":{"pageContent":{"html":"<h1 id=\"radiantone-hardware-sizing-guide\">RadiantOne Hardware Sizing Guide</h1>\n<h2 id=\"introduction-contents\">Introduction Contents</h2>\n<p>Hardware sizing is a critical component of directory service planning and deployment. When sizing hardware, both the amount of memory and the amount of local disk space available are of key importance.</p>\n<p>RadiantOne runs as a multi-threaded Java program, and is built to scale across multiple processors. In general, the more processing power available, the better. However, in practice, adding memory, faster disks, or faster network connections can enhance performance more than additional processors.</p>\n<p>When deploying a cluster, nodes must be running on hardware that is configured for optimal redundancy and highly reliable connectivity between the cluster nodes/machines.</p>\n<p>The information in this guide provides a basis for capacity planning that helps ensure that the virtual directory server hardware is adequate for handling peak loads. The following minimum requirements must be met and might be inadequate for a production environment. For best results, install and configure a test system with a subset of entries representing those used in production. You can then use the test system to approximate the behavior of the production server.</p>\n<ul>\n<li>CPU Cores - minimum 2 cores.</li>\n<li>Machine Memory - minimum 15GB.</li>\n<li>Disk Throughput - minimum 100MB/sec.</li>\n<li>Disk Space - minimum 20GB.</li>\n<li>DNS resolution - all hostnames must be resolvable.</li>\n<li>Zookeeper network latency - maximum 15ms.</li>\n<li>Zookeeper read throughput - minimum 25MB/sec.</li>\n<li>Zookeeper write throughput - minimum 5MB/sec.</li>\n<li>Linux Open File Descriptors - minimum 48k.</li>\n<li>Linux Maximum resident set size - requires unlimited.</li>\n<li>Linux Memory Map Areas for processes - minimum 256KB.</li>\n<li>Linux Swappiness - swap to be disabled or swappiness &#x3C;=20.</li>\n<li>Linux Maximum amount of virtual memory available to a process launched by the user associated with the RadiantOne installation - requires unlimited.</li>\n</ul>\n<h2 id=\"virtual-machine-settings\">Virtual Machine Settings</h2>\n<p>All aspects in this guide should be considered when deploying RadiantOne on Virtual Machines (VMs). However, some VM-specific items to consider are described in this section.</p>\n<h3 id=\"memory-ballooning\">Memory Ballooning</h3>\n<p>Memory ballooning in the hypervisor should be disabled as it is a feature that can impact the throughput performance of RadiantOne. In typical deployments, the primary function of RadiantOne is processing end user authentication and authorization. The user experience is highly dependent on the efficient processing of these requests. To ensure the consistent availability of free memory assigned to RadiantOne FID by VMWare, it is highly recommended that Memory Ballooning be turned off for the Virtual Machines hosting RadiantOne. If Memory Ballooning is enabled and triggered, the EXSi Host may claim free memory from the Virtual Machine host causing subsequent authentication and authorization requests processed by RadiantOne to page to disk frequently, significantly reducing the processing throughput of the server and negatively impacting the end users.</p>\n<h3 id=\"memory-requirements\">Memory Requirements</h3>\n<p>The memory requirements/allocation to the virtual machine must meet the minimum requirements. The memory requirements for RadiantOne are sometimes considered high for allocating to standard virtual machines and this is often a contributing factor to the decision made to go with “physical” or “virtual” hardware for the product deployment. The RadiantOne specifications recommends at least 16GB of RAM and it is not unusual to have a deployment with a higher amount of memory depending on the number of identities, complexity of the views and number of persistent caches.</p>\n\n          <codeblockcopytag>VM Memory (needed) = guest OS memory + JVM Memory where JVM Memory = JVM\r\nMax Heap (-Xmx value) + Perm Gen (-XX:MaxPermSize) +\r\nNumberOfConcurrentThreads * (-Xss)</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">VM Memory (needed) = guest OS memory + JVM Memory where JVM Memory = JVM\r\nMax Heap (-Xmx value) + Perm Gen (-XX:MaxPermSize) +\r\nNumberOfConcurrentThreads * (-Xss)</code></pre></div>\n<p>JVMs running on virtual machines have an active heap that must always be present in physical memory. Use the VMware vSphere® Client™ to set the reservation equal to the needed virtual machine memory.</p>\n\n          <codeblockcopytag>Reservation Memory = VM Memory = guest OS Memory + JVM Memory</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Reservation Memory = VM Memory = guest OS Memory + JVM Memory</code></pre></div>\n<h3 id=\"network-interface\">Network Interface</h3>\n<p>One network interface (1GB or greater) of the Hypervisor should be dedicated to RadiantOne as low network latency and high network throughput are desired.</p>\n<h3 id=\"vcpu\">vCPU</h3>\n<p>For performance-critical enterprise Java applications virtual machines in production, make sure that the total number of vCPUs assigned to all of the virtual machines does not cause greater than 80% CPU utilization on the ESX/ESXi host.</p>\n<p>Do not oversubscribe to CPU cycles that you do not really need.</p>\n<h3 id=\"timekeeping\">Timekeeping</h3>\n<p>Time synchronization between cluster nodes is imperative! It is recommended to reduce the polling interval to 15 minutes. As timekeeping is different with virtual machines, please follow the recommendations made by the hypervisor vendor. Example, for VMWare:</p>\n<p><a href=\"http://www.vmware.com/files/pdf/Timekeeping-In-VirtualMachines.pdf\">http://www.vmware.com/files/pdf/Timekeeping-In-VirtualMachines.pdf</a>\r\n<a href=\"%60http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&#x26;cmd=displayKC&#x26;externalId=%60\">http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&#x26;cmd=displayKC&#x26;exte</a></p>\n<p>Timekeeping can have an effect on Java programs if they are sensitive to accurate measurements over periods of time, or if they require a timestamp that is within an exact tolerance (such as a timestamp on a shared document or data item). VMware Tools contains features that are installable on the guest operating system to enable time synchronization. Use of those tools is recommended. The frequency of timer interrupts can also affect the performance of your Java application.</p>\n<p>Synchronize the time on the ESX/ESXi host with an NTP source. Synchronize the time in the virtual machine’s guest operating system:</p>\n<ul>\n<li>For Linux guest operating systems use an external NTP source. See the preceding reference.</li>\n<li>For Windows guest operating systems use W32Time. Refer to your Windows administration guide for detailed information. Lower the clock interrupt rate on the virtual CPUs in your virtual machines by using a guest operating system that allows lower timer interrupts. Examples of such operating systems are RHEL 4.7 and later, RHEL 5.2 and later, and SUSE Linux Enterprise Server 10 SP2.</li>\n</ul>\n<p>Use the Java features for lower resolution timing that are supplied by your JVM, such as the option for the Sun JVM on Windows guest operating systems: -XX:+ForceTimeHighResolution</p>\n<p>You can also set the _JAVA_OPTIONS variable to this value on Windows operating systems using the technique given (useful in cases where you cannot easily change the Java command\r\nline). The following is an example of how to set the Sun JVM option. To set the _JAVA_OPTIONS environment variable: Select Start > Settings > Control Panel > System > Advanced > Environment Variables. Select New under System Variables. The variable name is _JAVA_OPTIONS. The variable value is -XX:+ForceTimeHighResolution. Restart the guest operating system to propagate the variable. For Windows guest operating systems that use an SMP HAL, avoid using the /usepmtimer option in the boot.ini system configuration.</p>\n<h3 id=\"vertical-scalability\">Vertical Scalability</h3>\n<p>Virtual machines with a guest OS that supports hot add CPU and hot add memory can take advantage of the ability to change the virtual machine configuration at runtime without any interruption to virtual machine operations. This is particularly useful when you are trying to increase the ability of the virtual machine to handle more traffic.</p>\n<h3 id=\"horizontal-scalability\">Horizontal Scalability</h3>\n<p>When creating clusters, enable VMware HA and VMware DRS:</p>\n<p>VMware HA – Detects failures and provides rapid recovery for the VM running in a cluster. Core functionality includes host monitoring and VM monitoring to minimize downtime.</p>\n<p>VMware DRS – Enables VMware vCenter Server™ to manage hosts as an aggregate pool of resources. Cluster resources can be divided into smaller pools for users, groups, and virtual machines. It enables VMware vCenter™ to manage the assignment of virtual machines to hosts automatically, suggesting placement when virtual machines are powered on, and migrating running virtual machines to balance loads and enforce allocation policies.</p>\n<h2 id=\"disk-speed-and-space\">Disk Speed and Space</h2>\n<p>The Lucene-based storage is heavy on I/O when indexing because segments are merged and optimized generating a lot of I/O. Solid State Drives (SSD) are recommended, and if used on Linux, you should set the I/O scheduler to deadline or noop.</p>\n<p>Disk performance is also critical for ZooKeeper which must have low latency disk writes in order to perform optimally. You can use autopurge.purgeInterval and autopurge.snapRetainCount to automatically cleanup ZooKeeper data and reduce maintenance overhead.</p>\n<p>Disk mirroring is strongly advised (RAID configuration). Avoid using NAS due to latency issues and single point of failure.</p>\n<p>On Windows systems, format drives as NTFS rather than FAT. FAT is not supported for use with the Virtual Directory Server. NTFS allows access controls to be set on files and directories and doesn’t have the file size limitations present in FAT.</p>\n<p>Minimum recommended disk space is 500 GB. Depending on your deployment architecture, a variety of different local storages might be used and can consume varying amounts of disk\r\nspace.</p>\n<p>The recommended minimum data transfer rate is 150 MB/sec.</p>\n<p>See Table 1 below for details on how to estimate disk space requirements.</p>\n<p>Table 1: Recommended Disk Space</p>\n<table>\n<thead>\n<tr>\n<th>Local Store Usage</th>\n<th>Free Local Disk Space</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Universal Directory (HDAP stores)</strong> <br> RadiantOne offers a scalable local storage that can store any entries. This is known as a Universal Directory module</td>\n<td>Calculated by multiplying the size of the LDIF file (containing all entries) by 2. As an example, 1,000,000 entries approximately 1KB in size = 1 GB x 2= 2 GB disk space</td>\n</tr>\n<tr>\n<td><strong>Persistent Cache (local)</strong> <br> Persistent cache is actually the cache image stored on disk. The cache image is stored in the local RadiantOne FID where it is configured. With persistent cache, RadiantOne FID can offer a guaranteed level of performance because the underlying data source(s) do not need to be queried and once the server starts, the cache is ready without having to “prime” with an initial set of queries.</td>\n<td>Calculated by multiplying the size of the LDIF file (containing all entries) by 2. As an example, 1,000,000 entries approximately 1KB in size = 1 GB x 2= 2 GB disk space.</td>\n</tr>\n<tr>\n<td><strong>Changelog</strong> <br> The changelog is the recommended approach for other processes to detect changes that have happened to virtual entries. <br> If enabled (which it is by default), the change log stores all modifications made to any entry in the virtual namespace including entries that are stored in persistent cache. The contents of the change log can be viewed below the cn=changelog suffix in the directory.</td>\n<td>Calculated by multiplying the size of the LDIF file (containing all entries) by 2. As an example, 1,000,000 entries approximately 1KB in size = 1 GB x 2= 2 GB disk space. <br> To prevent the changelog growing forever (and filling up disk space), it is recommended to set a Max Age value on the Main Control Panel >Settings tab > Logs section > Changelog sub-section.</td>\n</tr>\n<tr>\n<td><strong>Replication Journal</strong> <br> If inter-cluster replication is enabled, a replication journal stores changes that happen on the configured naming context. The replication journal is associated with the default data source defined as replicationjournal and root naming context named cn=replicationjournal. Other clusters can pick up changes from the replication journal to update their local image. If you have not deployed multiple clusters, then the replication journal is not used.</td>\n<td>Calculated by multiplying the approximate size of the entries by 2. As an example, 1,000,000 changed entries approximately 1KB in size = 1 GB x 2= 2 GB disk space. <br> By default all entries in the replication journal older than 3 days are removed. Therefore, when sizing disk space you should estimate how many changes are expected to happen during a three day period and multiply the total size of these entries by 2.</td>\n</tr>\n<tr>\n<td><strong>Local Journal</strong> <br> If multi-master inter-cluster replication is enabled (for Universal Directory/HDAP stores) and a site is unable to connect to the replication journal to log a change, the change is temporarily logged locally into cn=localjournal. Changes are queued in the local journal until the connection to the replication journal can be re-established.</td>\n<td>Calculated by multiplying the approximate size of the entries by 2. As an example, 1,000,000 changed entries approximately 1KB in size could not be published to the replication journal due to connection problems = 1 GB x 2= 2 GB disk space.  <br> By default, changes remain in the cn=localjournal for three days and after are automatically removed. Therefore, when sizing disk space you should estimate how many changes are expected to happen during a three day period (assuming all of these changes couldn’t be published to the replication journal during this time) and multiply the total size of these entries by 2.</td>\n</tr>\n<tr>\n<td><strong>Tombstone</strong> <br> If inter-cluster replication is enabled, a “tombstone” storage stores all deleted entries that happen on the configured naming context. cn=tombstone is the naming context that stores these entries.</td>\n<td>Calculated by multiplying the approximate size of the deleted entries by 2. As an example, 1,000,000 deleted entries approximately 1KB in size = 1 GB x 2= 2 GB disk space. <br> By default, deleted entries remain in the cn=tombstone for three days and after are automatically removed. Therefore, when sizing disk space you should estimate how many delete operations are expected to happen during a three day period and multiply the total size of these entries by 2.</td>\n</tr>\n<tr>\n<td><strong>Cache Refresh Log</strong> <br> Update activity performed against a persistent cache is logged below a branch in the virtual namespace named cn=cacherefreshlog. This storage is always enabled for persistent cached branches and the “content”/log level can be set to all, status, or just errors. The level is set on the Main Control Panel > Settings Tab > Logs section > Changelog sub-section, Persistent Cache Refresh Log Level parameter.</td>\n<td>Calculated by multiplying the approximate size of the cached entries by 2. As an example, 1,000,000 changed persistent cache entries approximately 1KB in size = 1 GB x 2= 2 GB disk space. <br> The size and number of the entries logged into the cn=cacherefreshlog varies depending on log level. <br> If all log level is selected, the cn=cacherefreshlog branch contains all requests (successful or not) to refresh the persistent cache. This includes information about the exact changes (what information changed). The attribute named ‘changes’ contains the attribute level changes. <br> The difference between status level and all level is that all only logs entries that have actually changed whereas status level logs all changes coming into the persistent cache whether the actual entry has changed or not. <br> Log level of <em>error</em> only logs entries that fail to be updated in the persistent cache.</td>\n</tr>\n<tr>\n<td><strong>ZooKeeper snapshots</strong> <br> ZooKeeper maintains snapshots and transaction logs of its configuration. A new snapshot is created every time ZooKeeper starts and when zookeeper.snapCount is reached (dictated by the Java system property: zookeeper.snapCount). By default, a maximum of 3 snapshots are saved. The snapshots are saved here: &#x3C;RLI_HOME>\\apps\\zookeeper\\data\\version-2 folder. The number of snapshots created can temporarily exceed 3 due to the autopurge.purgeInterval which is set to 3 hours by default. If there are many transactions (configuration changes) during this 3 hour timeframe, there can be a lot of snapshots and transaction log files created. For example, if you use ICS, and the connectors are capturing many changes, the number of writes to ZooKeeper that are performed (to write last processed change number...etc.) can be quite high resulting in exceeding the 10,000 transaction snapCount and more snapshots and transaction logs being created. This could easily consume several GB of disk space so must be taken into account.</td>\n<td>Keep an eye on the size of the &#x3C;RLI_HOME>\\apps\\zookeeper\\data\\version-2 folder. <br> You can reduce the number of files accumulating in this location by reducing the purge interval (autopurge.purgeInterval in &#x3C;RLI_HOME>\\apps\\zookeeper\\conf\\zoo.cfg). Restart ZooKeeper after making changes to this file. If RadiantOne is deployed in a cluster, stop and restart ZooKeepers on all nodes.</td>\n</tr>\n</tbody>\n</table>\n<p>Additional disk space required for log files is calculated separately and recommendations can be seen in Table 2 below.</p>\n<p>Volume for logs depends on how RadiantOne is configured. Please refer to the RadiantOne Logging and Troubleshooting Guide for details on configuring logging.</p>\n<p>Total disk space recommended = (disk space for entries) + (disk space for logs).</p>\n<p>Table 2: Recommended disk space for log files</p>\n<table>\n<thead>\n<tr>\n<th>Log File Name</th>\n<th>Free Local Disk Space</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>vds_server.log</strong> <br> This log file is zipped (to reduce the size) and archived when it reaches the rollover size. The maximum number of log files to archive and rollover size are configurable from the Main Control Panel > Settings tab > Logs section > Log Settings sub-section. Since this log is archived when it reaches the rollover size, you could have more than one archived log file for each day – syntax of these files is vds_server_<code class=\"language-<year\">-&lt;month</code>.log).</td>\n<td>This varies depending on how many days of log files you would like to keep. 2 GB worth of log files could be generated daily (possibly more if you have increased the number of archived files to keep).</td>\n</tr>\n<tr>\n<td><strong>vds_server_access.log</strong> <br> This log file is archived when the size reaches the rollover size. Archived files are kept for 30 days by default. These settings are configurable from the Main Control Panel > Settings tab > Logs section > Access Logs sub-section. <br> The log output format can be text and/or CSV. Text is the default. If CSV is also enabled, the settings configured on the Main Control Panel -> Settings tab -> Logs section -> Access Logs sub-section are applicable to it as well.</td>\n<td>This varies depending on how long you would like to keep archived logs and how many log output formats are used. Amount of log files generated daily depends on if both text and CSV formats are configured.</td>\n</tr>\n<tr>\n<td>Other miscellaneous log files related to Jetty and VRS (found in &#x3C;RLI_HOME>/vds_server/logs), ZooKeeper (found in &#x3C;RLI_HOME>/logs/zookeeper) and synchronization/persistent cache refresh (found in &#x3C;RLI_HOME>/r1syncsvcs/log).</td>\n<td>Add at least 20 GB</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"linux-memory-map-areas\">Linux Memory Map Areas</h2>\n<p>Check the value for the number of discrete mapped memory areas with the following command:</p>\n<p>sysctl vm.max_map_count</p>\n<p>The default value is 65536.</p>\n<p>For most deployments, the default is too low. It is recommended to increase it to 262144 in /etc/sysctl.conf file. This file contains the maximum number of memory map areas a process may have.</p>\n<h2 id=\"linux-user-limits\">Linux User Limits</h2>\n<p>For Linux, the number of file descriptors should be set to at least 65536. Check the amount with:</p>\n\n          <codeblockcopytag>\\$ ulimit -n</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ulimit -n</code></pre></div>\n<p>Confirm that ulimit -v and -u return unlimited to prevent problems with the amount of virtual\r\naddress space that can be allocated.</p>\n<p>Also, set shell limits for the Max Number of Processes. These steps are described below.</p>\n<ol>\n<li>As root, open the system's /etc/security/limits.conf file.</li>\n<li>Add two lines that set the hard and soft limits for the number of processes (nproc) for the Directory Server user. The soft limit sets how many processes the user has available by default; the user can manually adjust that setting until they hit the hard limit.</li>\n</ol>\n\n          <codeblockcopytag>user soft nproc 2047\r\n\r\nuser hard nproc 16384</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">user soft nproc 2047\r\n\r\nuser hard nproc 16384</code></pre></div>\n<blockquote>\n<p><span style=\"color:red\"><strong>IMPORTANT NOTE - Do not set the hard limit for the Directory Server user equal to (or higher than) the maximum number of file descriptors assigned to the system itself in /proc/sys/fs/file-max. If the hard limit is too high and the user users all of those file descriptors, then the entire system runs out of file descriptors.</strong></p>\n</blockquote>\n<h2 id=\"linux-swap-space\">Linux Swap Space</h2>\n<p>Swap space in Linux is used when the amount of physical memory (RAM) is full. If the system needs more memory resources and the RAM is full, inactive pages in memory are moved to the swap space. While swap space can help machines with a small amount of RAM, it should not be considered a replacement for more RAM. Swap space is located on hard drives, which have a slower access time than physical memory. This means RadiantOne performance is impacted if swap space starts to be used.</p>\n<p>The setting that controls how often the swap file is used is called swappiness. A swappiness setting of zero means that the disk will be avoided unless absolutely necessary (you run out of memory). Swap should be disabled if possible (/etc/fstab) or configured to prevent swapping under normal usage (set vm.swappiness to a value &#x3C;=20 which is the percentage of RAM left before the system starts to swap). Reboot your system for the change to take effect.</p>\n<h2 id=\"network-capacity\">Network Capacity</h2>\n<p>RadiantOne is a network-intensive application, and for each client application request, it may send multiple operations to different data sources. Make sure the network connections between RadiantOne and your backend data sources are fast, with plenty of bandwidth and low latency. Also make sure the connections between client applications and the RadiantOne service can handle the amount of traffic you expect.</p>\n<p>Testing has demonstrated that 100 Mbit Ethernet may be sufficient for classic (active/active or active/passive architectures) depending on the maximum throughput expected. You may estimate theoretical maximum throughput as follows:</p>\n<p>max. throughput = max. entries returned/second x average entry size</p>\n<p>Imagine for example that a Directory Server must respond to a peak of 6000 searches per second for which it returns 1 entry each with entries having average size of 2000 bytes, then the theoretical maximum throughput would be 12 MB, or 96 Mbit. 96 Mbit is likely to be more than a single 100 Mbit Ethernet adapter can provide. Actual observed performance may vary.</p>\n<p>If you expect to perform multi-master replication (replication across clusters, or replication across active/active or active/passive classic architectures) over a wide area network, ensure the connection provides sufficient throughput with minimum/low latency and near-zero packet\r\nloss.</p>\n<blockquote>\n<p><span style=\"color:red\"><strong>IMPORTANT NOTE - If you intend to deploy RadiantOne in a cluster, on the same network for load balancing purposes, ensure the network infrastructure can support the additional load generated. 1 Gb minimum (this is a basic network card speed) between the cluster nodes is required. It is preferable to have the nodes connected to the same network switch. If you are deploying RadiantOne cluster nodes on Virtual Machines (VM), ensure the network capacity allocated to the VMs is 1 Gb minimum.</strong></p>\n</blockquote>\n<p>If you intend to support high update rates for replication in a wide area network environment, ensure through empirical testing that the network quality and bandwidth meet your requirements for replication throughput. When deploying multiple clusters or a classic active/active or active/passive architecture (clusters or individual servers across different networks), to ensure optimal inter-cluster/multi-master replication speeds, 1 Gb is preferred.</p>\n<h3 id=\"sizing-for-ssl\">Sizing for SSL</h3>\n<p>By default, support for the Secure Sockets Layer (SSL) protocol is implemented in RadiantOne.</p>\n<p>Using the software-based SSL implementation may have significant negative impact on the Directory Server performance. Running the directory in SSL mode may require the deployment of several directory replicas to meet overall performance requirements.</p>\n<h2 id=\"memory\">Memory</h2>\n<p>Adequate memory is key to optimum performance. As a general rule, the more memory available, the more directory information can be cached for quick access.</p>\n<p>Estimating memory size required to run RadiantOne involves estimating the memory needed both for a specific RadiantOne configuration, and for the underlying system on which it runs. These two aspects are described in this section.</p>\n<h3 id=\"sizing-memory-for-radiantone\">Sizing Memory for RadiantOne</h3>\n<p>The minimum machine memory to deploy RadiantOne (up to a total of 1 million entries of roughly 1KB in size stored in either persistent cache or in a local Universal Directory/HDAP store) is 16 GB. Keep in mind, for persistent cached views, computations and joins that might need to happen prior to caching often dictate a requirement of more than 16 GB. To provide another example, 20 million entries (~1 KB in size) stored in Universal Directory (HDAP store) would require 64 GB of RAM on the machine (not specifically allocated to the RadiantOne FID JVM).</p>\n<p>Table 3 summarizes the values used for the calculations in this section.</p>\n<p>Table 3: Default Memory Allocation</p>\n<table>\n<thead>\n<tr>\n<th>RadiantOne Component</th>\n<th>Description</th>\n<th>Default Memory</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>RadiantOne FID</strong></td>\n<td>Includes: Correlation engine, In-memory cache(query and entry), Interception scripts, Web services (REST, SCIM,SPML, DSML), Join Engine, Security (ACL), Computed Attributes.</td>\n<td>1 GB, automatically expanding up to ¼ of machine memory <br> *See additional comments below.</td>\n</tr>\n<tr>\n<td><strong>ZooKeeper</strong></td>\n<td>Responsible for cluster orchestration and configuration management.</td>\n<td>3 GB <br> *See additional comments below.</td>\n</tr>\n<tr>\n<td><strong>Universal Directory (HDAP stores)</strong></td>\n<td>Storage for persistent cache, extension attribute and Universal Directory stores including cn=changelog and cn=replicationjournal.</td>\n<td>Calculated based on: <Size of LDIF file> x 2 <br> Note - Lucene leverages the OS file system cache for its disk-based data. Java heap size is not applicable. <br> When the RadiantOne platform is deployed only with the Universal Directory module, on machines with large amounts of memory (e.g. 32GB), it is recommended to set a max JVM (-Xmx) for the RadiantOne FID service instead of letting it expand to ¼ of the available memory. This leaves more memory for the Universal Directory (HDAP) stores to ensure optimal performance.</td>\n</tr>\n<tr>\n<td><strong>Tasks Scheduler</strong></td>\n<td>Schedules tasks.</td>\n<td>1 GB</td>\n</tr>\n<tr>\n<td><strong>Tasks</strong></td>\n<td>Activities that are processed as tasks are: <br> Exporting to LDIF, Importing from LDIF, Login analysis (initiated from the virtual identity wizard), Initializing a persistent cache or Universal Directory (HDAP) store, Re- indexing a persistent cache or Universal Directory (HDAP) store, and the default RadiantOne FID monitoring task.</td>\n<td>512 MB, expanding up to ¼ of the machine memory. <br> *See additional comments below.</td>\n</tr>\n<tr>\n<td><strong>Jetty Application Server</strong></td>\n<td>Hosts the Main Control Panel and the Server Control Panels.</td>\n<td>512 MB</td>\n</tr>\n<tr>\n<td><strong>Real Time Persistent Cache Refresh Agent</strong></td>\n<td>Deploys and manages the real-time persistent cache refresh connectors.</td>\n<td>1 GB <br> The memory allocation is configured in &#x3C;RLI_HOME>/bin/advanced/ start_cacherefresh_realtime_agent.bat/.sh <br> - Xms512m -Xmx</td>\n</tr>\n</tbody>\n</table>\n<p>In addition to the items listed in the table, to estimate approximate machine memory size, you should be aware of the following:</p>\n<ul>\n<li>\n<p>The RadiantOne FID uses memory mainly to hold information that is being processed. Complex aggregations for processing some virtual directory requests against multiple data sources may temporarily use extra memory. You should keep this in consideration in addition to the estimates provided in this section.</p>\n</li>\n<li>\n<p>By default, RadiantOne FID memory expands up to ¼ of the machine memory. For example, if the machine had 16 GB, then the memory would expand to use at most 4 GB. Once the memory requirements are known for your deployment, ensure the minimum and maximum memory allocations are the same to prevent the heavy process of heap resizing at runtime. You can indicate a minimum (-Xms) and maximum amount (-Xmx) value for the JVM process instead of leveraging this automated expansion. For details on configuring memory size, see the RadiantOne Deployment and Tuning Guide.</p>\n<p><span style=\"color:red\"><strong>IMPORTANT NOTE – It is recommended to keep the maximum memory (-Xmx) under 32 GB to ensure the JVM uses compressed oops as a performance enhancement. If this is exceeded, the pointers switch to ordinary object pointers which grow in size, are more CPU-intensive and less efficient. Also, -Xms and -Xmx should be set to the same value to help avoid the performance-costly process of garbage collection from happening too frequently.</strong></p>\n<p><span style=\"color:red\"><strong>It is also important to note that the number of cached entries and indexed attributes configured for memory cache (if used) affect the RadiantOne FID memory usage. The number of cached entries is relevant for memory cache (entry and query). This is the number of entries to be stored in main memory. The default size is 5000 entries. The entry cache is populated as requests are sent to RadiantOne FID. This main memory stores the most recently used entries. Indexed attributes is relevant for memory cache (entry level). This is a list of indexed attributes. The default size is 1000 pages, which means there are, at most, 1000 index pages for each attribute you have indexed. For more details on memory cache, please see the RadiantOne Deployment and Tuning Guide.</strong></p>\n</li>\n<li>\n<p>The memory requirements for persistent cache or Universal Directory (HDAP) stores varies depending on how many entries are stored and can be calculated with: <code class=\"language-<size of ldif file containing all entries\"> x 2 = &lt;MEMORY</code></p>\n<p>E.G. 1M entries (~1KB each) = 1GB LDIF file x 2 = 2GB memory to store this in a Universal Directory (HDAP) store.</p>\n</li>\n<li>\n<p>If your deployment contains a lot of virtual views (a lot of metadata), ZooKeeper can run out of memory, especially during periods where additional cluster nodes are added and the existing configuration must be synchronized to the new nodes. To check the size of the ZooKeeper data, view the folder size located at &#x3C;RLI_HOME>/apps/zookeeper/data/version-2. For large amounts of metadata (e.g. 3GB), ZooKeeper memory should be increased (e.g. -Xmx5g would increase it to 5GB). ZooKeeper memory size can be set in &#x3C;RLI_HOME>/bin/advanced/runZooKeeperBlocking.bat file. An example of setting the memory to 5GB is shown below:</p>\n</li>\n</ul>\n\n          <codeblockcopytag>&quot;%RLI_JHOME%\\bin\\java&quot; –Xmx5g -cp &quot;%ZOO_CP%&quot;\r\n&quot;com.rli.zookeeper.commands.ZooKeeperServerWrapper&quot;\r\n&quot;%RLI_RHOME%\\apps\\zookeeper\\conf\\zoo.cfg&quot;</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"%RLI_JHOME%\\bin\\java\" –Xmx5g -cp \"%ZOO_CP%\"\r\n\"com.rli.zookeeper.commands.ZooKeeperServerWrapper\"\r\n\"%RLI_RHOME%\\apps\\zookeeper\\conf\\zoo.cfg\"</code></pre></div>\n<ul>\n<li>The Task Scheduler requires approximately 1 GB to schedule tasks. The actual tasks themselves each run inside their own JVM. For cache initialization containing a large number of entries (e.g. 1 million) it is recommended you manually define the memory used by the task to at least 8GB. This speeds up the cache initialization. For more details on Tasks and how to tune the JVM, please see the System Administration Guide.</li>\n</ul>\n<p>You may use utilities such as sar on Linux systems or the Windows Task Manager to measure physical memory used by the RadiantOne processes.</p>\n<h3 id=\"sizing-memory-for-the-operating-system\">Sizing Memory for the Operating System</h3>\n<p>Estimating the base amount of memory needed to run the underlying operating system must be done empirically, as operating system memory requirements vary widely based on the specifics of the system configuration. You may use utilities such as sar on Linux systems or the Task Manager on Windows to measure memory use.</p>\n<p>You should also allocate enough memory for general system overhead and normal administrative use. Ideally, you will allocate enough space for overhead so that the system avoids swapping pages in and out of memory while in production.</p>\n<p>The system total memory needed by the operating system, can then be estimated as follows:</p>\n\n          <codeblockcopytag>Total = Base amount + Overhead amount</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Total = Base amount + Overhead amount</code></pre></div>\n<h3 id=\"sizing-total-memory\">Sizing Total Memory</h3>\n<p>Given the amount of memory needed for RadiantOne plus the amount needed for the Operating System (OS) described in the previous sections, you can estimate the total memory needed.</p>\n\n          <codeblockcopytag>Total Memory = RadiantOne memory + OS memory</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Total Memory = RadiantOne memory + OS memory</code></pre></div>\n<p>Total memory is an estimate of the total memory needed, including the assumption that the system is dedicated to the RadiantOne, and includes estimated memory use for all other applications and services expected to run on the system.</p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{"id":"radiantone-hardware-sizing-guide"},"children":[{"type":"text","value":"RadiantOne Hardware Sizing Guide"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"introduction-contents"},"children":[{"type":"text","value":"Introduction Contents"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Hardware sizing is a critical component of directory service planning and deployment. When sizing hardware, both the amount of memory and the amount of local disk space available are of key importance."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"RadiantOne runs as a multi-threaded Java program, and is built to scale across multiple processors. In general, the more processing power available, the better. However, in practice, adding memory, faster disks, or faster network connections can enhance performance more than additional processors."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When deploying a cluster, nodes must be running on hardware that is configured for optimal redundancy and highly reliable connectivity between the cluster nodes/machines."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The information in this guide provides a basis for capacity planning that helps ensure that the virtual directory server hardware is adequate for handling peak loads. The following minimum requirements must be met and might be inadequate for a production environment. For best results, install and configure a test system with a subset of entries representing those used in production. You can then use the test system to approximate the behavior of the production server."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"CPU Cores - minimum 2 cores."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Machine Memory - minimum 15GB."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Disk Throughput - minimum 100MB/sec."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Disk Space - minimum 20GB."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"DNS resolution - all hostnames must be resolvable."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Zookeeper network latency - maximum 15ms."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Zookeeper read throughput - minimum 25MB/sec."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Zookeeper write throughput - minimum 5MB/sec."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Linux Open File Descriptors - minimum 48k."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Linux Maximum resident set size - requires unlimited."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Linux Memory Map Areas for processes - minimum 256KB."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Linux Swappiness - swap to be disabled or swappiness <=20."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Linux Maximum amount of virtual memory available to a process launched by the user associated with the RadiantOne installation - requires unlimited."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"virtual-machine-settings"},"children":[{"type":"text","value":"Virtual Machine Settings"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"All aspects in this guide should be considered when deploying RadiantOne on Virtual Machines (VMs). However, some VM-specific items to consider are described in this section."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"memory-ballooning"},"children":[{"type":"text","value":"Memory Ballooning"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Memory ballooning in the hypervisor should be disabled as it is a feature that can impact the throughput performance of RadiantOne. In typical deployments, the primary function of RadiantOne is processing end user authentication and authorization. The user experience is highly dependent on the efficient processing of these requests. To ensure the consistent availability of free memory assigned to RadiantOne FID by VMWare, it is highly recommended that Memory Ballooning be turned off for the Virtual Machines hosting RadiantOne. If Memory Ballooning is enabled and triggered, the EXSi Host may claim free memory from the Virtual Machine host causing subsequent authentication and authorization requests processed by RadiantOne to page to disk frequently, significantly reducing the processing throughput of the server and negatively impacting the end users."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"memory-requirements"},"children":[{"type":"text","value":"Memory Requirements"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The memory requirements/allocation to the virtual machine must meet the minimum requirements. The memory requirements for RadiantOne are sometimes considered high for allocating to standard virtual machines and this is often a contributing factor to the decision made to go with “physical” or “virtual” hardware for the product deployment. The RadiantOne specifications recommends at least 16GB of RAM and it is not unusual to have a deployment with a higher amount of memory depending on the number of identities, complexity of the views and number of persistent caches."}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"VM Memory (needed) = guest OS memory + JVM Memory where JVM Memory = JVM\nMax Heap (-Xmx value) + Perm Gen (-XX:MaxPermSize) +\nNumberOfConcurrentThreads * (-Xss)"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"VM Memory (needed) = guest OS memory + JVM Memory where JVM Memory = JVM\nMax Heap (-Xmx value) + Perm Gen (-XX:MaxPermSize) +\nNumberOfConcurrentThreads * (-Xss)"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"JVMs running on virtual machines have an active heap that must always be present in physical memory. Use the VMware vSphere® Client™ to set the reservation equal to the needed virtual machine memory."}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"Reservation Memory = VM Memory = guest OS Memory + JVM Memory"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Reservation Memory = VM Memory = guest OS Memory + JVM Memory"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"network-interface"},"children":[{"type":"text","value":"Network Interface"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One network interface (1GB or greater) of the Hypervisor should be dedicated to RadiantOne as low network latency and high network throughput are desired."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"vcpu"},"children":[{"type":"text","value":"vCPU"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For performance-critical enterprise Java applications virtual machines in production, make sure that the total number of vCPUs assigned to all of the virtual machines does not cause greater than 80% CPU utilization on the ESX/ESXi host."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Do not oversubscribe to CPU cycles that you do not really need."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"timekeeping"},"children":[{"type":"text","value":"Timekeeping"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Time synchronization between cluster nodes is imperative! It is recommended to reduce the polling interval to 15 minutes. As timekeeping is different with virtual machines, please follow the recommendations made by the hypervisor vendor. Example, for VMWare:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.vmware.com/files/pdf/Timekeeping-In-VirtualMachines.pdf"},"children":[{"type":"text","value":"http://www.vmware.com/files/pdf/Timekeeping-In-VirtualMachines.pdf"}]},{"type":"text","value":"\r\n"},{"type":"element","tagName":"a","properties":{"href":"%60http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&cmd=displayKC&externalId=%60"},"children":[{"type":"text","value":"http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&cmd=displayKC&exte"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Timekeeping can have an effect on Java programs if they are sensitive to accurate measurements over periods of time, or if they require a timestamp that is within an exact tolerance (such as a timestamp on a shared document or data item). VMware Tools contains features that are installable on the guest operating system to enable time synchronization. Use of those tools is recommended. The frequency of timer interrupts can also affect the performance of your Java application."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Synchronize the time on the ESX/ESXi host with an NTP source. Synchronize the time in the virtual machine’s guest operating system:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"For Linux guest operating systems use an external NTP source. See the preceding reference."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"For Windows guest operating systems use W32Time. Refer to your Windows administration guide for detailed information. Lower the clock interrupt rate on the virtual CPUs in your virtual machines by using a guest operating system that allows lower timer interrupts. Examples of such operating systems are RHEL 4.7 and later, RHEL 5.2 and later, and SUSE Linux Enterprise Server 10 SP2."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Use the Java features for lower resolution timing that are supplied by your JVM, such as the option for the Sun JVM on Windows guest operating systems: -XX:+ForceTimeHighResolution"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"You can also set the _JAVA_OPTIONS variable to this value on Windows operating systems using the technique given (useful in cases where you cannot easily change the Java command\r\nline). The following is an example of how to set the Sun JVM option. To set the _JAVA_OPTIONS environment variable: Select Start > Settings > Control Panel > System > Advanced > Environment Variables. Select New under System Variables. The variable name is _JAVA_OPTIONS. The variable value is -XX:+ForceTimeHighResolution. Restart the guest operating system to propagate the variable. For Windows guest operating systems that use an SMP HAL, avoid using the /usepmtimer option in the boot.ini system configuration."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"vertical-scalability"},"children":[{"type":"text","value":"Vertical Scalability"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Virtual machines with a guest OS that supports hot add CPU and hot add memory can take advantage of the ability to change the virtual machine configuration at runtime without any interruption to virtual machine operations. This is particularly useful when you are trying to increase the ability of the virtual machine to handle more traffic."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"horizontal-scalability"},"children":[{"type":"text","value":"Horizontal Scalability"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When creating clusters, enable VMware HA and VMware DRS:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"VMware HA – Detects failures and provides rapid recovery for the VM running in a cluster. Core functionality includes host monitoring and VM monitoring to minimize downtime."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"VMware DRS – Enables VMware vCenter Server™ to manage hosts as an aggregate pool of resources. Cluster resources can be divided into smaller pools for users, groups, and virtual machines. It enables VMware vCenter™ to manage the assignment of virtual machines to hosts automatically, suggesting placement when virtual machines are powered on, and migrating running virtual machines to balance loads and enforce allocation policies."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"disk-speed-and-space"},"children":[{"type":"text","value":"Disk Speed and Space"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The Lucene-based storage is heavy on I/O when indexing because segments are merged and optimized generating a lot of I/O. Solid State Drives (SSD) are recommended, and if used on Linux, you should set the I/O scheduler to deadline or noop."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Disk performance is also critical for ZooKeeper which must have low latency disk writes in order to perform optimally. You can use autopurge.purgeInterval and autopurge.snapRetainCount to automatically cleanup ZooKeeper data and reduce maintenance overhead."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Disk mirroring is strongly advised (RAID configuration). Avoid using NAS due to latency issues and single point of failure."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On Windows systems, format drives as NTFS rather than FAT. FAT is not supported for use with the Virtual Directory Server. NTFS allows access controls to be set on files and directories and doesn’t have the file size limitations present in FAT."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Minimum recommended disk space is 500 GB. Depending on your deployment architecture, a variety of different local storages might be used and can consume varying amounts of disk\r\nspace."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The recommended minimum data transfer rate is 150 MB/sec."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"See Table 1 below for details on how to estimate disk space requirements."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Table 1: Recommended Disk Space"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Local Store Usage"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Free Local Disk Space"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Universal Directory (HDAP stores)"}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" RadiantOne offers a scalable local storage that can store any entries. This is known as a Universal Directory module"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Calculated by multiplying the size of the LDIF file (containing all entries) by 2. As an example, 1,000,000 entries approximately 1KB in size = 1 GB x 2= 2 GB disk space"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Persistent Cache (local)"}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Persistent cache is actually the cache image stored on disk. The cache image is stored in the local RadiantOne FID where it is configured. With persistent cache, RadiantOne FID can offer a guaranteed level of performance because the underlying data source(s) do not need to be queried and once the server starts, the cache is ready without having to “prime” with an initial set of queries."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Calculated by multiplying the size of the LDIF file (containing all entries) by 2. As an example, 1,000,000 entries approximately 1KB in size = 1 GB x 2= 2 GB disk space."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Changelog"}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" The changelog is the recommended approach for other processes to detect changes that have happened to virtual entries. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If enabled (which it is by default), the change log stores all modifications made to any entry in the virtual namespace including entries that are stored in persistent cache. The contents of the change log can be viewed below the cn=changelog suffix in the directory."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Calculated by multiplying the size of the LDIF file (containing all entries) by 2. As an example, 1,000,000 entries approximately 1KB in size = 1 GB x 2= 2 GB disk space. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" To prevent the changelog growing forever (and filling up disk space), it is recommended to set a Max Age value on the Main Control Panel >Settings tab > Logs section > Changelog sub-section."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Replication Journal"}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If inter-cluster replication is enabled, a replication journal stores changes that happen on the configured naming context. The replication journal is associated with the default data source defined as replicationjournal and root naming context named cn=replicationjournal. Other clusters can pick up changes from the replication journal to update their local image. If you have not deployed multiple clusters, then the replication journal is not used."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Calculated by multiplying the approximate size of the entries by 2. As an example, 1,000,000 changed entries approximately 1KB in size = 1 GB x 2= 2 GB disk space. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" By default all entries in the replication journal older than 3 days are removed. Therefore, when sizing disk space you should estimate how many changes are expected to happen during a three day period and multiply the total size of these entries by 2."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Local Journal"}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If multi-master inter-cluster replication is enabled (for Universal Directory/HDAP stores) and a site is unable to connect to the replication journal to log a change, the change is temporarily logged locally into cn=localjournal. Changes are queued in the local journal until the connection to the replication journal can be re-established."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Calculated by multiplying the approximate size of the entries by 2. As an example, 1,000,000 changed entries approximately 1KB in size could not be published to the replication journal due to connection problems = 1 GB x 2= 2 GB disk space.  "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" By default, changes remain in the cn=localjournal for three days and after are automatically removed. Therefore, when sizing disk space you should estimate how many changes are expected to happen during a three day period (assuming all of these changes couldn’t be published to the replication journal during this time) and multiply the total size of these entries by 2."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Tombstone"}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If inter-cluster replication is enabled, a “tombstone” storage stores all deleted entries that happen on the configured naming context. cn=tombstone is the naming context that stores these entries."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Calculated by multiplying the approximate size of the deleted entries by 2. As an example, 1,000,000 deleted entries approximately 1KB in size = 1 GB x 2= 2 GB disk space. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" By default, deleted entries remain in the cn=tombstone for three days and after are automatically removed. Therefore, when sizing disk space you should estimate how many delete operations are expected to happen during a three day period and multiply the total size of these entries by 2."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Cache Refresh Log"}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Update activity performed against a persistent cache is logged below a branch in the virtual namespace named cn=cacherefreshlog. This storage is always enabled for persistent cached branches and the “content”/log level can be set to all, status, or just errors. The level is set on the Main Control Panel > Settings Tab > Logs section > Changelog sub-section, Persistent Cache Refresh Log Level parameter."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Calculated by multiplying the approximate size of the cached entries by 2. As an example, 1,000,000 changed persistent cache entries approximately 1KB in size = 1 GB x 2= 2 GB disk space. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" The size and number of the entries logged into the cn=cacherefreshlog varies depending on log level. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If all log level is selected, the cn=cacherefreshlog branch contains all requests (successful or not) to refresh the persistent cache. This includes information about the exact changes (what information changed). The attribute named ‘changes’ contains the attribute level changes. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" The difference between status level and all level is that all only logs entries that have actually changed whereas status level logs all changes coming into the persistent cache whether the actual entry has changed or not. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Log level of "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"error"}]},{"type":"text","value":" only logs entries that fail to be updated in the persistent cache."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"ZooKeeper snapshots"}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" ZooKeeper maintains snapshots and transaction logs of its configuration. A new snapshot is created every time ZooKeeper starts and when zookeeper.snapCount is reached (dictated by the Java system property: zookeeper.snapCount). By default, a maximum of 3 snapshots are saved. The snapshots are saved here: <RLI_HOME>\\apps\\zookeeper\\data\\version-2 folder. The number of snapshots created can temporarily exceed 3 due to the autopurge.purgeInterval which is set to 3 hours by default. If there are many transactions (configuration changes) during this 3 hour timeframe, there can be a lot of snapshots and transaction log files created. For example, if you use ICS, and the connectors are capturing many changes, the number of writes to ZooKeeper that are performed (to write last processed change number...etc.) can be quite high resulting in exceeding the 10,000 transaction snapCount and more snapshots and transaction logs being created. This could easily consume several GB of disk space so must be taken into account."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Keep an eye on the size of the <RLI_HOME>\\apps\\zookeeper\\data\\version-2 folder. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" You can reduce the number of files accumulating in this location by reducing the purge interval (autopurge.purgeInterval in <RLI_HOME>\\apps\\zookeeper\\conf\\zoo.cfg). Restart ZooKeeper after making changes to this file. If RadiantOne is deployed in a cluster, stop and restart ZooKeepers on all nodes."}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Additional disk space required for log files is calculated separately and recommendations can be seen in Table 2 below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Volume for logs depends on how RadiantOne is configured. Please refer to the RadiantOne Logging and Troubleshooting Guide for details on configuring logging."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Total disk space recommended = (disk space for entries) + (disk space for logs)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Table 2: Recommended disk space for log files"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Log File Name"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Free Local Disk Space"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"vds_server.log"}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This log file is zipped (to reduce the size) and archived when it reaches the rollover size. The maximum number of log files to archive and rollover size are configurable from the Main Control Panel > Settings tab > Logs section > Log Settings sub-section. Since this log is archived when it reaches the rollover size, you could have more than one archived log file for each day – syntax of these files is vds_server_"},{"type":"element","tagName":"code","properties":{"className":["language-<year"]},"children":[{"type":"text","value":"-<month"}]},{"type":"text","value":".log)."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"This varies depending on how many days of log files you would like to keep. 2 GB worth of log files could be generated daily (possibly more if you have increased the number of archived files to keep)."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"vds_server_access.log"}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This log file is archived when the size reaches the rollover size. Archived files are kept for 30 days by default. These settings are configurable from the Main Control Panel > Settings tab > Logs section > Access Logs sub-section. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" The log output format can be text and/or CSV. Text is the default. If CSV is also enabled, the settings configured on the Main Control Panel -> Settings tab -> Logs section -> Access Logs sub-section are applicable to it as well."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"This varies depending on how long you would like to keep archived logs and how many log output formats are used. Amount of log files generated daily depends on if both text and CSV formats are configured."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Other miscellaneous log files related to Jetty and VRS (found in <RLI_HOME>/vds_server/logs), ZooKeeper (found in <RLI_HOME>/logs/zookeeper) and synchronization/persistent cache refresh (found in <RLI_HOME>/r1syncsvcs/log)."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Add at least 20 GB"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"linux-memory-map-areas"},"children":[{"type":"text","value":"Linux Memory Map Areas"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Check the value for the number of discrete mapped memory areas with the following command:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"sysctl vm.max_map_count"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The default value is 65536."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For most deployments, the default is too low. It is recommended to increase it to 262144 in /etc/sysctl.conf file. This file contains the maximum number of memory map areas a process may have."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"linux-user-limits"},"children":[{"type":"text","value":"Linux User Limits"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For Linux, the number of file descriptors should be set to at least 65536. Check the amount with:"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"\\$ ulimit -n"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"$ ulimit -n"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Confirm that ulimit -v and -u return unlimited to prevent problems with the amount of virtual\r\naddress space that can be allocated."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Also, set shell limits for the Max Number of Processes. These steps are described below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"As root, open the system's /etc/security/limits.conf file."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Add two lines that set the hard and soft limits for the number of processes (nproc) for the Directory Server user. The soft limit sets how many processes the user has available by default; the user can manually adjust that setting until they hit the hard limit."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"user soft nproc 2047\n\nuser hard nproc 16384"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"user soft nproc 2047\n\nuser hard nproc 16384"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"style":"color:red"},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"IMPORTANT NOTE - Do not set the hard limit for the Directory Server user equal to (or higher than) the maximum number of file descriptors assigned to the system itself in /proc/sys/fs/file-max. If the hard limit is too high and the user users all of those file descriptors, then the entire system runs out of file descriptors."}]}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"linux-swap-space"},"children":[{"type":"text","value":"Linux Swap Space"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Swap space in Linux is used when the amount of physical memory (RAM) is full. If the system needs more memory resources and the RAM is full, inactive pages in memory are moved to the swap space. While swap space can help machines with a small amount of RAM, it should not be considered a replacement for more RAM. Swap space is located on hard drives, which have a slower access time than physical memory. This means RadiantOne performance is impacted if swap space starts to be used."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The setting that controls how often the swap file is used is called swappiness. A swappiness setting of zero means that the disk will be avoided unless absolutely necessary (you run out of memory). Swap should be disabled if possible (/etc/fstab) or configured to prevent swapping under normal usage (set vm.swappiness to a value <=20 which is the percentage of RAM left before the system starts to swap). Reboot your system for the change to take effect."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"network-capacity"},"children":[{"type":"text","value":"Network Capacity"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"RadiantOne is a network-intensive application, and for each client application request, it may send multiple operations to different data sources. Make sure the network connections between RadiantOne and your backend data sources are fast, with plenty of bandwidth and low latency. Also make sure the connections between client applications and the RadiantOne service can handle the amount of traffic you expect."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Testing has demonstrated that 100 Mbit Ethernet may be sufficient for classic (active/active or active/passive architectures) depending on the maximum throughput expected. You may estimate theoretical maximum throughput as follows:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"max. throughput = max. entries returned/second x average entry size"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Imagine for example that a Directory Server must respond to a peak of 6000 searches per second for which it returns 1 entry each with entries having average size of 2000 bytes, then the theoretical maximum throughput would be 12 MB, or 96 Mbit. 96 Mbit is likely to be more than a single 100 Mbit Ethernet adapter can provide. Actual observed performance may vary."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you expect to perform multi-master replication (replication across clusters, or replication across active/active or active/passive classic architectures) over a wide area network, ensure the connection provides sufficient throughput with minimum/low latency and near-zero packet\r\nloss."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"style":"color:red"},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"IMPORTANT NOTE - If you intend to deploy RadiantOne in a cluster, on the same network for load balancing purposes, ensure the network infrastructure can support the additional load generated. 1 Gb minimum (this is a basic network card speed) between the cluster nodes is required. It is preferable to have the nodes connected to the same network switch. If you are deploying RadiantOne cluster nodes on Virtual Machines (VM), ensure the network capacity allocated to the VMs is 1 Gb minimum."}]}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you intend to support high update rates for replication in a wide area network environment, ensure through empirical testing that the network quality and bandwidth meet your requirements for replication throughput. When deploying multiple clusters or a classic active/active or active/passive architecture (clusters or individual servers across different networks), to ensure optimal inter-cluster/multi-master replication speeds, 1 Gb is preferred."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"sizing-for-ssl"},"children":[{"type":"text","value":"Sizing for SSL"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"By default, support for the Secure Sockets Layer (SSL) protocol is implemented in RadiantOne."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Using the software-based SSL implementation may have significant negative impact on the Directory Server performance. Running the directory in SSL mode may require the deployment of several directory replicas to meet overall performance requirements."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"memory"},"children":[{"type":"text","value":"Memory"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Adequate memory is key to optimum performance. As a general rule, the more memory available, the more directory information can be cached for quick access."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Estimating memory size required to run RadiantOne involves estimating the memory needed both for a specific RadiantOne configuration, and for the underlying system on which it runs. These two aspects are described in this section."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"sizing-memory-for-radiantone"},"children":[{"type":"text","value":"Sizing Memory for RadiantOne"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The minimum machine memory to deploy RadiantOne (up to a total of 1 million entries of roughly 1KB in size stored in either persistent cache or in a local Universal Directory/HDAP store) is 16 GB. Keep in mind, for persistent cached views, computations and joins that might need to happen prior to caching often dictate a requirement of more than 16 GB. To provide another example, 20 million entries (~1 KB in size) stored in Universal Directory (HDAP store) would require 64 GB of RAM on the machine (not specifically allocated to the RadiantOne FID JVM)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Table 3 summarizes the values used for the calculations in this section."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Table 3: Default Memory Allocation"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"RadiantOne Component"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Description"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Default Memory"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"RadiantOne FID"}]}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Includes: Correlation engine, In-memory cache(query and entry), Interception scripts, Web services (REST, SCIM,SPML, DSML), Join Engine, Security (ACL), Computed Attributes."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"1 GB, automatically expanding up to ¼ of machine memory "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" *See additional comments below."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"ZooKeeper"}]}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Responsible for cluster orchestration and configuration management."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"3 GB "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" *See additional comments below."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Universal Directory (HDAP stores)"}]}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Storage for persistent cache, extension attribute and Universal Directory stores including cn=changelog and cn=replicationjournal."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Calculated based on: "},{"type":"element","tagName":"size","properties":{"of":"","ldif":"","file":""},"children":[{"type":"text","value":" x 2 "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Note - Lucene leverages the OS file system cache for its disk-based data. Java heap size is not applicable. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" When the RadiantOne platform is deployed only with the Universal Directory module, on machines with large amounts of memory (e.g. 32GB), it is recommended to set a max JVM (-Xmx) for the RadiantOne FID service instead of letting it expand to ¼ of the available memory. This leaves more memory for the Universal Directory (HDAP) stores to ensure optimal performance."}]}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Tasks Scheduler"}]}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Schedules tasks."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"1 GB"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Tasks"}]}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Activities that are processed as tasks are: "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Exporting to LDIF, Importing from LDIF, Login analysis (initiated from the virtual identity wizard), Initializing a persistent cache or Universal Directory (HDAP) store, Re- indexing a persistent cache or Universal Directory (HDAP) store, and the default RadiantOne FID monitoring task."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"512 MB, expanding up to ¼ of the machine memory. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" *See additional comments below."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Jetty Application Server"}]}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Hosts the Main Control Panel and the Server Control Panels."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"512 MB"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Real Time Persistent Cache Refresh Agent"}]}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Deploys and manages the real-time persistent cache refresh connectors."}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"1 GB "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" The memory allocation is configured in <RLI_HOME>/bin/advanced/ start_cacherefresh_realtime_agent.bat/.sh "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" - Xms512m -Xmx"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In addition to the items listed in the table, to estimate approximate machine memory size, you should be aware of the following:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The RadiantOne FID uses memory mainly to hold information that is being processed. Complex aggregations for processing some virtual directory requests against multiple data sources may temporarily use extra memory. You should keep this in consideration in addition to the estimates provided in this section."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"By default, RadiantOne FID memory expands up to ¼ of the machine memory. For example, if the machine had 16 GB, then the memory would expand to use at most 4 GB. Once the memory requirements are known for your deployment, ensure the minimum and maximum memory allocations are the same to prevent the heavy process of heap resizing at runtime. You can indicate a minimum (-Xms) and maximum amount (-Xmx) value for the JVM process instead of leveraging this automated expansion. For details on configuring memory size, see the RadiantOne Deployment and Tuning Guide."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"style":"color:red"},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"IMPORTANT NOTE – It is recommended to keep the maximum memory (-Xmx) under 32 GB to ensure the JVM uses compressed oops as a performance enhancement. If this is exceeded, the pointers switch to ordinary object pointers which grow in size, are more CPU-intensive and less efficient. Also, -Xms and -Xmx should be set to the same value to help avoid the performance-costly process of garbage collection from happening too frequently."}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"style":"color:red"},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"It is also important to note that the number of cached entries and indexed attributes configured for memory cache (if used) affect the RadiantOne FID memory usage. The number of cached entries is relevant for memory cache (entry and query). This is the number of entries to be stored in main memory. The default size is 5000 entries. The entry cache is populated as requests are sent to RadiantOne FID. This main memory stores the most recently used entries. Indexed attributes is relevant for memory cache (entry level). This is a list of indexed attributes. The default size is 1000 pages, which means there are, at most, 1000 index pages for each attribute you have indexed. For more details on memory cache, please see the RadiantOne Deployment and Tuning Guide."}]}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The memory requirements for persistent cache or Universal Directory (HDAP) stores varies depending on how many entries are stored and can be calculated with: "},{"type":"element","tagName":"code","properties":{"className":["language-<size","of","ldif","file","containing","all","entries"]},"children":[{"type":"text","value":" x 2 = <MEMORY"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"E.G. 1M entries (~1KB each) = 1GB LDIF file x 2 = 2GB memory to store this in a Universal Directory (HDAP) store."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If your deployment contains a lot of virtual views (a lot of metadata), ZooKeeper can run out of memory, especially during periods where additional cluster nodes are added and the existing configuration must be synchronized to the new nodes. To check the size of the ZooKeeper data, view the folder size located at <RLI_HOME>/apps/zookeeper/data/version-2. For large amounts of metadata (e.g. 3GB), ZooKeeper memory should be increased (e.g. -Xmx5g would increase it to 5GB). ZooKeeper memory size can be set in <RLI_HOME>/bin/advanced/runZooKeeperBlocking.bat file. An example of setting the memory to 5GB is shown below:"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"\"%RLI_JHOME%\\bin\\java\" –Xmx5g -cp \"%ZOO_CP%\"\n\"com.rli.zookeeper.commands.ZooKeeperServerWrapper\"\n\"%RLI_RHOME%\\apps\\zookeeper\\conf\\zoo.cfg\""}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"\"%RLI_JHOME%\\bin\\java\" –Xmx5g -cp \"%ZOO_CP%\"\n\"com.rli.zookeeper.commands.ZooKeeperServerWrapper\"\n\"%RLI_RHOME%\\apps\\zookeeper\\conf\\zoo.cfg\""}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"The Task Scheduler requires approximately 1 GB to schedule tasks. The actual tasks themselves each run inside their own JVM. For cache initialization containing a large number of entries (e.g. 1 million) it is recommended you manually define the memory used by the task to at least 8GB. This speeds up the cache initialization. For more details on Tasks and how to tune the JVM, please see the System Administration Guide."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"You may use utilities such as sar on Linux systems or the Windows Task Manager to measure physical memory used by the RadiantOne processes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"sizing-memory-for-the-operating-system"},"children":[{"type":"text","value":"Sizing Memory for the Operating System"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Estimating the base amount of memory needed to run the underlying operating system must be done empirically, as operating system memory requirements vary widely based on the specifics of the system configuration. You may use utilities such as sar on Linux systems or the Task Manager on Windows to measure memory use."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"You should also allocate enough memory for general system overhead and normal administrative use. Ideally, you will allocate enough space for overhead so that the system avoids swapping pages in and out of memory while in production."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The system total memory needed by the operating system, can then be estimated as follows:"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"Total = Base amount + Overhead amount"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Total = Base amount + Overhead amount"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"sizing-total-memory"},"children":[{"type":"text","value":"Sizing Total Memory"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Given the amount of memory needed for RadiantOne plus the amount needed for the Operating System (OS) described in the previous sections, you can estimate the total memory needed."}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"Total Memory = RadiantOne memory + OS memory"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Total Memory = RadiantOne memory + OS memory"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Total memory is an estimate of the total memory needed, including the assumption that the system is dedicated to the RadiantOne, and includes estimated memory use for all other applications and services expected to run on the system."}]}],"data":{"quirksMode":false}},"fileAbsolutePath":"C:/Ensemble/Projects/RadiantLogic/radiantlogic-v8-developer-site-ssh-2/developer-site/.cache/gatsby-source-git/r1-saas/documentation/hardware-sizing-guide/hardware-sizing-guide.md","frontmatter":{"title":"Hardware Sizing Guide"},"headings":[{"id":"radiantone-hardware-sizing-guide","value":"RadiantOne Hardware Sizing Guide","depth":1},{"id":"introduction-contents","value":"Introduction Contents","depth":2},{"id":"virtual-machine-settings","value":"Virtual Machine Settings","depth":2},{"id":"memory-ballooning","value":"Memory Ballooning","depth":3},{"id":"memory-requirements","value":"Memory Requirements","depth":3},{"id":"network-interface","value":"Network Interface","depth":3},{"id":"vcpu","value":"vCPU","depth":3},{"id":"timekeeping","value":"Timekeeping","depth":3},{"id":"vertical-scalability","value":"Vertical Scalability","depth":3},{"id":"horizontal-scalability","value":"Horizontal Scalability","depth":3},{"id":"disk-speed-and-space","value":"Disk Speed and Space","depth":2},{"id":"linux-memory-map-areas","value":"Linux Memory Map Areas","depth":2},{"id":"linux-user-limits","value":"Linux User Limits","depth":2},{"id":"linux-swap-space","value":"Linux Swap Space","depth":2},{"id":"network-capacity","value":"Network Capacity","depth":2},{"id":"sizing-for-ssl","value":"Sizing for SSL","depth":3},{"id":"memory","value":"Memory","depth":2},{"id":"sizing-memory-for-radiantone","value":"Sizing Memory for RadiantOne","depth":3},{"id":"sizing-memory-for-the-operating-system","value":"Sizing Memory for the Operating System","depth":3},{"id":"sizing-total-memory","value":"Sizing Total Memory","depth":3}]},"toc":{"html":"<ul>\n<li><a href=\"hardware-sizing-guide.md\">Hardware Sizing Guide</a></li>\n</ul>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"hardware-sizing-guide.md"},"children":[{"type":"text","value":"Hardware Sizing Guide"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fileAbsolutePath":"C:/Ensemble/Projects/RadiantLogic/radiantlogic-v8-developer-site-ssh-2/developer-site/.cache/gatsby-source-git/r1-saas/documentation/hardware-sizing-guide/TOC.md","frontmatter":{"title":"Hardware Sizing Guide"}},"rootToc":{"fileAbsolutePath":"C:/Ensemble/Projects/RadiantLogic/radiantlogic-v8-developer-site-ssh-2/developer-site/.cache/gatsby-source-git/r1-saas/home-pages/TOC.md","frontmatter":{"title":"Homepages TOC"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":""},"children":[{"type":"text","value":"Knowledge"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"developer.md"},"children":[{"type":"text","value":"Developer"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},"pageContext":{"slug":"hardware-sizing-guide/hardware-sizing-guide","dir":"documentation/hardware-sizing-guide/hardware-sizing-guide.md","absolutePath":"C:/Ensemble/Projects/RadiantLogic/radiantlogic-v8-developer-site-ssh-2/developer-site/.cache/gatsby-source-git/r1-saas/documentation/hardware-sizing-guide/hardware-sizing-guide.md","tocRegex":"/(r1-saas)/(documentation/)(hardware-sizing-guide/)?(hardware-sizing-guide.md/)?(TOC.md)/ig","rootTocRegex":".*/(gatsby-source-git)\\/(r1-saas)\\/(home-pages)\\/(TOC.md)/ig"}},"staticQueryHashes":["2212765230","3325251965","63159454"],"slicesMap":{}}