{"componentChunkName":"component---src-templates-base-page-js","path":"/deployment-and-tuning-guide/02-tuning-tips-for-caching-in-radiantone/","result":{"data":{"pageContent":{"html":"<h1 id=\"chapter-2-tuning-tips-for-caching-in-the-radiantone-federated-identity-service\">Chapter 2: Tuning Tips for Caching in the RadiantOne Federated Identity Service</h1>\n<p>This chapter provides guidelines on how to effectively use caching for optimal performance. The first part covers the different categories and levels of cache along with a quick review of the different use cases that justify a cache deployment. The second part provides details and describes the advantages and trade-off between “in-memory” and “persistent” cache. Finally, a description of cache refresh methods is reviewed. This is an essential and often overlooked aspect of cache management.</p>\n<p>Persistent caching is only associated with the RadiantOne Federated Identity module and is irrelevant for <a href=\"04-tuning-tips-radiantone-universal-directory.md\">RadiantOne Universal Directory</a>.</p>\n<h2 id=\"when-and-why-do-you-need-a-cache-with-radiantone-fid\">When and why do you need a cache with RadiantOne FID?</h2>\n<p>There are many cases where RadiantOne is leveraged more for its flexibility rather than its pure speed. However, in most critical operations such as identification, authentication, and authorization, it needs to provide guaranteed fast access to information. In fact, in many cases RadiantOne needs to provide read operations that are faster than what can be delivered by the underlying sources. What is meant by “fast”, is a level of performance that is at least 3 to 5 times what can be derived from standard relational databases (RDBMS) – as an example.</p>\n<p>An additional requirement, in some situations, is a fast “write” capability. A typical case is when security information needs to be logged into the directory for audit purposes at authentication time. The problem is that most directories are a lot slower than RDBMS when it comes to write operations. In this case, RadiantOne can forward the writes to faster transactional data stores.</p>\n<p>The question then becomes: How can the RadiantOne FID service be faster than the underlying data sources despite the fact that it adds an extra layer of software and one more intermediate TCP/IP hop?</p>\n<p>The answer is unambiguous, without caching, the RadiantOne FID service is always slower than the sources it has virtualized. In terms of overhead, the additional TCP/IP hop (an application talks to RadiantOne first and then it talks to the underlying sources) by itself, divides the throughput of the virtualized source by approximately half. If you include the dynamic transformations, the joins, and the reorganization of the underlying namespaces to this overhead (in short, all the value added by RadiantOne through on-the-fly processing), it is difficult to imagine how this service can be faster than the underlying sources with dynamic access alone.</p>\n<p>For all the above reasons, a flexible and efficient cache strategy and cache refresh mechanism is an absolute necessity. In most sizeable identity and access management deployments, caching is not only required, but also depending on volume, scalability, resilience to failure, etc…different levels and types of cache (in-memory and/or persistent) are needed.</p>\n<p>To better understand the different aspects of performance and cache for RadiantOne, we need to look at the architecture. At a high level, the architecture can be divided into two main layers:</p>\n<ul>\n<li>\n<p>A front-end layer which handles the protocol (LDAP or other standard protocols such as a Web Services, SPML, or SAML).</p>\n</li>\n<li>\n<p>A back-end layer that oversees mapping/transforming the result set from the “virtualized” data sources (directories, databases and/or applications).</p>\n</li>\n</ul>\n<p>The performance of the RadiantOne service depends on a front-end layer that shares most of the logic of an LDAP server and as such can leverage the same optimization strategies. However, performance also depends even more on the back–end layer, which really represents the virtualization. This is where the secret for performance and scalability resides and, where a solid and scalable caching mechanism is indispensable.</p>\n<p>###Front-end performance</p>\n<p>The RadiantOne front-end shares most of the layers of a “classic” LDAP directory and the same “potential” bottlenecks. They are essentially at:</p>\n<ul>\n<li>\n<p>The TCP/IP server (and client) connections</p>\n</li>\n<li>\n<p>The first level of query parsing</p>\n</li>\n</ul>\n<h4 id=\"tcpip-connections-and-connection-pooling\">TCP/IP Connections and Connection Pooling</h4>\n<p>The first bottleneck is common to any TCP/IP based server and not specific to LDAP servers. Even if a server could set aside resources (memory and handles) for an arbitrarily large number of connections, what the server can really support (the effective number of concurrent connections) is dictated by the underlying hardware platform, bandwidth and operating system. Once this level is reached, no matter how powerful the underlying hardware is (in terms of processing throughput), the server is idle and waiting for the establishment of the connections. In this case the only possible optimization at the TCP layer would be by using specific hardware such as TCP offload engines, more bandwidth, better routers and/or scaling out by load balancing.</p>\n<p>The latency of a TCP/IP client connection is another point to consider in the terms of performance. The latency of a TCP/IP client connection, compared to the speed of the processor is extremely high. As a result, multiple connections and disconnections hamper the apparent throughput of any directory server. (An easy way to verify this fact is to run the “search rate” utility (as described in <a href=\"05-testing-radiantone-performance.md\">Chapter 5</a>) against any LDAP directory with or without keeping the connection open after each search). With multiple connections/disconnections the search rate of a server drops to a quarter or a third of the normal throughput. At the same time the CPU of the server shows a lot of idle cycles. Most of the time is spent waiting for the establishment or re-establishment of the client TCP/IP connection. Since the RadiantOne service must connect to many distributed sources, it acts as a client to many TCP/IP servers, and so the cumulated latencies could be quite high. The solution to this problem consists in pooling the different connections by class of connected servers to reuse existing connections as much as possible. It is essentially a form of cache for an already open structure needed for a connection. Therefore, support for connection pooling is an important feature for RadiantOne in dynamic access mode (without caching any data at the level of the server). For details on connection pooling, please see <a href=\"03-tuning-tips-for-specific-types-of-backend-data-sources.md\">Chapter 3</a>.</p>\n<h4 id=\"first-level-of-query-parsing\">First Level of Query Parsing</h4>\n<p>The second issue is the overhead generated by the parsing of incoming queries. Although a lot less expensive than TCP/IP overhead, the parsing time is not negligible. To optimize, RadiantOne couples a query cache with an entry cache. The idea is that by caching a frequently issued query and its result set (entry cache), significant server time can be saved. This strategy works well when information is not too volatile. The cache is equipped with a LRU (least recently used) eviction policy and TTL (time-to-live) marker for both queries and entries.</p>\n<p>However, query cache and entry cache are not the panacea to addressing performance issues. Query cache is relatively blind and based essentially on syntax and not semantics: two queries yielding equivalent results but using a slightly different syntax are represented twice in the cache. Another limitation is the size of these caches. As volume increases, many factors start to negate the value of the approach. The cache refresh strategy is more complex, and latency in case of failure and cold restart (the cache needs to be re-populated before providing its performance boost) can be stumbling blocks. For these reasons, these categories of caches in RadiantOne are used essentially as a performance enhancer rather than the base for server speed. If correctly sized, such a cache brings a 15 to 30% performance boost to a server (unless the whole dataset is quite small and could fit entirely in memory). The next section explains that the key to scalability and sustainable performance for a directory with significant volume rests upon its indexing strategy for entries and access paths.</p>\n<h3 id=\"back-end-performance\">Back-end Performance</h3>\n<p><strong>The “Secret” of LDAP Directory Speed</strong></p>\n<p>The beginning of this chapter referred to the speed of a directory being primarily focused on reads. So, how fast is fast? Between 1500 to 2000 queries per second/per GHZ/per processor (Pentium IV class machine on a Windows Server or Linux) for LDAP (Sun or Netscape 4.x to 5.x) versus 150 to 300 queries per second for a RDBMS (Oracle, DB2, or SQL Server) for a standard entry search with fully indexed queries. The size of an entry for these performance numbers is about 512 bytes, and the number of entries in the LDAP directory was 2 million. These numbers reflect a search operation for identification purposes (login). This performance is quite stable, even if the volume of entries goes up to 80 to 100 million entries. However, the size of an entry is a factor in terms of performance. At 2 KB or more per entry the search rate starts to drop quickly.</p>\n<p>The performance secret of an LDAP server when it comes to read and search operations is a relatively simple structure for queries and operations, which yields a much simpler access method and storage strategy (nothing to be compared with the richness and capabilities of SQL, but also none of the optimizations and complexity required of a full RDBMS). Essentially, an LDAP directory can be implemented very efficiently with a classic approach of fully indexed data files based on B+ trees (RDBMS uses the same kind of storage and access methods, however their access plans are a lot more complex, involve a lot of processing, many indexes and optimizations for full support of relational operations).</p>\n<p>Due to their relative simplicity, LDAP directories fully benefit from the classic advantages of B+ tree indexing. Searching for an entry based on a fully indexed attribute can be delivered in a guaranteed time and scale quite well. Even without page caching, a B+ tree index can retrieve an indexed attribute (in the worst case) in no more than log N disk accesses, N being the number of entries. This simple and robust structure explains the performance and stability of LDAP directories when it comes to read even with a significant number of entries (100 million entries or more). More importantly, this level of speed can be guaranteed even with a relatively modest amount of main memory, again one of the strong points for B+Trees. However, the story in terms of writes is not as good. Writing is an expensive operation, which does not scale well when the volume of entries increases. If this constraint is added, the fact that an LDAP directory must maintain many indexes (ideally as many as potentially “searchable” attributes), you can see that the number of updates is the key factor that limits the scalability of a classic directory. As is well documented, a directory is optimized for read with a modest amount of writes.</p>\n<p><strong>The Different Caching Strategies</strong></p>\n<p>Where are the bottlenecks for the RadiantOne service? As described in this chapter, when it comes to the front-end layer read/search speed, RadiantOne is comparable to a classic directory. The optimizations at this level are also similar. The target is essentially to optimize the TCP/IP connections and to re-use the previous queries and corresponding results sets (Query cache and entry cache - see previous sections) when and where possible.</p>\n<p><strong>The major bottleneck is at the level of the back-end</strong></p>\n<p>By definition, a federated identity layer does not own any specialized back-end like a classic LDAP server (which as we have seen is the secret to speed and scalability with modest memory requirements). By construction, a federated identity layer needs access to the underlying “virtualized” data sources. Without a caching strategy, a federated identity layer acts simply as a proxy and forwards the calls to the underlying sources. Without caching, even with the best optimization at the front-end, RadiantOne FID can only deliver a fraction of the speed of the underlying sources. If the “virtualized” sources are fast in terms of read operations and if the virtualization overhead is acceptable then dynamic access alone to the source data may be a viable strategy.</p>\n<p>However in most cases (e.g. when databases and/or Web Services are involved and volume is significant), a back-end caching mechanism is a requirement. A complete federated identity layer needs to offer different levels of cache with different cache refresh implementation strategies matching different use cases.</p>\n<p>There are essentially two forms of cache:</p>\n<ul>\n<li>\n<p>In-memory cache</p>\n</li>\n<li>\n<p>Disk-based cache also called “persistent cache”</p>\n</li>\n</ul>\n<p>Each of these caching mechanisms can be refreshed using different methods.</p>\n<p>Cache refresh strategies can be divided into two main categories:</p>\n<ul>\n<li>Polling the changes either periodically or based or an expiration of a “time-to-live“ value assigned to a cache entry</li>\n<li>Detecting the change events directly at the sources (triggers or other methods)</li>\n</ul>\n<h4 id=\"memory-cache\">Memory Cache</h4>\n<p>In this approach, cached entries are stored solely in memory. In terms of implementation, this approach has the advantage of simplicity. However in practice, this solution may present many potential issues depending on the use case. In most cases, memory cache works when the volume of entries and the complexity of the queries are modest. However, with sizeable volume (and often the flexibility of a federated identity service tends to yield many use cases which quickly add an increased demand in terms of memory) and the variable latencies and volatility (update rates) of the virtualized data sources, it is difficult to guarantee the performance of a memory cache solution. The greatest risks with a memory cache result when the query pattern is not predictable and the data set volume exceeds the size of memory. Furthermore, some categories of directory views are not good candidates for caching because the operation can never guarantee that all possible observable results are retrieved at the right time. If the volatility of the underlying data store is high, and the volume of data is significant, then a memory cache with a time-to-live refresh strategy alone is very difficult to put in place and will not guarantee an accurate “image” or will generate excessive refresh volume negating the advantages of the cache. As a result, providing guaranteed performance is difficult if not impossible. Moreover, as volume increases or when queries needed to build the virtual image are more complex, the latency incurred by accessing the underlying sources just to rebuild the memory cache after a cold restart becomes more and more problematic. As a consequence, memory cache provides performance improvements only in very specific cases. Memory cache needs to be considered more like a partial/incremental improvement boost rather than a complete solution to guaranteed performance.</p>\n<h3 id=\"persistent-cache\">Persistent Cache</h3>\n<p>In this approach, images of the virtual entries are stored in the local RadiantOne Universal Directory. This approach allows for fast recovery in case of failure. The whole virtual tree could be cached this way and a large volume of entries can be supported (hundreds of millions entries - essentially no practical limit if combined with partitioning and clusters).</p>\n<p>The challenge then becomes how to access this disk cache selectively at the level of each entry and at the same speed than the fastest classic LDAP server. The answer is pretty straightforward even if its implementation is not: build a persistent cache, which is a full LDAP V3 server. All the advantages described for the classic LDAP directory speed apply here. The persistent cache becomes the equivalent of what in the RDBMS world we would call a “materialized” view of a complex directory tree stored in an LDAP format and transparently refreshed by polling or pushing events (triggers or logs) at the level of the data sources. In fact, the complexity here resides essentially in the cache refresh mechanism. The good news is that by leveraging good abstraction and representation (data modeling and metadata) of the different data sources, a completely automated solution is possible. One can say that in this case, a bit paradoxically, good abstraction and virtualization ends up into an always “synchronized” and persistent directory view. The major difference though with classic synchronization resides in the simplicity and the ease of deployment. Virtualization and good data modeling yield an automated solution where transformation, reconciliation, joins, caching, and synchronization is totally transparent to the RadiantOne administrator and reduced to a fairly simple configuration.</p>\n<p>The diagram below provides a general “rule of thumb” as to what type of cache to implement.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 492px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.363636363636363%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAd0RRX//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAYEAADAQEAAAAAAAAAAAAAAAAAASFRcf/aAAgBAQABPyHaZWLrP//aAAwDAQACAAMAAAAQfA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAADAQEBAAAAAAAAAAAAAAAAAREhUdH/2gAIAQEAAT8QjumiTvAI55H/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/d7d97183789a760cd34bc9f09f3c5e97/aee3f/Image2.1.jpg\"\n        srcset=\"/static/d7d97183789a760cd34bc9f09f3c5e97/c1cfe/Image2.1.jpg 275w,\n/static/d7d97183789a760cd34bc9f09f3c5e97/aee3f/Image2.1.jpg 492w\"\n        sizes=\"(max-width: 492px) 100vw, 492px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.1: Cache implementation diagram</p>\n<ul>\n<li>Low volatility during the life of the cache (the time to live)</li>\n</ul>\n<p>** Repetitive Queries – a query having exactly the same syntax (same user, same filter, same ACL)\r\n*** Low Volume – The size of the cache as measured by (Nb entries * entry size * 2.5) cannot exceed the amount of memory allocated for cache</p>\n<blockquote>\n<p>[!note]\r\nFor persistent cache, there is no limitation in terms of number of entries since everything is stored on disk. When fully indexed, the persistent cache provides performance levels comparable to the fastest “classic” LDAP directory and even better performance when it comes to modify operations.</p>\n</blockquote>\n<h2 id=\"cache\">Cache</h2>\n<p>RadiantOne offers different caching options to accommodate a variety of deployment needs.</p>\n<ul>\n<li>\n<p>Memory Cache (Entry Cache and Query Cache)</p>\n</li>\n<li>\n<p>Persistent Cache</p>\n</li>\n</ul>\n<p>The diagram below provides a general “rule of thumb” as to what type of cache to implement.</p>\n<ul>\n<li>Low volatility during the life of the cache (the time to live).</li>\n</ul>\n<p>** Repetitive Queries – a query having exactly the same syntax (same user, same filter, same ACL).</p>\n<p>*** Low Volume – The size of the cache as measured by (Nb entries * entry size * 2.5) cannot exceed the amount of memory allocated for cache.</p>\n<p>For persistent cache, there is no limitation in terms of number of entries since everything is stored on disk. When fully indexed, the persistent cache provides performance levels comparable to the fastest “classic” LDAP directory.</p>\n<h3 id=\"memory-cache-1\">Memory Cache</h3>\n<p>A memory cache (requires <a href=\"00-preface#expert-mode\">Expert Mode</a>) can be configured for any virtual directory view and there are two different types of memory caching available: <a href=\"#configuring-entry-memory-cache\">Entry Memory Cache</a> and <a href=\"#configuring-query-cache\">Query Memory Cache</a>. They can be used together or individually.</p>\n<blockquote>\n<p>[!warning]\r\nIf you plan on using both entry and query cache on the same view/branch, be aware that the query cache is searched first.</p>\n</blockquote>\n<h4 id=\"configuring-entry-memory-cache\">Configuring Entry Memory Cache</h4>\n<p>This model of caching leverages two types of memory: Main and Virtual. Main memory is the real memory where a certain number of most recently used entries reside. Virtual memory is memory on disk where all entries that exceed the amount allowed in the main memory reside. The swapping of entries from Virtual to Main memory (and vice versa) is managed by RadiantOne.</p>\n<p>First, enable the Entry Memory Cache. In the Main Control Panel > Settings Tab > Server Front End section > Memory Cache sub-section (requires <a href=\"00-preface#expert-mode\">Expert Mode</a>), on the right side, check the Entry Cache box. Click Save in the top right corner.</p>\n<blockquote>\n<p>[!warning]\r\nIf you plan on caching (either entry memory cache or persistent cache) the branch in the tree that maps to an LDAP backend, you must list the operational attributes you want to be in the cache as “always requested”. Otherwise, the entry stored in cache would not have these attributes and clients accessing these entries may need them. For details on how to define attributes as “always requested” please see the RadiantOne System Administration Guide.</p>\n</blockquote>\n<p>Entry cache is for caching every entry (a unique DN) of the specified tree. This kind of cache works well on trees where the volatility (update rate) is low (the likelihood of this data changing during the lifetime of this cache is low). This type of cache is optimized for and should only be used for finding specific entries (e.g. finding user entries during the “identification” phase of authentication) based on unique attributes that have been indexed in the cache setting, and base searches. The attributes you choose to index for the cache are very important because the value needs to be unique across all entries in the cache. For example, if you index the uid attribute, then all entries in the cache must have a unique uid (and be able to be retrieved from the cache based on this value). On the other hand, an attribute like postalcode would not be a good attribute to index (and search for entries based on) because more than one entry could have the same value for postalcode.</p>\n<blockquote>\n<p>[!warning]\r\nThe DN attribute is indexed by default. DNs are unique for each entry which is the reason why base searches can be optimized with the entry cache.</p>\n</blockquote>\n<p>For example, to populate/pre-fill the entry cache with unique user entries, you can preload with a query like:</p>\n\n          <codeblockcopytag>ldapsearch -h localhost -p 2389 -D “uid=myuser,ou=people,dc=vds” -w secret -b “ou=people,dc=vds” -s sub (uid=*)</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ldapsearch -h localhost -p 2389 -D “uid=myuser,ou=people,dc=vds” -w secret -b “ou=people,dc=vds” -s sub (uid=*)</code></pre></div>\n<p>With this type of LDAP search, all entries (containing uid) are stored in the entry memory cache. Therefore, if a client then searched for:</p>\n\n          <codeblockcopytag>ldapsearch -h localhost -p 2389 -D “uid=myuser,ou=people,dc=vds” -w secret -b “ou=people,dc=vds” -s sub (uid=lcallahan)</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ldapsearch -h localhost -p 2389 -D “uid=myuser,ou=people,dc=vds” -w secret -b “ou=people,dc=vds” -s sub (uid=lcallahan)</code></pre></div>\n<p>The entry could be retrieved from the entry cache and the underlying source would not need to be accessed.</p>\n<p>Also, since all DNs in an LDAP tree are unique, base searches can benefit from entry cache. Continuing with the example above, if a client performed a base search on uid=lcallahan,ou=people,dc=vds, the entry could be retrieved from the entry cache.</p>\n<blockquote>\n<p>[!warning]\r\nEntry Memory Cache works for BASE searches on entries as well as on One Level and Sub Tree searches. However, for One Level and Sub Tree searches, whether the entry is returned from cache depends on whether the filter is \"qualified\" or not. Qualified means that the attribute in the filter is one that is indexed in your cache. Remember, only UNIQUE attributes can be indexed in your cache. You could index something like cn, which is fine if it is unique across all your entries. You cannot however index something like objectclass as more than one entry could be of the same objectclass.</p>\n</blockquote>\n<p>For example, if your entry cache settings indexed the cn attribute, a search like the following (using the ldapsearch command line utility) doesn’t qualify to return the entry from entry cache even though it may be in the cache:</p>\n\n          <codeblockcopytag>ldapsearch -h localhost -p 2389 -D &quot;cn=directory manager&quot; -w secret -b &quot;cn=Laura Callahan,ou=Active Directory,dc=demo&quot; -s sub (objectclass=*)</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ldapsearch -h localhost -p 2389 -D \"cn=directory manager\" -w secret -b \"cn=Laura Callahan,ou=Active Directory,dc=demo\" -s sub (objectclass=*)</code></pre></div>\n<p>However, both of the following searches WOULD return the entry from the memory cache (because one uses a subtree search requesting a filter based on the indexed attribute, and one is a base search):</p>\n\n          <codeblockcopytag>ldapsearch -h localhost -p 2389 -D &quot;cn=directory manager&quot; -w secret -b &quot;cn=Laura Callahan,ou=Active Directory,dc=demo&quot; -s sub &quot;(cn=Laura Callahan)&quot;\r\n\r\nldapsearch -h localhost -p 2389 -D &quot;cn=directory manager&quot; -w secret -b &quot;cn=Laura Callahan,ou=Active Directory,dc=demo&quot; -s base &quot;(objectclass=*)&quot;</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ldapsearch -h localhost -p 2389 -D \"cn=directory manager\" -w secret -b \"cn=Laura Callahan,ou=Active Directory,dc=demo\" -s sub \"(cn=Laura Callahan)\"\r\n\r\nldapsearch -h localhost -p 2389 -D \"cn=directory manager\" -w secret -b \"cn=Laura Callahan,ou=Active Directory,dc=demo\" -s base \"(objectclass=*)\"</code></pre></div>\n<p>To configure an entry memory cache, follow the steps below (requires <a href=\"00-preface#expert-mode\">Expert Mode</a>).</p>\n<ol>\n<li>On the Main Control Panel > Settings Tab > Server Front End section > Memory Cache sub-section, on the right side click Add in the Entry Cache section.</li>\n<li>Select a starting point location in the virtual tree. All entries queried below this point are cached. The maximum number of entries allowed in the main memory is specified in the Number of Cache Entries parameter.</li>\n<li>Enter values for the Number of Cache Entries, Time to Live, Indexed attributes, and include/exclude filters. Details about these settings can be found below.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 361px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 92.72727272727273%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHurTKiYEoX/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAECIDH/2gAIAQEAAQUCvIWf/8QAFREBAQAAAAAAAAAAAAAAAAAAEAH/2gAIAQMBAT8BKf/EABURAQEAAAAAAAAAAAAAAAAAABAB/9oACAECAQE/ASH/xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAbEAEAAgIDAAAAAAAAAAAAAAABABARITFBcf/aAAgBAQABPyECI5MPsQhTXXbzV//aAAwDAQACAAMAAAAQ88/A/8QAFREBAQAAAAAAAAAAAAAAAAAAEDH/2gAIAQMBAT8QIP/EABURAQEAAAAAAAAAAAAAAAAAABAx/9oACAECAQE/ECj/xAAdEAEAAgICAwAAAAAAAAAAAAABABEhMRBBUWGh/9oACAEBAAE/EPE+xVABol3L2o3T1xtLiQqHo1GuSue25//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/07c4641abb127b3ade63586d85c16750/59a3c/Image2.2.jpg\"\n        srcset=\"/static/07c4641abb127b3ade63586d85c16750/c1cfe/Image2.2.jpg 275w,\n/static/07c4641abb127b3ade63586d85c16750/59a3c/Image2.2.jpg 361w\"\n        sizes=\"(max-width: 361px) 100vw, 361px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.2: Entry Cache Settings</p>\n<p><strong>Time to Live</strong></p>\n<p>The amount of time that entries should remain in cache. After the time has been reached, the entry is removed from the cache. The next request for the entry is sent to the underlying data store(s). The result of the request is then stored in the memory cache again. This value is specified in minutes. The default value for this parameter is 60 (1 hour).</p>\n<p><strong>Indexes</strong></p>\n<p>Enter the attribute names in the cache that should be indexed. The values need to be separated with a comma. The attribute names must represent unique values for all entries across the entire cache. You must only index attributes that have unique values, otherwise the response from the cache can be unpredictable. For example, if you indexed the postalCode attribute, your first request with a filter of (postalCode=94947) may return 50 entries (because the query would be issued to and returned from the underlying source). However, your second request would only return 1 entry (because RadiantOne expects to find only one unique entry in the cache that matches a postalCode=94947, and this is typically the last entry that was added to the cache). If this functionality does not meet your needs, you should review the query cache and persistent cache options.</p>\n<p><strong>Include Filter</strong></p>\n<p>Enter a valid LDAP filter here that defines the entries that should be included in the cache. Only entries that match this filter are cached.</p>\n<p>As an alternative approach, you can indicate what entries to exclude by using the Exclude filter described below.</p>\n<p><strong>Exclude Filter</strong></p>\n<p>Enter a valid LDAP filter here that defines the entries that should be excluded from the cache. All entries that match this filter are not cached.</p>\n<p>As an alternative approach, you can indicate what entries to include by using the Include filter described above.</p>\n<p><strong>Number of Cached Entries</strong></p>\n<p>The total number of entries kept in main memory. The entry cache can expand beyond the main memory and the entries are swapped as needed. The default value for this parameter is 5000. This means that up to 5000 most recently used entries are put in the main memory cache. As the number of entries exceeds 5000, they are stored as virtual memory (memory on disk) and swapped as needed. The default value of 5000 is usually sufficient.</p>\n<h5 id=\"memory-size-requirements\">Memory Size Requirements</h5>\n<h6 id=\"for-entries\">For Entries</h6>\n<p>As a rule of thumb, you should take the average size of one of your entries and multiply by the number of entries you want to store in main memory. Then multiply this total number (the size for all entries) by 2.5. This gives you the amount of main memory you should allocate to store the entries.</p>\n<h5 id=\"for-indexes\">For Indexes</h5>\n<blockquote>\n<p>[!note]\r\nThis value is the total number of pages for each indexed attribute. The default size is 1000 pages. Which means there are, at most, 1000 index pages for each attribute you have indexed.</p>\n</blockquote>\n<p>For each indexed attribute, the amount of memory consumed per page is calculated by taking the average size of an indexed value x 3 x 64.</p>\n<p>You should keep in mind that dn is always indexed (although it doesn’t appear in the index list). Therefore, the dn attribute by itself consumes the following (assuming the dn is an average of 200 bytes in size):</p>\n<p>200 x 3 x 64 = 38,400 bytes (approximately 39 KB per index page)</p>\n<p>The default of 1000 index pages, consumes about (1000 x 39 KB) 39 MB in memory for the dn attribute.</p>\n<p>Now, calculate the amount for each attribute you have indexed and add it to the 39 MB.</p>\n<p>For example, if you index the attribute uid, and the average uid is 20 characters, you would have 20x3x64 = 3840 byes (approximately 4 KB per index page).</p>\n<p>With 1000 index pages (1000 x 4 KB), about 4 MB in memory is consumed for the uid attribute.</p>\n<p>If you have 10 attributes indexed (all on average of 20 characters), the total consumption of memory would be about 40 MB + 39 MB (for the dn attribute) for a total of 79 MB.</p>\n<h3 id=\"total-memory-size-requirements\">Total Memory Size Requirements</h3>\n<p>Add entry memory cache requirements and index memory cache requirements together to get the total memory size required for your cache.</p>\n<h3 id=\"configuring-query-cache\">Configuring Query Cache</h3>\n<p>Query cache is sensitive to syntax. To benefit from the query cache, it must be the exact same query (from the same person, ACI, asking for the same information). This type of caching is good for repetitive queries (of the same nature).</p>\n<p>Query cache is only applicable on naming contexts that are not configured as persistent cache.</p>\n<p>First, enable the Query Memory Cache (requires <a href=\"00-preface#expert-mode\">Expert Mode</a>).</p>\n<ol>\n<li>\n<p>On the Main Control Panel > Settings Tab > Front End section > Memory Cache sub-section, on the right side, check the box in the Query Cache section.</p>\n</li>\n<li>\n<p>Click <strong>Add</strong> in the Query Cache section.</p>\n</li>\n<li>\n<p>Select a starting point location in the RadiantOne namespace. All queries below this point are cached.</p>\n</li>\n<li>\n<p>Enter a Time to Live (in minutes). This is the amount of time that entries should remain in cache. After the time has been reached, the entry is removed from the cache. The next request for the entry is sent to the underlying data store(s). The result of the request is then stored in the memory cache again. This value is specified in minutes. The default is 60 (1 hour).</p>\n</li>\n<li>\n<p>Click <strong>OK</strong>.</p>\n</li>\n<li>\n<p>Click <strong>Save</strong> (located in the top right hand corner) to save your settings.</p>\n</li>\n</ol>\n<blockquote>\n<p>[!warning]\r\nThe user and ACI information are also part of the query. This is why it was mentioned above that the query cache is sensitive to syntax. If User A issues a query, and then User B issued a query asking for the exact same information, this would count as two queries in the Query Cache.</p>\n</blockquote>\n<h4 id=\"populating-the-memory-cache\">Populating the Memory Cache</h4>\n<h5 id=\"entry-cache\">Entry Cache</h5>\n<p>The entry memory cache is filled as the RadiantOne service receives queries. The first time the server receives a request for an entry, the underlying data store(s) is queried and the entry is returned. The entry is stored in the entry memory cache. The entry remains in cache for the time specified in the Time to Live setting.</p>\n<h5 id=\"query-cache\">Query Cache</h5>\n<p>The query memory cache is filled as the RadiantOne service receives queries. The first time the server receives a request, the query is added to the query memory cache, and the underlying data store(s) is queried to retrieve the entries. The entries resulting from the query are also stored in the cache.</p>\n<h4 id=\"refreshing-the-memory-cache\">Refreshing the Memory Cache</h4>\n<p>A time-to-live parameter can be set for both the entry cache and the query cache. The time starts when the entry/query is added into memory. Once the time-to-live value is reached, the entry/query is removed from the cache. The next time a query is received for the entry, RadiantOne issues a query to the underlying store(s), retrieves the latest value and the entry is stored in the entry memory cache and/or the query memory cache again.</p>\n<p>You also have the option to flush the entire memory cache from the Main Control Panel > Settings Tab > Server Front End section > Memory Cache section (requires <a href=\"00-preface#expert-mode\">Expert Mode</a>). On the right side, click on the “Flush All” button next to the type of cache you are interested in clearing.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 491px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.36363636363637%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdyhIFf/xAAWEAADAAAAAAAAAAAAAAAAAAAAECH/2gAIAQEAAQUCUP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABgQAAMBAQAAAAAAAAAAAAAAAAABIRFh/9oACAEBAAE/IZ0Q6eo//9oADAMBAAIAAwAAABD8D//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/EEf/xAAYEAEBAQEBAAAAAAAAAAAAAAABEQBBIf/aAAgBAQABPxBaLxzATwwdhRjd/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/077a3e3bb7be60eb66dd58a42f066725/f6c46/Image2.3.jpg\"\n        srcset=\"/static/077a3e3bb7be60eb66dd58a42f066725/c1cfe/Image2.3.jpg 275w,\n/static/077a3e3bb7be60eb66dd58a42f066725/f6c46/Image2.3.jpg 491w\"\n        sizes=\"(max-width: 491px) 100vw, 491px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.3: Memory Cache Settings</p>\n<h3 id=\"persistent-cache-1\">Persistent Cache</h3>\n<p>Persistent cache is the cache image stored on disk. With persistent cache, the RadiantOne service can offer a guaranteed level of performance because the underlying data source(s) do not need to be queried and once the server starts, the cache is ready without having to “prime” with an initial set of queries. Also, you do not need to worry about how quickly the underlying data source can respond. What is unique about the persistent cache is if the RadiantOne service receives an update for information that is stored in the cache, the underlying data source(s) receives the update, and the persistent cache is refreshed automatically. In addition, you have the option of configuring real-time cache refreshes which automatically update the persistent cache image when data changes directly on the backend sources. For more details, please see <a href=\"#options-for-refreshing-the-persistent-cache\">Refreshing the Persistent Cache</a>.</p>\n<blockquote>\n<p>[!warning]\r\nIf you plan on caching (either entry memory cache or persistent cache) the branch in the tree that maps to an LDAP backend, you must list the operational attributes you want to be in the cache as “always requested”. Otherwise, the entry stored in cache would not have these attributes and clients accessing these entries may need them.</p>\n</blockquote>\n<h4 id=\"disk-space-requirements\">Disk Space Requirements</h4>\n<p>Initialization of a persistent cache happens in two phases. The first phase is to create an LDIF formatted file of the cache contents (if you already have an LDIF file, you have the option to use this existing file as opposed to generating a new one). The second phase is to initialize the cache with the LDIF file. After the first phase, RadiantOne prepares the LDIF file to initialize the cache. Therefore, you need to consider at least these two LDIF files and the amount of disk space to store the entries in cache.</p>\n<p>Best practice would be to take four times the size of the LDIF file generated to determine the disk space that is required to initialize the persistent cache. For example, lab tests have shown 50 million entries (1KB or less in size) generates an LDIF file approximately 50 GB in size. So total disk space recommended to create the persistent cache for this example would be 200 GB.</p>\n<h4 id=\"initializing-persistent-cache\">Initializing Persistent Cache</h4>\n<p>Persistent cache should be initialized during off-peak hours, or during scheduled downtime, since it is a CPU-intensive process and during the initialization queries are delegated to the backend data sources which might not be able to handle the load.</p>\n<p>When initializing persistent cache, two settings you should take into consideration are paging and initializing cache from an encrypted file. These options are described in this section.</p>\n<blockquote>\n<p>[!warning]\r\nIf you are using real-time refresh, make sure the cache refresh components are stopped before re-initializing or re-indexing a persistent cache.</p>\n</blockquote>\n<h5 id=\"using-paging\">Using Paging</h5>\n<p>Depending on the complexity of the virtual view, building the persistent cache image can take some time. Since the internal connections used by RadiantOne to build the persistent cache image are subject to the Idle Connection Timeout server setting, the cache initialization process might fail due to the connection being automatically closed by the server. To avoid cache initialization problems, it is recommended to use paging for internal connections. To use paging:</p>\n<ol>\n<li>\n<p>Navigate to the Main Control Panel > Settings tab > Server Front End > Supported Controls.</p>\n</li>\n<li>\n<p>On the right, check the option to Enable Paged Results.</p>\n</li>\n<li>\n<p>Click <strong>Save</strong>.</p>\n</li>\n<li>\n<p>Navigate to the Main Control Panel > Settings tab > Server Backend > Internal Connections (requires <a href=\"00-preface#expert-mode\">Expert Mode</a>).</p>\n</li>\n<li>\n<p>On the right, check the option for Paged Results Control, page size: 1000.</p>\n</li>\n<li>\n<p>Click <strong>Save</strong>.</p>\n</li>\n</ol>\n<h5 id=\"supporting-zipped-and-encrypted-ldif-files\">Supporting Zipped and Encrypted LDIF Files</h5>\n<p>If you are initializing persistent cache using an existing LDIFZ file, the security key used in RadiantOne (for attribute encryption) where the file was exported must be the same security key value used on the RadiantOne server that you are trying to import the file into.</p>\n<p>If you are creating a new LDIF file to initialize the persistent cache, you have the option to use an LDIFZ file which is a zipped and encrypted file format. This ensures that the data to be cached is not stored in clear in files required for the initialization process.</p>\n<p>To use this option, you must have an LDIFZ encryption key configured. The security key is defined from the Main Control Panel > Settings Tab > Security > Attribute Encryption section.</p>\n<p>Once the security key has been defined, check the option to “Use .ldifz (zipped and secure format).</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 301px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.63636363636364%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEDAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7beEoTF//8QAGBAAAgMAAAAAAAAAAAAAAAAAAAECIDH/2gAIAQEAAQUCpLEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRABAAMBAQAAAAAAAAAAAAAAAQARIRCR/9oACAEBAAE/IZTPONLmM0bP/9oADAMBAAIAAwAAABDMD//EABYRAQEBAAAAAAAAAAAAAAAAACEBEP/aAAgBAwEBPxCjn//EABYRAQEBAAAAAAAAAAAAAAAAACEBEP/aAAgBAgEBPxCJn//EABwQAQACAwADAAAAAAAAAAAAAAEAESFRkTFxof/aAAgBAQABPxCm/B2C02dnv6lGjkZrkM0RqNFvRP/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/34e60315b412b44588ddc21ab52c6998/50ff8/Image2.4.jpg\"\n        srcset=\"/static/34e60315b412b44588ddc21ab52c6998/c1cfe/Image2.4.jpg 275w,\n/static/34e60315b412b44588ddc21ab52c6998/50ff8/Image2.4.jpg 301w\"\n        sizes=\"(max-width: 301px) 100vw, 301px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.4: Using LDIFZ File to Initialize Persistent Cache</p>\n<h4 id=\"options-for-refreshing-the-persistent-cache\">Options for Refreshing the Persistent Cache</h4>\n<p>There are four categories of events that can invoke a persistent cache refresh. They are:</p>\n<ul>\n<li>\n<p>When changes occur through RadiantOne.</p>\n</li>\n<li>\n<p>When changes occur outside of RadiantOne (directly on the backend source).</p>\n</li>\n<li>\n<p>Scheduling a periodic refresh of the persistent cache.</p>\n</li>\n</ul>\n<p>Each is described below.</p>\n<h5 id=\"changes-occurring-through-radiantone\">Changes Occurring Through RadiantOne</h5>\n<p>If RadiantOne receives an update for an entry that is stored in a persistent cache, the following operations occur:</p>\n<ul>\n<li>\n<p>The entry in persistent cache is “locked” pending the update to the underlying source(s).</p>\n</li>\n<li>\n<p>The underlying source(s) receives the update from RadiantOne.</p>\n</li>\n<li>\n<p>Upon successful update of the underlying source(s), RadiantOne updates the entry in the persistent cache.</p>\n</li>\n<li>\n<p>The modified entry is available in the persistent cache.</p>\n</li>\n</ul>\n<h4 id=\"real-time-cache-refresh-based-on-changes-occurring-directly-on-the-backend-sources\">Real Time Cache Refresh Based on Changes Occurring Directly on the Backend Source(s)</h4>\n<p>When a change happens in the underlying source, connectors capture the change and send it to update the persistent cache. The connectors are managed by agents built into RadiantOne and changes flow through a message queue for guaranteed message delivery. The real-time refresh process is outlined below.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 330px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.18181818181819%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAECAwQF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAQAC/9oADAMBAAIQAxAAAAHrRs1c3QNKEZBP/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEQIRH/2gAIAQEAAQUC02OcHf/EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/ASP/xAAVEQEBAAAAAAAAAAAAAAAAAAARIP/aAAgBAgEBPwFj/8QAFhAAAwAAAAAAAAAAAAAAAAAAADBB/9oACAEBAAY/Aio//8QAHBAAAgICAwAAAAAAAAAAAAAAAAERMUFRECGR/9oACAEBAAE/IZWbE99hUihM9MSJZ9KGeP/aAAwDAQACAAMAAAAQDAh8/8QAFREBAQAAAAAAAAAAAAAAAAAAIHH/2gAIAQMBAT8Qsf/EABURAQEAAAAAAAAAAAAAAAAAACBx/9oACAECAQE/EJH/xAAcEAACAgMBAQAAAAAAAAAAAAABEQAhMUFRgRD/2gAIAQEAAT8QJB3WLb8hhIooCR3U3sqO6XsKhs4xKhldkfoGBP/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/fcfb987b2f14c90c1e4657e7bc859f1f/4f5c6/Image2.5.jpg\"\n        srcset=\"/static/fcfb987b2f14c90c1e4657e7bc859f1f/c1cfe/Image2.5.jpg 275w,\n/static/fcfb987b2f14c90c1e4657e7bc859f1f/4f5c6/Image2.5.jpg 330w\"\n        sizes=\"(max-width: 330px) 100vw, 330px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.5: Persistent Cache Refresh Architecture</p>\n<p>Persistent Cache Refresh Agents are started automatically once a persistent cache with real-time refresh is configured. Agents can run on any type of RadiantOne cluster node (follower or leaders) and there is only one agent running at any given time in a RadiantOne cluster. The agent doesn't consume a lot of memory, and they are not CPU-intensive, so there is no point in running multiple processes to distribute connectors on multiple nodes. One agent is enough per cluster and makes things simpler.</p>\n<p>This type of refresh is described as “Real-time” in the Main Control Panel > Directory Namespace > Cache settings > Cache Branch > Refresh Settings tab (on the right). This is the recommended approach if a real-time refresh is needed.</p>\n<h5 id=\"periodic-refresh\">Periodic Refresh</h5>\n<p>In certain cases, if you know the data in the backends does not change frequently (e.g. once a day), you may not care about refreshing the persistent cache immediately when a change is detected in the underlying data source. In this case, a periodic refresh can be used.</p>\n<p>If you have built your view in either the Context Builder tab or Directory Namespace Tab, you can define the refresh interval after you’ve configured the persistent cache. The option to enable periodic refresh is on the Refresh Settings tab (on the right) for the selected persistent cache node. Once the periodic refresh is enabled, configure the interval using a CRON expression. Click the Assist button if you need help defining the CRON expression.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 974px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.72727272727273%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB2wUH/8QAFhAAAwAAAAAAAAAAAAAAAAAAARAS/9oACAEBAAEFAoD/AP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABkQAAMBAQEAAAAAAAAAAAAAAAABIRFhkf/aAAgBAQABPyFd/TKJSpaf/9oADAMBAAIAAwAAABBwD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQADAAMBAAAAAAAAAAAAAAEAESExQbHR/9oACAEBAAE/EADitvn9hdqTJX7Bp5P/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/13ad91c36b1ed4d17f9deff7eab81bf0/083a5/Image2.6.jpg\"\n        srcset=\"/static/13ad91c36b1ed4d17f9deff7eab81bf0/c1cfe/Image2.6.jpg 275w,\n/static/13ad91c36b1ed4d17f9deff7eab81bf0/67061/Image2.6.jpg 550w,\n/static/13ad91c36b1ed4d17f9deff7eab81bf0/083a5/Image2.6.jpg 974w\"\n        sizes=\"(max-width: 974px) 100vw, 974px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.6: Periodic Cache Refresh Settings</p>\n<p>During each refresh interval, the periodic persistent cache refresh is performed based on the following high-level steps:</p>\n<ol>\n<li>RadiantOne generates an LDIF formatted file from the virtual view (bypassing the cache).</li>\n</ol>\n<blockquote>\n<p>[!warning]\r\nIf a backend data source is unreachable, RadiantOne attempts to re-connect one more time after waiting 5 seconds. The number of retries is dictated by the maxPeriodicRefreshRetryCount property defined in <code class=\"language-text\">/radiantone/&lt;version>/&lt;clusterName>/config/vds_server.conf</code> in ZooKeeper.</p>\n</blockquote>\n<ol start=\"2\">\n<li>\n<p>(Optional) If a <a href=\"#add-validation-threshold\">validation threshold</a> is defined, RadiantOne determines if the threshold defined has been exceeded. If it has, the persistent cache is not refreshed during this cycle.</p>\n</li>\n<li>\n<p>RadiantOne compares the LDIF file generated in step 1 to the current cache image and applies changes to the cache immediately as it goes through the comparison.</p>\n</li>\n</ol>\n<p>The periodic persistent cache refresh activity is logged into periodiccache.log. This file can be viewed and downloaded from Server Control Panel > Log Viewer. For details on this log, see the Logging and Troubleshooting Guide.</p>\n<p>The rebuild process can be very taxing on your backends, and each time a new image is built you are putting stress on the data sources. This type of cache refresh deployment works well when the data doesn’t change too frequently and the volume of data is relatively small.</p>\n<h4 id=\"configuring-persistent-cache-with-periodic-refresh\">Configuring Persistent Cache with Periodic Refresh</h4>\n<p>Review the section on <a href=\"#periodic-refresh\">periodically refreshing the cache</a> to ensure the persistent cache is updated to match your needs. If you plan on refreshing the cache image periodically on a defined schedule, this would be the appropriate cache configuration option. This type of caching option leverages the internal RadiantOne Universal Directory storage for the cache image.</p>\n<p>To configure persistent cache with Periodic refresh</p>\n<ol>\n<li>\n<p>On the Directory Namespace tab of the Main Control Panel, click the Cache node.</p>\n</li>\n<li>\n<p>On the right side, browse to the branch in the RadiantOne namespace that you would like to store in persistent cache and click <strong>OK</strong>.</p>\n</li>\n<li>\n<p>Click <strong>Create Persistent Cache</strong>. The configuration process begins. Once it completes, click <strong>OK</strong> to exit the window.</p>\n</li>\n<li>\n<p>Click the <strong>Refresh Settings</strong> tab.</p>\n</li>\n<li>\n<p>Select the Periodic Refresh option.</p>\n</li>\n<li>\n<p>Enter the <a href=\"#periodic-refresh-cron-expression\">CRON expression</a> to define the refresh interval.</p>\n</li>\n<li>\n<p>(Optional) Define a <a href=\"#delete-validation-threshold\">Delete Validation Threshold</a>.</p>\n</li>\n<li>\n<p>(Optional) Define an <a href=\"#add-validation-threshold\">Add Validation Threshold</a>.</p>\n</li>\n<li>\n<p>Click <strong>Save</strong>.</p>\n</li>\n<li>\n<p>Click <strong>Initialize</strong> to start the initialization process.</p>\n</li>\n</ol>\n<p>There are two options for initializing the persistent cache: Creating a new LDIF file or initializing from an existing LDIF file. Each is described below.</p>\n<h4 id=\"create-an-ldif-from-a-snapshot\">Create an LDIF from a Snapshot</h4>\n<p>If this is the first time you’ve initialized the persistent cache, then you should choose this option. An LDIF formatted file is generated from the virtual view and then imported into the local RadiantOne Universal Directory store.</p>\n<p><strong>Initialize from an Existing LDIF File</strong></p>\n<p>If you’ve initialized the persistent cache before and the LDIF file was created successfully from the backend source(s) (and the data from the backend(s) has not changed since the generation of the LDIF file), then you can choose to use that existing file. The persisting of the cache occurs in two phases. The first phase generates an LDIF file with the data returned from the queries to the underlying data source(s). The second phase imports the LDIF file into the local RadiantOne Universal Directory store. If there is a failure during the second phase, and you must re-initialize the persistent cache, you have the option to choose the LDIF file (that was already built during the first phase) instead of having to re-generate it (as long as the LDIF file generated successfully). You can click browse and navigate to the location of the LDIF. The LDIF files generated are in &#x3C;RLI_HOME>&#x3C;instance_name>\\ldif\\import.</p>\n<p>If you have a large data set and generated multiple LDIF files for the purpose of initializing the persistent cache (each containing a subset of what you want to cache), name the files with a suffix of “_2”, “_3”…etc. For example, let’s say the initial LDIF file (containing the first subset of data you want to import) is named cacheinit.ldif. After this file has been imported, the process attempts to find cacheinit_2.ldif, then cacheinit_3.ldif…etc. Make sure all files are located in the same place so the initialization process can find them.</p>\n<p>After you choose to either generate or re-use an LDIF file, click Finish and cache initialization begins. Cache initialization is launched as a task and can be viewed and managed from the Tasks Tab in the Server Control Panel associated with the RadiantOne leader node. Therefore, you do not need to wait for the initialization to finish before exiting the initialization window.</p>\n<p>After the persistent cache is initialized, queries are handled locally by the RadiantOne service and no longer be sent to the backend data source(s). For information about properties associated with persistent cache, please see <a href=\"#persistent-cache-properties\">Persistent Cache Properties</a>.</p>\n<h5 id=\"periodic-refresh-cron-expression\">Periodic Refresh CRON Expression</h5>\n<p>If periodic refresh is enabled, you must define the refresh interval in this property. For example, if you want the persistent cache refreshed every day at 12:00 PM, the CRON expression is:\r\n0 0 12 1/1 * ? *\r\nClick <strong>Assist</strong> if you need help defining the CRON expression.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 407px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAWEAADAAAAAAAAAAAAAAAAAAAAEBH/2gAIAQEAAQUCVP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAAMAAAAAAAAAAAAAAAAAAAAQMf/aAAgBAQAGPwJQ/8QAFxABAQEBAAAAAAAAAAAAAAAAAREAQf/aAAgBAQABPyGZYWLiut//2gAMAwEAAgADAAAAEPAP/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8QZ//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ECf/xAAYEAEAAwEAAAAAAAAAAAAAAAABABFxIf/aAAgBAQABPxAHJdYAwBdGpP/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/c131e18862496130c8cb2d88ff0a549b/fabf6/Image2.7.jpg\"\n        srcset=\"/static/c131e18862496130c8cb2d88ff0a549b/c1cfe/Image2.7.jpg 275w,\n/static/c131e18862496130c8cb2d88ff0a549b/fabf6/Image2.7.jpg 407w\"\n        sizes=\"(max-width: 407px) 100vw, 407px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.7: CRON Expression Editor</p>\n<h5 id=\"delete-validation-threshold\">Delete Validation Threshold</h5>\n<p>For details on how the periodic persistent cache refresh process works, see <a href=\"#periodic-refresh\">Periodic Refresh</a>.</p>\n<p>You can define a threshold to validate the generated LDIF file/image prior to RadiantOne executing the cache refresh process. The threshold is a percentage of the total entries.</p>\n<p>To define a granular threshold for delete operations, indicate the percentage in the Delete Validation Threshold. For example, if Delete Validation Threshold contains a value of 50, it means if the generated LDIF image contains at least 50% fewer entries than the current cache image, the periodic persistent cache refresh is aborted for the current refresh cycle.</p>\n<p>If a validation threshold is configured, the threshold is checked.</p>\n<h5 id=\"add-validation-threshold\">Add Validation Threshold</h5>\n<p>For details on how the periodic persistent cache refresh process works, see <a href=\"#periodic-refresh\">Periodic Refresh</a>.</p>\n<p>You can define a threshold to validate the generated LDIF file/image prior to RadiantOne executing the cache refresh process. The threshold is a percentage of the total entries.</p>\n<p>To define a granular threshold for add operations, indicate the percentage in the Add Validation Threshold. For example, if Add Validation Threshold contains a value of 50, it means if the generated LDIF image contains 50% more entries than the current cache image, the periodic persistent cache refresh is aborted for the current refresh cycle.</p>\n<h4 id=\"configuring-persistent-cache-with-real-time-refresh\">Configuring Persistent Cache with Real-Time Refresh</h4>\n<p>If you plan on automatically refreshing the persistent cache as changes happen on the backend data sources, this would be the recommended cache configuration option. This type of caching option leverages the RadiantOne Universal Directory storage for the cache image.</p>\n<p>If you choose a real-time refresh strategy, there are two terms you need to become familiar with:</p>\n<ul>\n<li>\n<p>Cache Dependency – cache dependencies are all objects/views related to the view that is configured for persistent cache. A cache dependency is used by the cache refresh process to understand all the different objects/views that need to be updated based on changes to the backend sources.</p>\n</li>\n<li>\n<p>Cache Refresh Topology – a cache refresh topology is a graphical representation of the flow of data needed to refresh the cache. The topology includes an object/icon that represents the source (the backend object where changes are detected from), the queue (the temporary storage of the message), and the cache destination. Cache refresh topologies can be seen from the Main Control Panel > PCache Monitoring tab.</p>\n</li>\n</ul>\n<p>Cache dependencies and the refresh topology are generated automatically during the cache configuration process.</p>\n<p>If you have deployed multiple nodes in a cluster, to configure and initialize the persistent cache, you must be on the current RadiantOne leader node. To find out the leader status of the nodes, go to the Dashboard tab > Overview section in the Main Control Panel and locate the node with a yellow triangle icon.</p>\n<p>To configure persistent cache with real-time refresh:</p>\n<ol>\n<li>\n<p>Go to the Directory Namespace Tab of the Main Control Panel associated with the current RadiantOne leader node.</p>\n</li>\n<li>\n<p>Click the Cache node.</p>\n</li>\n<li>\n<p>On the right side, browse to the branch in the RadiantOne namespace that you would like to store in persistent cache and click <strong>OK</strong>.</p>\n</li>\n</ol>\n<blockquote>\n<p>[!warning]\r\nFor proxy views of LDAP backends, you must select the root level to start the cache from. Caching only a sub-container of a proxy view is not supported.</p>\n</blockquote>\n<ol start=\"4\">\n<li>\n<p>Click Create Persistent Cache. The configuration process begins. Once it completes, click OK to exit the window.</p>\n</li>\n<li>\n<p>On the Refresh Settings tab, select the Real-time refresh option.</p>\n</li>\n</ol>\n<blockquote>\n<p>[!warning]\r\nIf your virtual view is joined with other virtual views you must cache the secondary views first. Otherwise, you are unable to configure the real-time refresh and will see the following message. A Diagnostic button is also shown and provides more details about which virtual views require caching.</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 385px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.90909090909091%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB25MthH//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwGq/8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAGRAAAQUAAAAAAAAAAAAAAAAAABARYZGh/9oACAEBAAE/IbHnE//aAAwDAQACAAMAAAAQ89//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPxCI/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8QpT//xAAYEAEBAQEBAAAAAAAAAAAAAAAhAQARYf/aAAgBAQABPxDjXwQ0rjiQW7//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/f5043d9b63fe4007f74fe26bf0e54cea/47ca8/Image2.8.jpg\"\n        srcset=\"/static/f5043d9b63fe4007f74fe26bf0e54cea/c1cfe/Image2.8.jpg 275w,\n/static/f5043d9b63fe4007f74fe26bf0e54cea/47ca8/Image2.8.jpg 385w\"\n        sizes=\"(max-width: 385px) 100vw, 385px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.8: Caching secondary views message</p>\n<ol start=\"6\">\n<li>\n<p>Configure any needed connectors. Please see the section titled <a href=\"#configuring-source-connectors\">Configuring Source Connectors</a> for steps.</p>\n</li>\n<li>\n<p>Click <strong>Save</strong>.</p>\n</li>\n<li>\n<p>On the Refresh Settings tab, click Initialize to initialize the persistent cache.</p>\n</li>\n</ol>\n<p>There are two options for initializing a persistent cache. Each is described below.</p>\n<p><strong>Create an LDIF File</strong></p>\n<p>If this is the first time you’ve initialized the persistent cache, choose this option. An LDIF formatted file is generated from the virtual view and then imported into the cache.</p>\n<p>**Using an Existing LDIF **</p>\n<p>If you’ve initialized the persistent cache before and the LDIF file was created successfully from the backend source(s) (and the data from the backend(s) has not changed since the generation of the LDIF file), then you can choose this option to use that existing file. The persisting of the cache occurs in two phases. The first phase generates an LDIF file with the data returned from the queries to the underlying data source(s). The second phase imports the LDIF file into the local RadiantOne Universal Directory store. If there is a failure during the second phase, and you must re-initialize the persistent cache, you have the option to choose the LDIF file (that was already built during the first phase) instead of having to re-generate it (as long as the LDIF file generated successfully). You can click browse and navigate to the location of the LDIF. The LDIF files generated are in <code class=\"language-text\">&lt;RLI_HOME>\\&lt;vds_server>\\ldif\\import</code>.</p>\n<p>If you have a large data set and generated multiple LDIF files for the purpose of initializing the persistent cache (each containing a subset of what you want to cache), name the files with a suffix of “_2”, “_3”…etc. For example, let’s say the initial LDIF file (containing the first subset of data you want to import) is named cacheinit.ldif. After this file has been imported, the process attempts to find cacheinit_2.ldif, then cacheinit_3.ldif…etc. Make sure all files are located in the same place so the initialization process can find them.</p>\n<ol start=\"9\">\n<li>\n<p>Click <strong>OK</strong>. The cache initialization process begins. The cache initialization is performed as a task and can be viewed and managed from the Tasks Tab in the Server Control Panel associated with the RadiantOne leader node. Therefore, you do not need to wait for the initialization to finish before exiting the initialization window.</p>\n</li>\n<li>\n<p>The view(s) is now in the persistent cache. Queries are handled locally by RadiantOne and are no longer sent to the backend data source(s). Real-time cache refresh has been configured. For information about properties associated with persistent cache, please see <a href=\"#persistent-cache-properties\">Persistent Cache Properties</a>.</p>\n</li>\n</ol>\n<h5 id=\"configuring-source-connectors\">Configuring Source Connectors</h5>\n<p>Configuring connectors involves deciding how you want to detect changes from your backend(s). By default, all <a href=\"#directory-connectors\">directory connectors</a> and <a href=\"#custom-connectors\">custom connectors</a> (only custom connectors included in the RadiantOne install) are configured and started immediately without further configuration. For databases, configure the connector to use the desired change detection mechanism.</p>\n<blockquote>\n<p>[!warning]\r\nAll connectors leverage the connection pooling settings defined from the Main Control Panel > Settings tab. In other words, the connector opens a connection to the data source to pick up changes and keeps the connection open so when the next interval passes a new connection does not need to be created.</p>\n</blockquote>\n<h3 id=\"database-connectors\">Database Connectors</h3>\n<p>For database backends (JDBC-accessible), the change detection options are:</p>\n<ul>\n<li>\n<p><a href=\"#db-changelog\">Changelog</a> – This connector type relies on a database table that contains all changes that have occurred on the base tables (that the RadiantOne virtual view is built from). This typically involves having triggers on the base tables that write into the log/changelog table. However, an external process may be used instead of triggers. The connector picks up changes from the changelog table based on a specified interval which is 10 seconds by default.</p>\n</li>\n<li>\n<p><a href=\"#db-timestamp\">Timestamp</a> – This connector type has been validated against Oracle, SQL Server, MySQL, MariaDB, PostgreSQL, and Apache Derby. The database table must have a primary key defined for it and an indexed column that contains a timestamp/date value. This value must be maintained and modified accordingly for each record that is updated.</p>\n<p>For Oracle databases, the timestamp column type must be one of the following: \"TIMESTAMP\", \"DATE\", \"TIMESTAMP WITH TIME ZONE\", \"TIMESTAMP WITH LOCAL TIME ZONE\".</p>\n<p>For SQL Server database, the timestamp column type must be one of the following: \"SMALLDATETIME\", \"DATETIME\", \"DATETIME2\"</p>\n<p>For MYSQL or MariaDB databases, the timestamp column type must be one of the following: \"TIMESTAMP\", \"DATETIME\"</p>\n<p>For PostgreSQL databases, the timestamp column type must be one of the following: \"TIMESTAMP\", \"timestamp without time zone” (equivalent to timestamp), “TIMESTAMPTZ”, “timestamp with time zone” (equivalent to timestamptz)</p>\n<p>For Derby databases, the timestamp column type must be: \"TIMESTAMP\"</p>\n<p>The DB Timestamp connector leverages the timestamp column to determine which records have changed since the last polling interval. This connector type does not detect delete operations. If you have a need to detect and propagate delete operations from the database, you should choose a different connector type like DB Changelog or DB Counter.</p>\n</li>\n<li>\n<p><a href=\"#db-counter\">Counter</a> - This connector type is supported for any database table that has an indexed column that contains a sequence-based value that is automatically maintained and modified for each record that is added/updated. This column must be one of the following types: BIGINT, DECIMAL, INTEGER, or NUMERIC. If DECIMAL or NUMERIC are used, they should be declared without numbers after the dot: DECIMAL(6,0) not as DECIMAL(6,2). The DB Counter connector leverages this column to determine which records have changed since the last polling interval. This connector type can detect delete operations as long as the table has a dedicated “Change Type” column that indicates one of the following values: insert, update, delete. If the value is empty or something other than insert, update, or delete, an update operation is assumed.</p>\n<blockquote>\n<p>[!warning]\r\nIf none of these options are useable with your database, use a periodic cache refresh instead of real-time.</p>\n</blockquote>\n</li>\n</ul>\n<h6 id=\"db-changelog\">DB Changelog</h6>\n<p>RadiantOne can generate the SQL scripts which create the configuration needed to support the DB Changelog Connector. The scripts can be generated in the Main Control Panel. The following scripts are generated.</p>\n<ul>\n<li>\n<p>create_user.sql – Reminds you to have your DBA manually create a user account to be associated with the connector.</p>\n</li>\n<li>\n<p>create_capture.sql - Creates the log table and the triggers on the base table.</p>\n</li>\n<li>\n<p>drop_capture.sql - Drops the triggers and the log table.</p>\n</li>\n</ul>\n<p><br>Note: for some databases the file is empty.</p>\n<ul>\n<li>drop_user.sql - Drops the log table user and schema.</li>\n</ul>\n<p><br> Note: for some databases the file is empty.</p>\n<h5 id=\"connector-configuration\">Connector Configuration</h5>\n<p>This section describes generating and executing the scripts in the Main Control Panel. The following steps assume the database backend has a changelog table that contains changed records that need to be updated in the persistent cache. The changelog table must have two key columns named RLICHANGETYPE and RLICHANGEID. RLICHANGETYPE must indicate insert, update or delete, dictating what type of change was made to the record. RLICHANGEID must be a sequence-based, auto-incremented INTEGER that contains a unique value for each record. The DB Changelog connector uses RLICHANGEID to maintain a cursor to keep track of processed changes.</p>\n<p>To configure DB Changelog connector:</p>\n<blockquote>\n<p>[!note]\r\nThese instructions assume you want to apply the SQL scripts immediately and you already have a user account in the database to use for the connector.</p>\n</blockquote>\n<ol>\n<li>From the Main Control Panel > Directory Namespace Tab, select the configured persistent cache branch below the Cache node.</li>\n<li>On the right side, select the Refresh Settings tab.</li>\n<li>When the Real-time refresh type is selected, the connectors appear in a table below. Select a connector and click <strong>Configure</strong>.</li>\n<li>Select DB Changelog from the Connector Type drop-down list.</li>\n</ol>\n<p>5.Enter the log table name using the proper syntax for your database (e.g. <code class=\"language-text\">&lt;USER></code>.<code class=\"language-text\">&lt;TABLE>_LOG)</code>. If you used <a href=\"#log-table-name-syntax\">RadiantOne to generate the SQL scripts</a> for configuring the changelog components in the database, you can view the scripts to see the exact table name. Otherwise, contact your DBA for the log table name.</p>\n<blockquote>\n<p>[!warning]\r\nChange the value for this property only if you are creating the log table manually and the capture connector does not calculate the log table name correctly. Be sure to use the <a href=\"#log-table-name-syntax\">correct syntax</a> if you change the value.</p>\n</blockquote>\n<ol start=\"6\">\n<li>Indicate the user name and password for the connector’s dedicated credentials for connecting to the log table. If you do not have the user name and password, contact your DBA for the credentials. An example is shown below.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.72727272727272%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAd1OgSSf/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAECESEx/9oACAEBAAEFAsH4iK1Dvv8A/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQMBAT8BV//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABsQAAMBAAMBAAAAAAAAAAAAAAABESExQVGx/9oACAEBAAE/IUngnQTN+FZybCjUynB//9oADAMBAAIAAwAAABDw7//EABYRAQEBAAAAAAAAAAAAAAAAAAERAP/aAAgBAwEBPxBIx0b/xAAXEQADAQAAAAAAAAAAAAAAAAAAASER/9oACAECAQE/EFaaj//EABoQAQEBAQADAAAAAAAAAAAAAAERADFBUWH/2gAIAQEAAT8QbaMQuH2FzPnb8ZpOHA5voaLbU7v/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/c0f14ec575e498b90d1e10cd2ce16fc3/b966c/Image2.9.jpg\"\n        srcset=\"/static/c0f14ec575e498b90d1e10cd2ce16fc3/c1cfe/Image2.9.jpg 275w,\n/static/c0f14ec575e498b90d1e10cd2ce16fc3/67061/Image2.9.jpg 550w,\n/static/c0f14ec575e498b90d1e10cd2ce16fc3/b966c/Image2.9.jpg 624w\"\n        sizes=\"(max-width: 624px) 100vw, 624px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.9: DB Changelog Connector Configuration</p>\n<ol start=\"7\">\n<li>\n<p>Click <strong>Next</strong>.</p>\n</li>\n<li>\n<p>When the connector has been configured, click Next again.</p>\n</li>\n<li>\n<p>Select <strong>Apply Now</strong>. Click <strong>Next</strong>.</p>\n<blockquote>\n<p>[!note]\r\nSelecting Apply Now creates and executes the SQL scripts. If you choose to apply later, the scripts can be downloaded to be reviewed and applied by the DBA directly on the database server.</p>\n</blockquote>\n</li>\n<li>\n<p>Click <strong>Next</strong> and then click <strong>Finish</strong>.</p>\n</li>\n<li>\n<p>After all connectors are configured, click <strong>Save</strong>.</p>\n</li>\n</ol>\n<blockquote>\n<p>[!note]\r\nThe Execute DB Configure Scripts and Execute DB Deconfigure Scripts buttons become available when you finish configuring the connector. Execute DB Configure Scripts runs create_capture.sql. Execute DB Deconfigure Scripts runs drop_capture.sql. The location that RadiantOne looks for these scripts in cannot be changed.</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 478px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.63636363636364%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQCBf/EABQBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAe4hIXMiv//EABkQAAMAAwAAAAAAAAAAAAAAAAABEQMQMv/aAAgBAQABBQLUKysx8f/EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/Aaf/xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPwGH/8QAFxAAAwEAAAAAAAAAAAAAAAAAABAxQf/aAAgBAQAGPwJaUq//xAAcEAACAgIDAAAAAAAAAAAAAAAAAWGRESFBUYH/2gAIAQEAAT8h306HlrnwUrE6ydY7aZ2f/9oADAMBAAIAAwAAABA03//EABYRAQEBAAAAAAAAAAAAAAAAAAABIf/aAAgBAwEBPxBmx//EABYRAQEBAAAAAAAAAAAAAAAAAAABIf/aAAgBAgEBPxBs1//EABsQAQACAwEBAAAAAAAAAAAAAAEAESFBUbFx/9oACAEBAAE/EO/hhMbRvYpmH1hqO7tGo90REq3K3uf/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/3b45d000341279a3f2aae8422b0e4c16/74f5b/Image2.10.jpg\"\n        srcset=\"/static/3b45d000341279a3f2aae8422b0e4c16/c1cfe/Image2.10.jpg 275w,\n/static/3b45d000341279a3f2aae8422b0e4c16/74f5b/Image2.10.jpg 478w\"\n        sizes=\"(max-width: 478px) 100vw, 478px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.10: The Execute DB Configure and Deconfigure buttons</p>\n<ol start=\"12\">\n<li>Go to Main Control Panel > PCache Monitoring tab to start connectors, configure <a href=\"#connector-properties\">connector properties</a> and manage and monitor the persistent cache refresh process.</li>\n</ol>\n<blockquote>\n<p>[!warning]\r\nIf you make changes to the DB Changelog Connector configuration, restart the connector on the PCache Monitoring tab. Select the icon representing the database backend and click Stop. Then click Start to restart it.</p>\n</blockquote>\n<h5 id=\"log-table-name-syntax\">Log Table Name Syntax</h5>\n<p>Proper syntax for the Log Table Name must include both the schema name and the table name separated with a period. Values for this property may contain quote marks as required by the database. In most cases, the double quote mark (“) is used, but some databases use a single quote (‘) or back quote (`). The following examples explain the property’s syntax and usage.</p>\n<p>Example 1:\r\n<br>For Postgres, if the schema is rli_con, and log table name is test_log, the property should be one of the following.</p>\n<blockquote>\n<p>[!note]\r\nBy default, Postgres uses lower-case table names.</p>\n</blockquote>\n<p>rli_con.test_log\r\nor with optional quoting:\r\n\"rli_con\".\"test_log\"</p>\n<p>Example 2:\r\n<br>For SQL Server, if the schema is RLI_CON, and log table name is TEST_LOG, the property should be one of the following.</p>\n<blockquote>\n<p>[!note]\r\nBy default, many databases, including SQL Server, use upper-case table names.</p>\n</blockquote>\n\n          <codeblockcopytag>RLI_CON.TEST_LOG </codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">RLI_CON.TEST_LOG </code></pre></div>\n<p>Or with optional quoting:</p>\n\n          <codeblockcopytag>&quot;RLI_CON&quot;.&quot;TEST_LOG&quot;</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"RLI_CON\".\"TEST_LOG\"</code></pre></div>\n<blockquote>\n<p>[!note]\r\nIf this name is the same as the log name in the database, leave the property empty.</p>\n</blockquote>\n<p>Example 3:\r\n<br>If schema and/or table name contain mixed-case characters, they must be quoted. For example, if the schema is Rli_Con, and log table name is Test_Log, the property should be as follows.</p>\n\n          <codeblockcopytag>&quot;Rli_con&quot;.&quot;Test_log&quot;</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"Rli_con\".\"Test_log\"</code></pre></div>\n<h6 id=\"db-timestamp\">DB Timestamp</h6>\n<p>The following steps assume your backend database table has a primary key defined and contains a timestamp column. The timestamp column name is required for configuring the connector. The timestamp column database types supported are described in the <a href=\"#database-connectors\">Database Connectors</a> section.</p>\n<blockquote>\n<p>[!warning]\r\nThis connector type does not detect delete operations. If you need to detect delete operations from the database, you should choose a different connector type.</p>\n</blockquote>\n<ol>\n<li>\n<p>From the Main Control Panel > Directory Namespace Tab, select the configured persistent cache branch below the Cache node.</p>\n</li>\n<li>\n<p>On the right side, select the Refresh Settings tab.</p>\n</li>\n<li>\n<p>When the Real-time refresh type is selected, the connectors appear in a table below. Select a connector and click <strong>Configure</strong>.</p>\n</li>\n<li>\n<p>Select DB Timestamp from the Connector Type drop-down list.</p>\n</li>\n<li>\n<p>Indicate the column name in the database table that contains the timestamp. An example is shown below.</p>\n</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 539px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.09090909090909%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAd6CQH//xAAXEAADAQAAAAAAAAAAAAAAAAAAAQIx/9oACAEBAAEFAh4qP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABcQAQEBAQAAAAAAAAAAAAAAAAEAIUH/2gAIAQEAAT8hMnqBO3//2gAMAwEAAgADAAAAEHw//8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAx/9oACAEDAQE/EHIb/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAx/9oACAECAQE/EDZL/8QAFxABAQEBAAAAAAAAAAAAAAAAAREAcf/aAAgBAQABPxCBMIzQC6tK6b//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/f327511c7abb3a2195bfe7cc4a378ed0/4a972/Image2.11.jpg\"\n        srcset=\"/static/f327511c7abb3a2195bfe7cc4a378ed0/c1cfe/Image2.11.jpg 275w,\n/static/f327511c7abb3a2195bfe7cc4a378ed0/4a972/Image2.11.jpg 539w\"\n        sizes=\"(max-width: 539px) 100vw, 539px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.11: DB Timestamp Connector Configuration</p>\n<ol start=\"6\">\n<li>\n<p>Click <strong>OK</strong>.</p>\n</li>\n<li>\n<p>After all connectors are configured, click <strong>Save</strong>.</p>\n</li>\n<li>\n<p>The connectors are started automatically once they are configured.</p>\n</li>\n<li>\n<p>Go to Main Control Panel > PCache Monitoring tab to configure connector properties and manage and monitor the persistent cache refresh process.</p>\n</li>\n</ol>\n<blockquote>\n<p>[!warning]\r\nIf you need to make changes to the timestamp column name, manually restart the connector and reset the cursor. This can be done from the PCache Monitoring tab. Select the icon representing the database backend and click Stop. Then click Start to restart it. Then click Reset Cursor.</p>\n</blockquote>\n<h6 id=\"db-counter\">DB Counter</h6>\n<p>The following steps assume your database backend table contains an indexed column that contains a sequence-based value that is automatically maintained and modified for each record that is added, updated or deleted. The DB Counter connector uses this column to maintain a cursor to keep track of processed changes. The counter column database types supported are described in the <a href=\"#database-connectors\">Database Connectors</a> section.</p>\n<ol>\n<li>\n<p>From the Main Control Panel > Directory Namespace Tab, select the configured persistent cache branch below the Cache node.</p>\n</li>\n<li>\n<p>On the right side, select the Refresh Settings tab.</p>\n</li>\n<li>\n<p>When the Real-time refresh type is selected, the connectors appear in a table below. Select a connector and click <strong>Configure</strong>.</p>\n</li>\n<li>\n<p>Select DB Counter from the Connector Type drop-down list.</p>\n</li>\n<li>\n<p>Enter a value in the Change Type Column field. This value should be the database table column that contains the information about the type of change (insert, update or delete). If the column doesn’t have a value, an update operation is assumed.</p>\n</li>\n<li>\n<p>Enter the column name in the database table that contains the counter. An example is shown below.</p>\n</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 404px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.909090909090914%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHdFVKkhf/EABgQAAIDAAAAAAAAAAAAAAAAAAABAhAx/9oACAEBAAEFAh3LEf/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABsQAAIBBQAAAAAAAAAAAAAAAAABERAhMVFh/9oACAEBAAE/IUlo4Ipc8mJ//9oADAMBAAIAAwAAABDPz//EABYRAQEBAAAAAAAAAAAAAAAAAAEQIf/aAAgBAwEBPxBwn//EABYRAQEBAAAAAAAAAAAAAAAAAAEQIf/aAAgBAgEBPxA1n//EABoQAQADAAMAAAAAAAAAAAAAAAEAESExQVH/2gAIAQEAAT8QtNiAAocwCaFy31mBoemYVZs//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/89e8617c97009b560e647ad76531e0ab/24ff0/Image2.12.jpg\"\n        srcset=\"/static/89e8617c97009b560e647ad76531e0ab/c1cfe/Image2.12.jpg 275w,\n/static/89e8617c97009b560e647ad76531e0ab/24ff0/Image2.12.jpg 404w\"\n        sizes=\"(max-width: 404px) 100vw, 404px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.12: DB Counter Connector Configuration</p>\n<ol start=\"7\">\n<li>\n<p>Click <strong>OK</strong>.</p>\n</li>\n<li>\n<p>After all connectors are configured, click <strong>Save</strong>.</p>\n</li>\n<li>\n<p>The connectors are started automatically once they are configured.</p>\n</li>\n<li>\n<p>Go to Main Control Panel > PCache Monitoring tab to configure connector properties and manage and monitor the persistent cache refresh process.</p>\n</li>\n</ol>\n<blockquote>\n<p>[!warning]\r\nIf you need to make changes to the Counter Column name, manually restart the connector and reset the cursor. This can be done from the PCache Monitoring tab. Select the icon representing the database backend and click Stop. Then click Start to restart it. Then click Reset Cursor.</p>\n</blockquote>\n<h6 id=\"database-connector-failover\">Database Connector Failover</h6>\n<p>This section describes the failover mechanism for the database connectors.</p>\n<blockquote>\n<p>[!warning]\r\nThe backend servers must be configured for multi-master replication. Please check the vendor documentation for assistance with configuring replication for your backends.</p>\n</blockquote>\n<p>The database connectors leverage the failover server that has been configured for the data source. When you configure a data source for your backend database, select a failover database server from the drop-down list. The failover server must be configured as a RadiantOne data source. See the screen shot below for how to indicate a failover server for the Data Sources from the Main Control Panel.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHbpcgf/8QAFRABAQAAAAAAAAAAAAAAAAAAACH/2gAIAQEAAQUCRH//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwGI/8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAGRAAAwADAAAAAAAAAAAAAAAAABEhAXHw/9oACAEBAAE/IcJ05DQ//9oADAMBAAIAAwAAABD/AN//xAAWEQADAAAAAAAAAAAAAAAAAAAAARH/2gAIAQMBAT8QbhT/xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQIBAT8QykP/xAAaEAEAAwADAAAAAAAAAAAAAAABABExQXGB/9oACAEBAAE/EBkKo4nQhHofJ//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/aac137cad0f812f04825c1f1e2ed85ba/b966c/Image2.14.jpg\"\n        srcset=\"/static/aac137cad0f812f04825c1f1e2ed85ba/c1cfe/Image2.14.jpg 275w,\n/static/aac137cad0f812f04825c1f1e2ed85ba/67061/Image2.14.jpg 550w,\n/static/aac137cad0f812f04825c1f1e2ed85ba/b966c/Image2.14.jpg 624w\"\n        sizes=\"(max-width: 624px) 100vw, 624px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.14: Configuring Failover Servers for the Backend Database</p>\n<p>If a connection cannot be made to the primary server, the connector tries to connect to the failover server configured in the data source. If a connection to both the primary and failover servers fails, the retry count goes up. The connector repeats this process until the value configured in <a href=\"#max-retries-on-connection-error-for-database-connectors\">Max Retries on Connection Error</a> is reached. There is no automatic failback, meaning once the primary server is back online, the connector doesn’t automatically go back to it.</p>\n<h6 id=\"re-configuring-database-connectors\">Re-configuring Database Connectors</h6>\n<p>By re-configuring the connector, you can change the connector type.</p>\n<p>The connector can be re-configured from the Main Control Panel > Directory Namespace Tab. Navigate below the Cache node and select the persistent cache branch configured for auto-refresh. On the right side, select the Refresh Settings tab. Select the connector you want to re-configure and choose Configure.</p>\n<p>To change the connector user password, for a connector currently using DB Changelog, enter the user name and password in the Credentials section.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 359px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.63636363636363%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB3WkkisP/xAAYEAADAQEAAAAAAAAAAAAAAAAAAQIQEf/aAAgBAQABBQIe0+SrP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAQEBAAAAAAAAAAAAAAAAAAEQIP/aAAgBAQAGPwLCz//EABoQAAMBAAMAAAAAAAAAAAAAAAABMSEQEVH/2gAIAQEAAT8hSXhhQWqcZxDsUP/aAAwDAQACAAMAAAAQrB//xAAWEQEBAQAAAAAAAAAAAAAAAAAAETH/2gAIAQMBAT8QxX//xAAVEQEBAAAAAAAAAAAAAAAAAAAQMf/aAAgBAgEBPxCn/8QAGRABAQEAAwAAAAAAAAAAAAAAAREAIYGh/9oACAEBAAE/EHrwcCh4xKIMMcsUzZmtJ3v/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/b4f303aae4294c121456c065e47a5802/f86e9/Image2.15.jpg\"\n        srcset=\"/static/b4f303aae4294c121456c065e47a5802/c1cfe/Image2.15.jpg 275w,\n/static/b4f303aae4294c121456c065e47a5802/f86e9/Image2.15.jpg 359w\"\n        sizes=\"(max-width: 359px) 100vw, 359px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.15: Editing DB Changelog Connector Configuration</p>\n<p>To change the detection mechanism from DB Changelog to another method, select the type from the Connector Type drop-down menu. Enter values as needed for the properties specific to the new connector type and click Next. Click Next in the confirmation window to confirm that you want the connector reconfigured. Click Next to confirm that the connector has been reconfigured. Click Finish.</p>\n<h6 id=\"directory-connectors\">Directory Connectors</h6>\n<p>For directory backends (LDAP-accessible including RadiantOne Universal Directory and Active Directory), the default connectors are configured and started automatically. Go to Main Control Panel > PCache Monitoring tab to configure connector properties and manage and monitor the persistent cache refresh process.</p>\n<blockquote>\n<p>[!warning]\r\nIf you are using a persistent cache on a proxy view of a local RadiantOne Universal Directory store, or a nested persistent cache view (a cached view used in another cached view), the connector type is noted as HDAP Trigger. This is a special trigger mechanism that publishes the changes directly into the queue to automatically invoke the refresh to all associated persistent cache layers. This change detection mechanism doesn’t require a connector process (or agents). If a RadiantOne service is virtualizing an external (non-local) RadiantOne Universal Directory store, and a persistent cache is configured for the view, this is considered an “LDAP backend” and the refresh connector can be configured for either changelog or persistent search (whatever is enabled/supported on the remote RadiantOne server) as described below.</p>\n</blockquote>\n<h6 id=\"ldap-directories\">LDAP Directories</h6>\n<p>For LDAP backends that support both Changelog and Persistent Search, you can configure the connector from the Main Control Panel -> Directory Namespace Tab. Navigate below the Cache node and select the persistent cache branch configured for auto-refresh. On the right side, select the Refresh Settings tab. Select the connector you want to configure and choose Configure. Choose either the LDAP option (for Changelog) or Persistent Search and click OK.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 452px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.454545454545457%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAd2CQH//xAAWEAEBAQAAAAAAAAAAAAAAAAAAATH/2gAIAQEAAQUCXI//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAVEAEBAAAAAAAAAAAAAAAAAAAAIf/aAAgBAQAGPwJFf//EABoQAAICAwAAAAAAAAAAAAAAAAABESExUWH/2gAIAQEAAT8hrQ76DuMJP//aAAwDAQACAAMAAAAQD/8A/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAEx/9oACAEDAQE/ELiP/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAEx/9oACAECAQE/EJqv/8QAGRABAAIDAAAAAAAAAAAAAAAAAQAhETFR/9oACAEBAAE/EBMKdQ2ZKmnron//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/8e941729f4e14a53060b02ada9a0fe0b/56a76/Image2.16.jpg\"\n        srcset=\"/static/8e941729f4e14a53060b02ada9a0fe0b/c1cfe/Image2.16.jpg 275w,\n/static/8e941729f4e14a53060b02ada9a0fe0b/56a76/Image2.16.jpg 452w\"\n        sizes=\"(max-width: 452px) 100vw, 452px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.16: LDAP Directory Connector Types</p>\n<p><strong>Changelog</strong> - the connector leverages a changelog that has been enabled on the backend directory. The connector picks up changes from the cn=changelog naming context based on a polling interval. The changelog must be enabled in the backend directory. Please check with your directory vendor for instructions on how to enable the changelog.</p>\n<p><strong>Persistent Search</strong> - Any LDAP directory that offers a persistent search mechanism can use the Persistent Search connector type. Novell eDirectory is an example of an LDAP source that supports persistent search. Others include Red Hat Directory, IBM TDS, RadiantOne Universal Directory and CA Directory. The connector issues a persistent search and gets notified by the directory server when information changes. If the connector is shut down (either deliberately or due to failure), the delete operations that occurred in the directory are lost. Once the connector is back online there is no way to detect the delete operations that occurred while it was down. The only exception to this is for IBM TDS directories. It stores deleted entries and the capture connector is able to read them, and based on timestamp, determine if the change occurred while the connector was offline.</p>\n<h6 id=\"active-directory\">Active Directory</h6>\n<p>There are three change detection mechanisms: USNChanged, DirSync and Hybrid. If you are virtualizing and detecting changes from a Global Catalog, then you must use the USNChanged changed connector because the DirSync and Hybrid connectors cannot detect change events on sub-domains.</p>\n<p>The flowchart below helps to decide which change detection mechanism to use.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 97.45454545454545%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAEDAgX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAH3kpUGWgdA/8QAGBAAAgMAAAAAAAAAAAAAAAAAEEEAARH/2gAIAQEAAQUCLeR0P//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEABj8CH//EABoQAAIDAQEAAAAAAAAAAAAAAAERABAxIVH/2gAIAQEAAT8hG7Bu0E3IE3InlACr/9oADAMBAAIAAwAAABBjwDz/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAeEAEAAgEEAwAAAAAAAAAAAAABABFRECExYUFxkf/aAAgBAQABPxAF93q5Qe9cXxLMkwjvMFgr3mA8D5AHh5iNxp//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/82f2c944189d20d46ac87dd9975e81c4/b966c/Image2.17.jpg\"\n        srcset=\"/static/82f2c944189d20d46ac87dd9975e81c4/c1cfe/Image2.17.jpg 275w,\n/static/82f2c944189d20d46ac87dd9975e81c4/67061/Image2.17.jpg 550w,\n/static/82f2c944189d20d46ac87dd9975e81c4/b966c/Image2.17.jpg 624w\"\n        sizes=\"(max-width: 624px) 100vw, 624px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.17: Selecting a Active Directory Change Detection Mechanism</p>\n<p><strong>The Active Directory DirSync</strong> capture connector retrieves changes that occur to entries by passing a cookie that identifies the directory state at the time of the previous DirSync search. The first time the DirSync capture connector is started, it stores a cookie in a cursor file. At the next polling interval, the connector performs a DirSync search to detect changes by sending the current cookie. To use the DirSync control, the Bind DN connecting to the directory must have the DS-Replication-Get-Changes extended right, which can be enabled with the “Replicating Directory Changes” permission, on the root of the partition being monitored. By default, this right is assigned to the Administrator and LocalSystem accounts on domain controllers.</p>\n<blockquote>\n<p>[!warning]\r\nTo detect delete events, the service account used by RadiantOne to connect to the backend Active Directory (configured in the connection string of the RadiantOne data source) must have permissions to search the tombstone objects. Usually, a member of the Administrators group is sufficient. However, some Active Directory servers may require a member of the Domain Admins group. Check with your Active Directory administrator to determine the appropriate credentials required.</p>\n</blockquote>\n<blockquote>\n<p>[!warning]\r\nIf you are virtualizing and detecting changes from a Global Catalog, then you must use the Active Directory USNChanged changed connector because the DirSync connector cannot detect change events on sub-domains.</p>\n</blockquote>\n<p>The Active Directory USNChanged capture connector keeps track of changes based on the uSNChanged attribute for the entry. Based on a configured polling interval, the connector connects with the user and password configured in the connection string/data source and checks the list of changes stored by Active Directory. The connector internally maintains the last processed change number (uSNChanged value) and this allows for the recovery of all changes that occur even if the connector is down (deliberately or due to failure).</p>\n<p>If capturing the sequence of events is critical, use the DirSync connector instead of USNChanged because it processes events in the order in which they occur instead of prioritizing and processing inserts and updates before deletes.</p>\n<p>By default, the connector is set to DirSync. To change, select the connector in the table and click Configure. Then select the desired change detection method from the drop-down list.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 602px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.090909090909086%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAEDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHbkKQn/8QAFxAAAwEAAAAAAAAAAAAAAAAAAAECEv/aAAgBAQABBQKXLGbP/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8BZ//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAQEBAAAAAAAAAAAAAAAAACEAEP/aAAgBAQAGPwIjP//EABgQAAMBAQAAAAAAAAAAAAAAAAABETFR/9oACAEBAAE/IavDhjomtNqpzD//2gAMAwEAAgADAAAAEHff/8QAFhEBAQEAAAAAAAAAAAAAAAAAEQAB/9oACAEDAQE/EMGk3//EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAgEBPxCNf//EABkQAQEBAQEBAAAAAAAAAAAAAAERACFBYf/aAAgBAQABPxAV9CKnu7ZB9Gg+VI9//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/b1f3b2b66f3a47a6f73f8e88be8713ea/39e41/Image2.18.jpg\"\n        srcset=\"/static/b1f3b2b66f3a47a6f73f8e88be8713ea/c1cfe/Image2.18.jpg 275w,\n/static/b1f3b2b66f3a47a6f73f8e88be8713ea/67061/Image2.18.jpg 550w,\n/static/b1f3b2b66f3a47a6f73f8e88be8713ea/39e41/Image2.18.jpg 602w\"\n        sizes=\"(max-width: 602px) 100vw, 602px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.18: Active Directory Connector Type Configuration</p>\n<p>The Active Directory hybrid capture connector uses a combination of the uSNChanged and DirSync change detection mechanisms. The first time the connector starts, it gets a new cookie and the highest uSNchanged number. When the connector gets a new change (modify or delete), it makes an additional search using the DN of the entry and fetches the entry from AD. The fetched entry contains the uSNChanged attribute, so the connector updates the cursor values for both for the cookie and the last processed uSNchanged number.</p>\n<blockquote>\n<p>[!warning]\r\nIf you are virtualizing and detecting changes from a Global Catalog, then you must use the Active Directory USNChanged changed connector because the Hybrid connector cannot detect change events on sub-domains.</p>\n</blockquote>\n<p>When the connector restarts, uSNChanged detection catches the entries that have been modified or deleted while the connector was stopped. The LDAP search uses the last processed uSNChanged number to catch up. After the connector processes all entries, it requests a new cookie from Active Directory (not from the cursor) and switches to DirSync change detection.</p>\n<p><strong>RadiantOne Universal Directory Stores</strong></p>\n<p>If you are using a persistent cache on a proxy view of a local RadiantOne Universal Directory store, or a nested persistent cache view (a cached view used in another cached view), the connector type is noted as HDAP (trigger) automatically and cannot be changed. This is a special trigger mechanism that publishes changes directly into the queue to invoke the persistent cache refresh.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.09090909090909%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3KEB/8QAFhAAAwAAAAAAAAAAAAAAAAAAABAR/9oACAEBAAEFAlT/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAXEAADAQAAAAAAAAAAAAAAAAAAARAx/9oACAEBAAE/IRZH/9oADAMBAAIAAwAAABDzz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABkQAQADAQEAAAAAAAAAAAAAAAEAEZExcf/aAAgBAQABPxBKLO+xaihSjJ//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/b99ed9e6bee864412afbd46312928c11/b966c/Image2.19.jpg\"\n        srcset=\"/static/b99ed9e6bee864412afbd46312928c11/c1cfe/Image2.19.jpg 275w,\n/static/b99ed9e6bee864412afbd46312928c11/67061/Image2.19.jpg 550w,\n/static/b99ed9e6bee864412afbd46312928c11/b966c/Image2.19.jpg 624w\"\n        sizes=\"(max-width: 624px) 100vw, 624px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.19: HDAP Trigger Connector Type</p>\n<p><a href=\"#connector-properties\">Connector properties</a> can be edited from the Main Control Panel > PCache Monitoring tab. Click the icon representing the source in the topology to display the configuration section and view/edit properties.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.454545454545446%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3aEB/8QAFhAAAwAAAAAAAAAAAAAAAAAAEBEh/9oACAEBAAEFAgp//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAGBAAAwEBAAAAAAAAAAAAAAAAAAERIVH/2gAIAQEAAT8hnENYKEp//9oADAMBAAIAAwAAABCAD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQEBAAMBAAAAAAAAAAAAAAERACExUXH/2gAIAQEAAT8QCBF+4agX2aYAocqd7//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/57ef648882ee22c6f912a89ef312988a/b966c/Image2.20.jpg\"\n        srcset=\"/static/57ef648882ee22c6f912a89ef312988a/c1cfe/Image2.20.jpg 275w,\n/static/57ef648882ee22c6f912a89ef312988a/67061/Image2.20.jpg 550w,\n/static/57ef648882ee22c6f912a89ef312988a/b966c/Image2.20.jpg 624w\"\n        sizes=\"(max-width: 624px) 100vw, 624px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.19: Connector Properties</p>\n<p><strong>Directory Connector Failover</strong></p>\n<p>This section describes the failover mechanism for the LDAP, Persistent Search and Active Directory connectors.</p>\n<blockquote>\n<p>[!warning]\r\nThe backend servers must be configured for multi-master replication. Please check the vendor documentation for assistance with configuring replication for your backends.</p>\n</blockquote>\n<p>The directory connectors leverage the failover servers that have been configured for the data source. When you configure a data source for your backend directory, you need to indicate the list of failover servers in order of priority. When the connector fails over, it uses the failover servers in the order they are listed. See the screen shot below for how to indicate a failover server for the Data Sources from the Main Control Panel.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.72727272727273%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHtspKSP//EABgQAAMBAQAAAAAAAAAAAAAAABARIQAB/9oACAEBAAEFAo5lwIf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAIEH/2gAIAQEABj8CIv8A/8QAGhAAAgMBAQAAAAAAAAAAAAAAAREAMWEQQf/aAAgBAQABPyHwKq4H1kwEQJDiCgOf/9oADAMBAAIAAwAAABB8P//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQACAwADAAAAAAAAAAAAAAEAESExUUFx0f/aAAgBAQABPxCzRFBsleuxYQVtIcSz5RoQbDZNoT0IeZ//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/d13fa40e6db6137bb6568ae0c9cf77d7/b966c/Image2.21.jpg\"\n        srcset=\"/static/d13fa40e6db6137bb6568ae0c9cf77d7/c1cfe/Image2.21.jpg 275w,\n/static/d13fa40e6db6137bb6568ae0c9cf77d7/67061/Image2.21.jpg 550w,\n/static/d13fa40e6db6137bb6568ae0c9cf77d7/b966c/Image2.21.jpg 624w\"\n        sizes=\"(max-width: 624px) 100vw, 624px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.21: Configuring Failover Servers for the Backend Directory</p>\n<p>If a connection cannot be made to the primary server and the maximum number of retry attempts has been exhausted, the connector connects to the failover servers in the order they are listed. There is no automatic failback, meaning once the primary server is back online, the connector doesn’t automatically go back to it.</p>\n<p>This failover mechanism is supported for Active Directory, OpenDJ, Oracle Directory Server Enterprise Edition (Sun Directory v7), Oracle Unified Directory (OUD). In addition, any LDAP directory implementing cn=changelog and replicationCSN attribute or the persistent search control is also supported.</p>\n<blockquote>\n<p>[!warning]\r\nWhen the Active Directory DirSync connector fails over to another DC replica, the current cursor (cookie) is used. The connector may receive all objects and attributes from the replica instead of just the delta from its last request. Therefore, you may notice the number of entries published by the connector is more than you were expecting. This behavior is dictated by the Active Directory server and is out of the control of the connector. Keep this in mind when you define the Max Retries and Retry Intervals for the connector properties. The smaller the numbers of retries, the higher the chance the connector will fail over and possibly receive all objects and attributes (a full sync) from the domain controller.</p>\n</blockquote>\n<p>For the Active Directory USNChanged connector, the failover logic leverages the Active Directory replication vectors [replUpToDateVector], and the failover servers configured at the level of the RadiantOne data source associated with Active Directory, to determine which server(s) the connector switches to in case of failure. Since the replication vector contains all domains, in addition to some possibly retired domains, the connector narrows down the list of possible failover candidates to only the ones listed as failover servers in the RadiantOne data source associated with the Active Directory backend. If there are no failover server defined for the data source, all domains in the replication vector are possible candidates for failover.</p>\n<blockquote>\n<p>[!warning]\r\nWhen defining the RadiantOne data source associated with Active Directory, do not use Host Discovery or Load Balancers. You must use the fully qualified machine names for the primary server and failover servers. Do not use IP addresses. Also, it is highly recommended that you list your desired failover servers at the level of the data source. Not only does this make the failover logic more efficient, but it also avoids delays in synchronization.</p>\n</blockquote>\n<p>[replUpToDateVector] definition: The non-replicated attribute replUpToDateVector is an optional attribute on the naming context root of every naming context replica. If this vector is unavailable, the connector is suspended.</p>\n<p>The ReplUpToDateVector type is a tuple with the following fields:</p>\n<ul>\n<li>\n<p>uuidDsa: The invocation ID of the DC that assigned usnHighPropUpdate.</p>\n</li>\n<li>\n<p>usnHighPropUpdate: A USN at which an update was applied on the DC identified by uuidDsa.</p>\n</li>\n<li>\n<p>timeLastSyncSuccess: The time at which the last successful replication occurred from the DC identified by uuidDsa; for replication latency reporting only.</p>\n</li>\n</ul>\n<p>[replUpToDateVector] example:</p>\n<p>01ca6e90-7d20-4f9c-ba7b-823a72fc459e @ USN 2210490 @ Time 2005-08-21 15:54:21</p>\n<p>1d9bb4b6-054a-440c-aedf-7a3f28837e7f @ USN 26245013 @ Time 2007-02-27 10:17:33</p>\n<p>24980c9d-39fa-44d7-a153-c0c5c27f0577 @ USN 4606302 @ Time 2006-08-20 23:33:09</p>\n<p>At run-time, the connector retrieves the entire list of servers defined in the replication vector and reduces the number of possible failover candidates based on failover servers defined in the RadiantOne data source. The list of potential failover servers is stored at each polling interval. When the current server fails, the connector decides to switch to the closest candidate by selecting the server with the maximum timestamp from the up-to-dateness vector. The capture connector’s cursor will be assigned the value from the up-to-dateness vector for the failover server. If the closest candidate fails as well, the connector tries with a second closest candidate and so on.</p>\n<blockquote>\n<p>[!warning]\r\nDue to the lack of Active Directory replication for the USNChanged attribute, some changes could be missed or replayed on failover.</p>\n</blockquote>\n<p>For the AD Hybrid connector, the failover process starts when the number of exceptions exceeds either the Maximum Retries on Error or Maximum Retries on Connection Error value. The failover servers are specified in the data source associated with Active Directory. The Active Directory up-to-date vector is used to determine the failover server and the value of the new cursor. If the up-to-date vector is unavailable from the current server, failover is not possible. If this happens, verify that AD replication is correctly configured. After the failover server is found, uSNChanged detection catches the entries that have been modified or deleted since the connector’s failure. The LDAP search uses the last processed uSNChanged number to catch up.</p>\n<blockquote>\n<p>[!warning]\r\nDue to the lack of Active Directory replication for the USNChanged attribute, some changes could be missed or replayed on failover.</p>\n</blockquote>\n<p>After the connector processes all entries, it requests a new cookie from Active Directory and switches to DirSync change detection.</p>\n<h6 id=\"custom-connectors\">Custom Connectors</h6>\n<p>The following custom data sources support Real-time persistent cache refresh. For all other custom data sources, use a <a href=\"#periodic-refresh\">periodic cache refresh</a>.</p>\n<ul>\n<li>\n<p>Any source that supports SCIM v1 or v2 (e.g. scimclient and scimclient2 custom data sources)</p>\n</li>\n<li>\n<p>Azure Active Directory (e.g. default mgraph custom data source)</p>\n</li>\n<li>\n<p>Okta Universal Directory (e.g. default oktaclient custom data source)</p>\n</li>\n</ul>\n<p>The custom connectors are configured and started automatically. Go to Main Control Panel > PCache Monitoring tab to configure <a href=\"#connector-properties\">connector properties</a> and manage and monitor the persistent cache refresh process. Click the icon representing the custom data source in the topology to display the configuration section and view/edit properties.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.81818181818182%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3QUH/8QAFxAAAwEAAAAAAAAAAAAAAAAAABARIf/aAAgBAQABBQLFD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABgQAQADAQAAAAAAAAAAAAAAAAEAEVFB/9oACAEBAAE/IaHIhhKZP//aAAwDAQACAAMAAAAQ8A//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAbEAACAgMBAAAAAAAAAAAAAAAAAREhMWGR0f/aAAgBAQABPxBVIaoT8BQ4cR//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/564496d30ff9e719963ec59d8ccd3ae4/b966c/Image2.22.jpg\"\n        srcset=\"/static/564496d30ff9e719963ec59d8ccd3ae4/c1cfe/Image2.22.jpg 275w,\n/static/564496d30ff9e719963ec59d8ccd3ae4/67061/Image2.22.jpg 550w,\n/static/564496d30ff9e719963ec59d8ccd3ae4/b966c/Image2.22.jpg 624w\"\n        sizes=\"(max-width: 624px) 100vw, 624px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.22: Custom Connector Properties</p>\n<p>Custom connectors don’t have built-in failover logic. The web service target must handle failover and this is typically achieved with a web server/HTTP load balancer.</p>\n<h6 id=\"connector-properties\">Connector Properties</h6>\n<p>The following properties are for real-time persistent cache refresh connectors. Not all properties are applicable for every type of backend. The description indicates the type of backend the property is used for.</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Polling Interval</td>\n<td>This property indicates the amount of time (in milliseconds) the connector should wait before querying the source to check for changes. <br> This property is applicable to all connectors except HDAP triggers. The default value is 10,000 ms (10 seconds).</td>\n</tr>\n<tr>\n<td>Size Limit</td>\n<td>This property indicates the number of entries the connector collects from the source in a single request. However, even if the connector picks up multiple entries, they are processed and published to the queue one at a time. <br> This property is applicable to all connectors except HDAP triggers. The default value is 1000.</td>\n</tr>\n<tr>\n<td>Log Level</td>\n<td>Log Level – OFF: Used to turn logging off. <br> Log level – FATAL: Severe errors that cause premature termination. <br> Log level – ERROR: Other runtime errors or unexpected conditions. <br> Log level – WARN: Use of deprecated APIs, poor use of API. <br> Log level – INFO: Interesting runtime events. <br> Log level – DEBUG: Detailed information on the flow through the system. <br> Log level – TRACE: Most detailed information. <br> Log location: <br> <code class=\"language-text\">&lt;RLI_HOME>\\logs\\sync_agent\\&lt;naming_context>__&lt;baseDN>__&lt;data_source>\\connector.log</code> <br> This property is applicable to all connectors except HDAP triggers. The default value is INFO.</td>\n</tr>\n<tr>\n<td>Max Retries On Error</td>\n<td>If the connector is unable to connect to the source to pick up changes for any reason other than a connection error, it tries to reconnect. Maximum Retries on Error is the total number of times the connector tries reconnecting. The frequency of the reconnect attempt is based on the Retry Interval on Error property. After all attempts have been tried, the connector failover logic is triggered. If there are no backends available to connect to, the agent automatically redeploys the connector until a connection to the backend can be made.<br> This property is applicable to all connectors except HDAP triggers. The default value is 5.</td>\n</tr>\n<tr>\n<td>Retry Interval on Error</td>\n<td>Used in conjunction with the Max Retries on Error property. This is the amount of time (in milliseconds) the connector waits before it attempts to pick up changes from the source after an error has occurred.<br> This property is applicable to all connectors except HDAP triggers. The default value is 10,000 ms (10 seconds).</td>\n</tr>\n<tr>\n<td>Max Retries on Connection Error</td>\n<td>For Database Connectors - If the connector is unable to connect to the primary backend server, it tries to connect to the failover server. If the connector cannot connect to the primary or failover servers because of a connection error, it tries to connect again later. Maximum Retries on Connection Error is the total number of times the connector tries reconnecting. A failed attempt to connect to both the primary and failover server is considered a single retry. The frequency of the reconnect attempt is based on the Retry Interval on Connection Error property. If there are no backends available to connect to, the agent automatically redeploys the connector until a connection to the backend can be made.<br>For Directory Connectors - If the connector is unable to connect to the primary backend server because of a connection error, it tries to connect again later. Maximum Retries on Connection Error is the total number of times the connector tries reconnecting. The frequency of the reconnect attempt is based on the Retry Interval on Connection Error property. After all attempts have been tried, the connector failover logic is triggered. If there are no backends available to connect to, the agent automatically redeploys the connector until a connection to the backend can be made.<br> This property is applicable to all connectors except HDAP triggers. The default value is 5.</td>\n</tr>\n<tr>\n<td>Retry Interval on Connection Error</td>\n<td>Used in conjunction with the Max Retries on Connection Error property. This is the amount of time (in milliseconds) the connector waits before trying to establish a connection to the source if there was a connection problem during the previous attempt. <br> This property is applicable to all connectors except HDAP triggers. The default value is 10,000 ms (10 seconds).</td>\n</tr>\n<tr>\n<td>LDAP Filter</td>\n<td>To further condition the entries that are published, you can indicate the desired criteria in the LDAP Filter property. This is a post filter, used to qualify which entries are published by the connector. You must enter a valid LDAP filter in the property.<br> This property can be used to avoid publishing unwanted information.<br> If a captured entry matches the criteria indicated in the LDAP filter property, it is published by the connector. If it doesn’t, the entry is not published. Information about the skipped entries is in the connector log (with log level set to DEBUG). <br> If the captured change type is delete, and not enough information is known about the entry, the LDAP filter is not used and the entry is published by the connector. For example, if the LDAP filter property contained a value of (l=Novato) and the captured entry did not contain an “l” attribute, the LDAP filter is not applied and the entry is published. <br> If the captured change type is not delete (e.g. insert, update, move…etc.), and not enough information is known about the entry, the LDAP filter is still used and the entry is not published. For example, if the LDAP filter property contained a value of (l=Novato) and the captured entry did not contain an “l” attribute, the LDAP filter is still applied and the entry is not published by the connector.<br> This property is only applicable to Active Directory, LDAP and Persistent Search connectors. The default value is blank (no specific filter).<br> This property also plays a role in recovering changes that happen while a connector is stopped. The LDAP filter is added to the (internal) default filter used to further condition the entries to capture. For example, if the \"LDAP Filter\" property = <br> (|(objectclass=myProvider)(objectclass=myPerson)(objectclass=mySubscriber)), then, the following LDAP filter is used by the connector to capture changes that were missed while the connector was stopped:<br>(&#x26;(|(modifyTimestamp>=20211014212817.215Z)(createTimestamp>=20211014212817.215Z))(|(objectclass=myProvider)(objectclass=myPerson)(objectclass=mySubscriber))) <br> Note - If a change is made to this property while the connector is running, it must be restarted for the new value to take effect.</td>\n</tr>\n<tr>\n<td>Excluded Branches</td>\n<td>To further condition the entries that are published, you can indicate branch(es) to exclude. In the Excluded Branches property, enter one or more suffixes associated with entries that should not be published in the message by the connector. Click “Enter” to accept the value and to be able to enter another suffix. You can use the “x” next to the suffix to remove it.<br> <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 371px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 16%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAADABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB34hQH//EABYQAAMAAAAAAAAAAAAAAAAAAAABEP/aAAgBAQABBQKI/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAFhABAQEAAAAAAAAAAAAAAAAAABEx/9oACAEBAAE/IYjD/9oADAMBAAIAAwAAABAAD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAAICAwAAAAAAAAAAAAAAAAABESExYZH/2gAIAQEAAT8QaW4shvrMZ//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/c8e10133112a457d6f32186f8a15bc18/bfbf0/excluded-branches.jpg\"\n        srcset=\"/static/c8e10133112a457d6f32186f8a15bc18/c1cfe/excluded-branches.jpg 275w,\n/static/c8e10133112a457d6f32186f8a15bc18/bfbf0/excluded-branches.jpg 371w\"\n        sizes=\"(max-width: 371px) 100vw, 371px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span> <br> If the changed entry DN contains a suffix that matches the excluded branches value, or is a change in the exact entry that is listed (e.g. CN=CFS users,DC=seradiant,DC=dom), this entry is not published by the connector. Otherwise, the entry is published. This can avoid publishing unwanted information.<br>Note – If both included and excluded branches are used, an entry must satisfy the conditions defined in both settings to be included in the message. The included branches condition(s) is checked first. <br> If you set this value using the vdsconfig command line utility on Windows, separate the branches with a comma. E.g. C:\\radiantone\\vds\\bin>vdsconfig.bat set-connector-property -connectorname o_sead_pcache_proxy__dc_seradiant_dc_dom__seradiantad -propertyid excludedBranches <br> -propertyvalue “[\"cn=users,dc=seradiant,dc=dom\",\"cn=domain groups,dc=seradiant,dc=dom\"]” <br> This property is only applicable to Active Directory, LDAP and Persistent Search connectors. The default value is blank (no excluded branches). <br> If a change is made to this property while the connector is running, the new value is taken into account once the connector re-initializes (happens automatically every 20 seconds).</td>\n</tr>\n<tr>\n<td>Included Branches</td>\n<td>To further condition the entries that are published, you can indicate branch(es) to include. In the Included Branches property, enter one or more suffixes associated with entries that should be published by the connector. Click “Enter” to accept the value and to be able to enter another suffix. You can use the “x” next to the suffix to remove it. <br> <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 358px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 15.636363636363637%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAADABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB34BUH//EABYQAAMAAAAAAAAAAAAAAAAAAAABEP/aAAgBAQABBQKI/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAFhABAQEAAAAAAAAAAAAAAAAAABEx/9oACAEBAAE/IYjD/9oADAMBAAIAAwAAABBzz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABkQAQADAQEAAAAAAAAAAAAAAAEAESFhkf/aAAgBAQABPxBALWynfZkz/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/1573e71ec5e506571d0e06f65e41b724/af061/included-branches.jpg\"\n        srcset=\"/static/1573e71ec5e506571d0e06f65e41b724/c1cfe/included-branches.jpg 275w,\n/static/1573e71ec5e506571d0e06f65e41b724/af061/included-branches.jpg 358w\"\n        sizes=\"(max-width: 358px) 100vw, 358px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span> <br> If the changed entry DN contains a suffix that matches the included branches value, or is a change in the exact entry that is listed (e.g. CN=All Users,DC=seradiant,DC=com), this entry is published by the connector. Otherwise, the entry is not published. This can avoid publishing unwanted information. <br> Note - if both included and excluded branches are used, an entry must satisfy the conditions defined in both settings to be included in the message. The included branches condition(s) is checked first. <br> If you set this value using the vdsconfig command line utility on Windows, separate the branches with a comma. E.g. C:\\radiantone\\vds\\bin>vdsconfig.bat set-connector-property -connectorname o_sead_pcache_proxy__dc_seradiant_dc_dom__seradiantad -propertyid includedBranches -propertyvalue “[\"cn=users,dc=seradiant,dc=dom\",\"cn=domain groups,dc=seradiant,dc=dom\"]”** <br> This property is only applicable to Active Directory, LDAP and Persistent Search connectors. The default value is blank (no included branches). <br> If a change is made to this property while the connector is running, the new value is taken into account once the connector re-initializes (happens automatically every 20 seconds).</td>\n</tr>\n<tr>\n<td>SQL Filter</td>\n<td>SQL filter is a post filter used to evaluate entries captured by the connector. Only changes that match the filter are published by the connector. <br>A SQL filter is either a single expression or several single expressions joined by binary operators and brackets ( ). Possible binary operators are: <br>-\tAND <br> - OR <br> -NOT <br> Some examples of valid SQL Filters are: <br>- ID='5' <br> - ID='5' AND NAME='ALLEN' <br> -\tID='5' AND NAME='ALLEN' OR CITY='SAN FRANCISCO' <br> -\tID='5' AND (NAME='ALLEN' OR CITY='SAN FRANCISCO') <br> - NAME LIKE 'AL%' <br> -\tNAME LIKE 'ALLE_' <br> If the SQL Filter syntax entered into the property is not correct, an error is logged by the connector and it continues working without applying the SQL Filter (all changes are published). <br> This property is only applicable for the DB Changelog, DB Counter, and DB Timestamp connectors. The default value is blank (no specific filter).</td>\n</tr>\n<tr>\n<td>Force Sequential Counters (true/false)</td>\n<td>This property accepts a value of true or false and dictates how the connector treats entries it picks up from the LOG table that have non-sequential change IDs. The default is true meaning that if the connector detects a non-sequential change ID for an entry in the LOG table, it behaves as if there is an error (non-connection error) and the retry logic based on the Max Retries on Error and Retry Interval on Error properties takes effect. Sometimes rows in the log table are not written in the order of the change ID, and if the connector doesn’t wait for the entries to have sequential IDs, some changes could be missed. The connector waits for the length of time specified in the Retry Interval on Error property and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the Max Retries on Error property) is exhausted, if it still detects non-sequential change IDs, the connector stops. Set “Force Sequential Counters” to false before restarting the connector to have the connector ignore non-sequential change IDs. <br> If the connector should ignore non-sequential change IDs, and process all changes immediately, set the property to false.<br> This property is only applicable to the DB Changelog and DB Counter connectors. The default value is true.</td>\n</tr>\n<tr>\n<td>Processing Delay</td>\n<td>This property can be used if there is a need for a delay in the processing of changes by the connector. For example, if there are two or more processes that update the source table at the same time, and they take about 2 minutes each to run, the processing delay can be set at anywhere between 4-6 minutes. This delays the processing and makes sure the connector captures all changes coming from both processes. <br> The property value is in seconds, and the default value is 0. If the value is set to &#x3C;=0, it means that the property is ignored by the connector. If the value is set to be more than 0, then only the entries between last_cursor and current_time – processing_delay are processed by the connector. If an invalid, non-numeric value is set for this property, the connector stops. <br> This property is only applicable to the DB Timestamp connector.</td>\n</tr>\n<tr>\n<td>Skip catch-up process (true/false)</td>\n<td>If this option is set to false, when the connector starts, it tries to pick up all changes that happened since the last time it successfully processed any changes (this information is maintained in the connector’s cursor file). This is based on changenumber. If this option is set to true, the connector sends out only the changes that happen after it has started. All changes that happened while the connector was stopped are ignored. <br> The property is applicable to the Persistent Search connector only. The default value is false.</td>\n</tr>\n<tr>\n<td>Switch to Primary Server (in Polling Intervals)</td>\n<td>This option, working in conjunction with the Polling Interval property, allows you to configure how often, if at all, the connector attempts to switch back to the primary server after failover. To configure the connector to attempt to switch to the primary server, set Switch to Primary Server to a value of 4 or greater. You can set the value to less than 4, but attempting to connect back to the primary server can be time consuming and therefore not recommended to do frequently. For example, if this value is set to 1, the connector makes an attempt every polling interval. If the Switch to Primary Server value is 3, the connector makes an attempt every third polling interval. <br> To disable attempts to reconnect to the primary server, set this value to zero. This is the default value. <br> Changes made to this property’s value while the connector is running are immediately taken into account. When the connector starts or restarts and the property value is 1 or higher, the connector attempts to switch to the primary server immediately. <br> This property is applicable to the LDAP changelog connectors only.</td>\n</tr>\n<tr>\n<td>Failover Algorithm [1-4]</td>\n<td>This option is relevant for the LDAP changelog connector type.<br> When a failover happens, the changelog capture connector attempts to find a new cursor. Since this process is inexact, and changenumber sequence can vary across some replica servers, some events may be replayed or lost. The changelog connector maintains a cursor that indicates information related to the last change processed by the connector along with information about possible replica servers in case failover is needed. During failover, the connector searches the changelog of the replica servers and determines minimum and maximum changenumbers across them. Assume that the last processed changenumber stored by the connector is 100 and there are 2 replica servers defined for the backend. During failover, the connector determines the current changenumbers for each of the replicas by searching their changelogs. Assume that replica 1 has changenumber 99 and replica 2 has changenumber 97. When the connector needs to failover, it must decide whether to start processing changes using changenumber 100 (its current last processed change), 97 (changenumber from replica 2), or 99 (changenumber from replica 1). <br> The Failover Algorithm property allows you to determine how the cursor value gets set during failover, and ultimately determine the quantity of events that are replayed. The property supports values between 1 and 4. The meaning of each is outlined in the table below. <br> <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 436px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.18181818181818%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAv/EABYBAQEBAAAAAAAAAAAAAAAAAAECA//aAAwDAQACEAMQAAABsfmjWVDgf//EABsQAAICAwEAAAAAAAAAAAAAAAECABEDEBIj/9oACAEBAAEFAkA4pZSzGPOtf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQIBAT8Bb0p//8QAGBAAAwEBAAAAAAAAAAAAAAAAAAJBcRD/2gAIAQEABj8CXCEFzv8A/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAER8FGR/9oACAEBAAE/IXbSwYI2R5Ygi4f/2gAMAwEAAgADAAAAELQP/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAwEBPxBLCH//xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQIBAT8Q2tb/xAAbEAEAAgIDAAAAAAAAAAAAAAABABFRcSFB4f/aAAgBAQABPxB8aVi61E2l4ZgciSlvlO2oYk//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/3e10e17ce37bc8fc5033ea3b73da75f1/4c32f/failover-algorithm.jpg\"\n        srcset=\"/static/3e10e17ce37bc8fc5033ea3b73da75f1/c1cfe/failover-algorithm.jpg 275w,\n/static/3e10e17ce37bc8fc5033ea3b73da75f1/4c32f/failover-algorithm.jpg 436w\"\n        sizes=\"(max-width: 436px) 100vw, 436px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"resetting-connector-cursor--detect-new-only\">Resetting Connector Cursor – Detect New Only</h6>\n<p>Capture connectors use a cursor to maintain information about the last processed changes. This allows the connectors to capture only changes that have happened since the last time they checked for changes. When the real-time persistent cache refresh connectors start, they automatically attempt to capture all changes that have happened since the last time they checked. If the real-time persistent cache refresh process has been stopped for an extended period of time, you might not want them to attempt to capture all changes since the last time they checked. In this case, you can reset the cursor for the connector. From the Main Control Panel > PCache Monitoring tab, select the real-time refresh topology and the topology displays. Click the icon representing the capture connector and the Runtime details are displayed on the right. Click <strong>Reset Cursor</strong> to clear the cursor value and trigger the connector to behave as if it is the first time connecting to the source to collect changes.</p>\n<h4 id=\"persistent-cache-properties\">Persistent Cache Properties</h4>\n<p>Once a persistent cache is configured, properties can be managed from the Main Control Panel > Directory Namespace tab > Cache node. Select the configured persistent cache branch and the properties are available on the right.</p>\n<h5 id=\"non-indexed-attributes\">Non-indexed Attributes</h5>\n<p>If the Indexed Attributes list is empty, all attributes are indexed by default (except binary ones). Also, the following “internal” ones won’t be indexed either: \"creatorsName\", \"createTimestamp\", \"modifiersName\", \"modifyTimestamp\", \"cacheCreatorsName\", \"cacheCreateTimestamp\", \"cacheModifiersName\", \"cacheModifyTimestamp\", \"uuid\", \"vdsSyncState\", \"vdsSyncHist\", \"ds-sync-generation-id\", \"ds-sync-state\", \"ds-sync-hist\", \"vdsSyncCursor\", \"entryUUID\", \"userpassword”. Any additional attributes that you do not want indexed should be added to the Non Indexed Attributes list on the Properties tab for the selected persistent cache branch.</p>\n<p>If you change the non-indexed attributes, you must re-build the index. You can do this from the Properties tab by clicking <strong>Re-build Index</strong>.</p>\n<h5 id=\"sorted-attributes\">Sorted Attributes</h5>\n<p>This is a comma-separated list of attributes to be used in association with Virtual List Views (VLV) or sort control configured for RadiantOne. These sorted indexes are managed internally in the persistent cache and kept optimized for sorting. They are required if you need to sort the search result or to execute a VLV query on the persistent cache branch.</p>\n<p>If you need to support VLV, the VLV/Sort control must be enabled in RadiantOne. For details on this control, please see the RadiantOne System Administration Guide.</p>\n<p>If you change the sorted attributes, you must re-build the index. You can do this from the Properties tab by clicking <strong>Re-build Index</strong>.</p>\n<h5 id=\"encrypted-attributes\">Encrypted Attributes</h5>\n<p>Attribute encryption protects sensitive data while it is stored in RadiantOne. You can specify that certain attributes of an entry are stored in an encrypted format. This prevents data from being readable while stored in persistent cache, backup files, and exported LDIF files. Attribute values are encrypted before they are stored in persistent cache, and decrypted before being returned to the client, as long as the client is authorized to read the attribute (based on ACLs defined in RadiantOne), is connected to the RadiantOne service via SSL, and not a member of the special group containing members not allowed to get these attributes (e.g. cn=ClearAttributesOnly,cn=globalgroups,cn=config). For details on this special group, please see the RadiantOne System Administration Guide.</p>\n<blockquote>\n<p>[!warning]\r\nDefine a security encryption key from the Main Control Panel > Settings Tab > Security section > Attribute Encryption prior to configuring encrypted attributes. For steps on defining key generation, see the RadiantOne System Administration Guide.</p>\n</blockquote>\n<p>On the Properties Tab for the selected persistent cache, enter a comma-separated list of attributes to store encrypted in the Encrypted Attributes property. Attributes listed in the Encrypted Attributes property are added to the Non-indexed attribute list by default. This means these attributes are not searchable by default. Indexing encrypted attributes is generally not advised as the index itself is less secure than the attribute stored in the persistent cache. However, if you must be able to search on the encrypted attribute value, it must be indexed. Only “exact match/equality” index is supported for encrypted attributes. To make an encrypted attribute searchable, remove the attribute from the list of nonindexed attributes and then click <strong>Re-build Index</strong>.</p>\n<h5 id=\"extension-attributes\">Extension Attributes</h5>\n<p>Extension Attributes are new attributes (meaning these attributes don’t exist anywhere yet) that are associated with a cached virtual entry. This is primarily used to accommodate the storage of application-specific attributes that you want to store locally as opposed to the backend(s) you are virtualizing. Extension attributes should be used as an alternative to Extended Joins in scenarios where the virtual view is stored in persistent cache and then needs replicated out to RadiantOne Universal Directory stores in other clusters.</p>\n<p>Extension attributes are stored locally and RadiantOne handles the lifecycle of these attributes accordingly. Once a persistent cache is defined, list the attribute names (comma-separated) in the Extension Attributes property. The attribute names must be unique and not overlap with attributes coming from and being cached from existing backends. The example below has an extension attribute named lastLogin. Applications can write to this attribute and RadiantOne handles the write locally without delegating anything to the backend.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 899px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.36363636363636%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd1yySg//8QAFhABAQEAAAAAAAAAAAAAAAAAERAg/9oACAEBAAEFAoOP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxAAAwEAAAAAAAAAAAAAAAAAECBBkf/aAAgBAQAGPwIXU//EABoQAQACAwEAAAAAAAAAAAAAAAEAERBBYZH/2gAIAQEAAT8h1L5Eq3woErH/2gAMAwEAAgADAAAAEDPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAMBAAMAAAAAAAAAAAAAAQARQSGBofD/2gAIAQEAAT8QG6JuMOqmiAXAHpnLDxKfEqp//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/4bf496f7587ef88b94dd9c8391d54aff/2d452/Image2.23.jpg\"\n        srcset=\"/static/4bf496f7587ef88b94dd9c8391d54aff/c1cfe/Image2.23.jpg 275w,\n/static/4bf496f7587ef88b94dd9c8391d54aff/67061/Image2.23.jpg 550w,\n/static/4bf496f7587ef88b94dd9c8391d54aff/2d452/Image2.23.jpg 899w\"\n        sizes=\"(max-width: 899px) 100vw, 899px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.23: Extension Attributes for Persistent Cache</p>\n<p>For consistency of the RadiantOne LDAP schema, define the extension attributes as part of the schema, generally associated with an auxiliary object class. For details on extending the schema, see the RadiantOne System Administration Guide.</p>\n<p>Extension Attributes are replicated to other clusters in deployment scenarios where inter-cluster replication is enabled and a replica of a persistent cache is maintained as a RadiantOne Universal Directory store in the target cluster(s).</p>\n<p>When using extension attributes for cached virtual views of LDAP directory backends, you must configure invariant attribute(s). See the following section for more details.</p>\n<h5 id=\"invariant-attributes\">Invariant Attributes</h5>\n<p>To guarantee extension attributes are linked to their respective underlying entries and moved properly should modRDN/modDN events occur in the backend source, invariant attribute(s) must be defined. The invariant attribute is the unique identifier in the backend directory. Below are some invariant attributes used in common LDAP directories.</p>\n<ul>\n<li>\n<p>objectGUID (Active Directory)</p>\n</li>\n<li>\n<p>entryUUID (Oracle Unified Directory, OpenDJ, unboundID)</p>\n</li>\n<li>\n<p>nsUniqueID (Sun/ODSEE)</p>\n</li>\n<li>\n<p>ibm-entryUUID (IBM)</p>\n</li>\n<li>\n<p>UUID (RadiantOne Universal Directory)</p>\n</li>\n</ul>\n<p>For the example shown below, the persistent cached view is from an Active Directory backend. RadiantOne manages the lifecycle of the attribute named lastLogin and this attribute is stored directly in the cache. The invariant attribute is set to objectGUID which is the unique identifier for the users in the backend Active Directory. If the entry in the backend is moved, the invariant attribute ensures RadiantOne handles the move of the associated cached extension attributes properly.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 899px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.36363636363636%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd1yySg//8QAFhABAQEAAAAAAAAAAAAAAAAAERAg/9oACAEBAAEFAoOP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxAAAwEAAAAAAAAAAAAAAAAAECBBkf/aAAgBAQAGPwIXU//EABoQAQACAwEAAAAAAAAAAAAAAAEAERBBYZH/2gAIAQEAAT8h1L5Eq3woErH/2gAMAwEAAgADAAAAEBPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAICAwAAAAAAAAAAAAAAAQARIUFhofD/2gAIAQEAAT8QG6JvTDKpogF0A6ZwGWU8Sqn/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/0a8fd86f0d0f6fa43cdb027ed5c7652a/2d452/Image2.24.jpg\"\n        srcset=\"/static/0a8fd86f0d0f6fa43cdb027ed5c7652a/c1cfe/Image2.24.jpg 275w,\n/static/0a8fd86f0d0f6fa43cdb027ed5c7652a/67061/Image2.24.jpg 550w,\n/static/0a8fd86f0d0f6fa43cdb027ed5c7652a/2d452/Image2.24.jpg 899w\"\n        sizes=\"(max-width: 899px) 100vw, 899px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.24: Invariant Attribute for Persistent Cache</p>\n<h5 id=\"inter-cluster-replication\">Inter-cluster Replication</h5>\n<p>This option should be enabled if you want to support replication between this persistent cache branch and a RadiantOne Universal Directory store in a different cluster.</p>\n<p>If inter-cluster replication is enabled, a replication journal is used to store changes that happen on the persistent cache branch. The replication journal is associated with the default LDAP data source defined as replicationjournal and root naming context named cn=replicationjournal. The RadiantOne leader node in the cluster associated with the persistent cache, publishes changes into the replication journal. The RadiantOne leader nodes in all other clusters (that are configured for inter-cluster replication) pick up changes from the replication journal to update their local replica. Persistent caches usually only publish changes into the replication journal (for other RadiantOne Universal Directory replicas in other clusters). There are some cases where persistent cache can accept changes from other clusters.</p>\n<blockquote>\n<p>[!warning]\r\nChanges that haven’t been picked up from the replicationjournal for 3 days are automatically purged.</p>\n</blockquote>\n<h5 id=\"accept-changes-from-replicas\">Accept Changes from Replicas</h5>\n<p>For limited use cases where the only type of modify operations that client applications perform is updates to existing entries (no adds or deletes), the persistent cache can subscribe to these events. If the persistent cache should process attribute updates from RadiantOne Universal Directory replicas in other clusters, enable the Accept Changes from Replicas option and list the acceptable attributes in the Updateable Attributes from Replicas property.</p>\n<blockquote>\n<p>[!warning]\r\nPersistent Cache stores can only accept modification operations from RadiantOne Universal Directory replicas. Add and delete operations are currently not supported. Therefore, proper ACLs should be configured for the RadiantOne Universal Directory replicas to prevent the addition and deletion of entries.</p>\n</blockquote>\n<blockquote>\n<p>[!warning]\r\nThis is an advanced setting, consult with a Radiant Logic Solution Architect to get assistance on the needed architecture and usage.</p>\n</blockquote>\n<h5 id=\"updateable-attributes-from-replicas\">Updateable Attributes from Replicas</h5>\n<p>A comma-separated list of attribute names that the persistent cache should accept changes for. Only changes made to these attributes are processed by the persistent cache. All other changes published in the replication journal from the RadiantOne Universal Directory replicas are ignored by the persistent cache. If an updateable attribute is associated with an extension attribute in the persistent cache, the attribute update is handled locally. If an updateable attribute is sourced from a backend data source, the update is forwarded to the appropriate backend and the cache image is refreshed after the backend update is successful. If the backend update fails, the current persistent cache image is considered the reference and is published to the replication journal to override the images in the RadiantOne Universal Directory replicas in all other clusters.</p>\n<blockquote>\n<p>[!warning]\r\nPersistent Cache stores can only accept modification operations from RadiantOne Universal Directory replicas. Add and delete operations are currently not supported. Therefore, proper ACLs should be configured for the RadiantOne Universal Directory replicas to prevent the addition and deletion of entries.</p>\n</blockquote>\n<blockquote>\n<p>[!warning]\r\nThis is an advanced setting, consult with a Radiant Logic Solution Architect to get assistance on the needed architecture and usage.</p>\n</blockquote>\n<h5 id=\"use-cache-for-authentication\">Use Cache for Authentication</h5>\n<p>The default behavior of the RadiantOne service for processing bind requests for users located in a persistent cache branch is to delegate the credentials checking to the authoritative backend source. If the password in the backend is encrypted using one of the algorithms supported by RadiantOne, and the passwords are stored in the cache, you can configure the service to authenticate the user locally against the password in cache instead of delegating the credentials checking to the backend. To enable this behavior, check the Use Cache for Authentication option on the configured cache branch. This option is not applicable in scenarios where the passwords are not stored in the persistent cache. For an example use case where this option could be applicable, please see <a href=\"07-deployment-architecture#backends-inaccessible-by-all-sites\">Authoritative Backends Inaccessible by All Sites</a>.</p>\n<p>By default, if the Use Cache for Authentication option is enabled and the entry in persistent cache has a password, RadiantOne checks the password against the local value and the user is authenticated or not based on this comparison. If the entry in persistent cache doesn’t have a password, RadiantOne delegates the credentials checking to the backend data source. There are two options to override this default behavior: Local Bind Only or Delegate on Failure.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10.90909090909091%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAACABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG4AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAYEAACAwAAAAAAAAAAAAAAAAAAARAxQf/aAAgBAQABPyHB1H//2gAMAwEAAgADAAAAEAPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAFhABAQEAAAAAAAAAAAAAAAAAAAEx/9oACAEBAAE/EJpTMf/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/ee5d3b554026aa87807a3cc70088d47d/b966c/Image2.25.jpg\"\n        srcset=\"/static/ee5d3b554026aa87807a3cc70088d47d/c1cfe/Image2.25.jpg 275w,\n/static/ee5d3b554026aa87807a3cc70088d47d/67061/Image2.25.jpg 550w,\n/static/ee5d3b554026aa87807a3cc70088d47d/b966c/Image2.25.jpg 624w\"\n        sizes=\"(max-width: 624px) 100vw, 624px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.25: Authentication Options</p>\n<p>Each option is described in more details below.</p>\n<ul>\n<li>\n<p>Local Bind Only – If this option is enabled and the user entry in cache either has no password or the bind fails, RadiantOne does not delegate the credentials checking to the backend. It determines if the user authentication fails based on the local comparison.</p>\n</li>\n<li>\n<p>Delegate on Failure – If this option is enabled and the user entry in cache has a password but the local checking fails, RadiantOne delegates the credentials checking to the backend. If the credentials checking fails against the backend, an unsuccessful bind response is returned to the client. If the credentials checking succeeds against the backend, a successful bind response is returned to the client.</p>\n</li>\n<li>\n<p>Enable Password Policy Enforcement - If you are storing user passwords in cache and you are using the cache for authentication, you can also choose to have RadiantOne enforce password policies (as opposed to delegating password checking to the backend directory and having it enforce password policies). Enable this option and then define the password policy to enforce. For details on password policies, see the RadiantOne System Administration Guide.</p>\n</li>\n<li>\n<p>When you enable the password policy enforcement on a persistent cache, the userPassword attribute is automatically added to the Extension Attribute property and you have the option to enable Password Write Back. If Password Write Back is enabled, and a modify request for the password is sent to RadiantOne, it tries to update the password in the backend. In some circumstances, having two levels of password policies can result in inconsistencies between the cache image and the underlying backend(s). These circumstances are outlined in the table below.</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Password Change Event</th>\n<th>Password Writeback Enabled?</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Password update via a Modify Request sent to RadiantOne</td>\n<td>No</td>\n<td>The password is updated in the persistent cache if it complies with the persistent cache password policy. Otherwise the password update fails. <br> <br> The password update is not sent to the backend. If the update to the persistent cache succeeds, the password in the persistent cache will be different than the one in the backend.</td>\n</tr>\n<tr>\n<td>Password update via a Modify Request sent to RadiantOne</td>\n<td>Yes</td>\n<td>The password update is sent to the backend. If the password update fails in the backend, the password in the persistent cache is not updated. If the password update succeeds in the backend, the password is updated in the persistent cache.</td>\n</tr>\n<tr>\n<td>Password is updated directly in the backend (outside of RadiantOne)</td>\n<td>N/A</td>\n<td>Through the persistent cache refresh process, the password is updated in the persistent cache. If the account was locked in the persistent cache due to a password policy enforced at the cache layer, it will be unlocked by the cache refresh process after a successful password update in the backend. Password strength defined in the persistent cache password policy is not enforced since the password change originated from the backend.</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"active\">Active</h5>\n<p>Check the Active option if you want to Activate this naming context. Uncheck the Active option to deactivate the cache. If a persistent cache is deactivated, RadiantOne issues queries to the backend(s) when processing client requests.</p>\n<h5 id=\"full-text-search\">Full-text Search</h5>\n<p>Persistent cache branches can support full text searches. This offers additional flexibility for clients as they can search data in the RadiantOne namespace based on text (character) data. These types of searches are no longer linked to specific attributes as the characters requested could be found in any attribute value. An entry is returned if any attribute in the entry contains the character string(s) requested by the client.</p>\n<p>Clients issue full text searches similar to the way they issue LDAP searches. The only difference is the filter contains <code class=\"language-text\">(fulltext=&lt;value>)</code> where <code class=\"language-text\">&lt;value></code> would be the text they are interested in. As an example, if a client was interested in the text John Doe as an exact phrase, the search filter sent to RadiantOne would be (fulltext= “John Doe”) where the phrase is encapsulated in double quotes. If the phrase in the filter is not encapsulated in double quotes it means the client wants any entries that have attribute values that contain the character string John OR Doe.</p>\n<p>The part of the filter that contains the piece related to the full text search can also be combined with other “standard” LDAP operators. As an example, a filter could be something like (&#x26;(uid=sjones)(fulltext=”John Doe”)). This would return entries that contain a uid attribute with the value sjones AND any other attribute that contains the exact character string John Doe.</p>\n<p>If you want the persistent cache to support full text searches, check the Full-Text Search option and click <strong>Save</strong>. If you add the support for full text searches, click <strong>Re-build Index</strong>.</p>\n<h5 id=\"optimize-linked-attributes\">Optimize Linked Attributes</h5>\n<p>Linked attributes are attributes that allow relationships between objects. A typical example would be isMemberOf/uniqueMember for user/groups objects. A group has members (uniqueMember attribute) which is the forward link relationship. Those members have an isMemberOf attribute which is the back link (to the group entry) relationship. Other examples of linked attributes are:</p>\n\n          <codeblockcopytag>manager/directReports\r\naltRecipient/altRecipientBL\r\ndLMemRejectPerms/dLMemRejectPermsBL\r\ndLMemSubmitPerms/dLMemSubmitPermsBL\r\nmsExchArchiveDatabaseLink/msExchArchiveDatabaseLinkBL\r\nmsExchDelegateListLink/msExchDelegateListBL\r\npublicDelegates/publicDelegatesBL\r\nowner/ownerBL</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">manager/directReports\r\naltRecipient/altRecipientBL\r\ndLMemRejectPerms/dLMemRejectPermsBL\r\ndLMemSubmitPerms/dLMemSubmitPermsBL\r\nmsExchArchiveDatabaseLink/msExchArchiveDatabaseLinkBL\r\nmsExchDelegateListLink/msExchDelegateListBL\r\npublicDelegates/publicDelegatesBL\r\nowner/ownerBL</code></pre></div>\n<p>The most common back link/forward link relationship is between group and user objects. A list of groups a user is a member of can be calculated automatically by RadiantOne and returned in the membership attribute of the user entry. The most common back link attributes are in the drop-down list. However, you can manually enter any attribute name you want. This is configured on the Main Control Panel, click Settings > Interception > Special Attributes Handling > Linked Attributes setting (on the right).</p>\n<p>If the Target Base DN (back link attribute location) and the Source Base DN (forward link attribute location) in the Linked Attributes setting is a persistent cached branch, the computation of the references can be optimized in order to return client requests for the back link attribute at high speed. To enable this optimization, follow the steps below.</p>\n<blockquote>\n<p>[!warning]\r\nIf your linked attributes are for users and groups (both branches located in persistent cache), and you enable the Optimize Linked Attributes setting, and must support nested groups, only one user location per persistent cache store is supported. For example, in the Linked Attributes setting, having a Target Base DN location configured for ou=people1,dc=myhdap and ou=people2,dc=myhdap (both in the same dc=myhdap persistent cache store) is not supported. In this case, you should configure a single user location as dc=myhdap as a shared parent for both containers.</p>\n</blockquote>\n<p>It is assumed you have configured and initialized your persistent cache, and configured the Linked Attributes in Special Attributes Handling. If you have not, please do so prior to continuing with the steps below.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 343px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.63636363636364%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB2rCRBxP/xAAXEAADAQAAAAAAAAAAAAAAAAABEBEA/9oACAEBAAEFAgqNH//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABoQAAEFAQAAAAAAAAAAAAAAAAEAEBEhMcH/2gAIAQEAAT8h1dsZo4gAxoC//9oADAMBAAIAAwAAABB7P//EABYRAQEBAAAAAAAAAAAAAAAAAAABIf/aAAgBAwEBPxCNf//EABYRAQEBAAAAAAAAAAAAAAAAAAABIf/aAAgBAgEBPxCsf//EAB0QAQACAQUBAAAAAAAAAAAAAAEAESExQVFhcdH/2gAIAQEAAT8Q1Dd8qCJiBSWzDl8hNCjiVOon/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/8f4757535013efda5f9eff70bacb365c/4f01a/Image2.29.jpg\"\n        srcset=\"/static/8f4757535013efda5f9eff70bacb365c/c1cfe/Image2.29.jpg 275w,\n/static/8f4757535013efda5f9eff70bacb365c/4f01a/Image2.29.jpg 343w\"\n        sizes=\"(max-width: 343px) 100vw, 343px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.29: Back Link Attribute Name in Special Attribute Handling</p>\n<ol>\n<li>\n<p>Select the Optimize Linked Attributes option on the Properties tab for the selected persistent cache branch on the Main Control Panel > Directory Namespace tab > Cache section. The defined linked attribute is added to the Extension Attributes List for the persistent cache.</p>\n</li>\n<li>\n<p>Click <strong>Save</strong>.</p>\n</li>\n<li>\n<p>You can either rebuild the index, or reinitialize the persistent cache. Click <strong>Re-build Index</strong> or <strong>Initialize</strong>. The back link attribute is always returned to clients even when not requested unless Hide Operational Attributes is enabled in RadiantOne (in which case it is only returned when a client explicitly requests it). For details on the Hide Operational Attributes setting, please see the RadiantOne System Administration Guide.</p>\n</li>\n</ol>\n<blockquote>\n<p>[!warning]\r\nIf a persistent cache has optimizations associated with it, deactivating it will interfere with queries associated with the linked attributes and they will not return properly. If you no longer need a cache, delete it instead of deactivating it.</p>\n</blockquote>\n<h4 id=\"persistent-cache-universally-unique-identifier-uuid\">Persistent Cache Universally Unique Identifier (UUID)</h4>\n<p>The Universally Unique Identifier (UUID) attribute is a reserved, internal attribute that is assigned to each entry and can guarantee uniqueness across space and time.</p>\n<p>When adding entries into a persistent cache (LDAP ADD operations) from an LDIF file, if there are UUID attributes they are ignored by RadiantOne during import. RadiantOne generates a unique value for each entry based on the specifications in RFC 4122.</p>\n<p>When initializing with an LDIF file (LDIF INIT), if the entry has a UUID attribute, RadiantOne keeps it. If the entry does not have a UUID attribute, RadiantOne generates a unique value for each entry based on the specifications in RFC 4122.</p>\n<p>UUID is an operational attribute meaning that if a client wants this attribute, they must explicitly ask for it in the search request sent to RadiantOne.</p>\n<p>When exporting a persistent cache store to an LDIF file, you have the option to export the UUID attribute or not. The UUID attribute should be exported into LDIF if you plan on using this export to initialize a RadiantOne Universal Directory store, a replica for inter-cluster replication. Otherwise, the UUID attribute generally should not be exported. To export a persistent cache store and include the UUID attributes, check the Export for Replication option in the export window.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 538px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.90909090909091%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7qcJRmH/xAAZEAABBQAAAAAAAAAAAAAAAAAQAAECETL/2gAIAQEAAQUCFsJZX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAAIDAAAAAAAAAAAAAAAAAAABICEx/9oACAEBAAY/Ai2aof/EABkQAQACAwAAAAAAAAAAAAAAAAEAERAxYf/aAAgBAQABPyGiKBdB3IboT//aAAwDAQACAAMAAAAQ/wD/AP/EABYRAQEBAAAAAAAAAAAAAAAAAAEQIf/aAAgBAwEBPxBwn//EABYRAQEBAAAAAAAAAAAAAAAAAAEQIf/aAAgBAgEBPxA1n//EABsQAAIDAAMAAAAAAAAAAAAAAAABETFBEJGx/9oACAEBAAE/EIE6nIGZBWskiSuzjyFD/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/107ecd4ba74c4f745b67d1e0f1a91b44/22978/Image2.30.jpg\"\n        srcset=\"/static/107ecd4ba74c4f745b67d1e0f1a91b44/c1cfe/Image2.30.jpg 275w,\n/static/107ecd4ba74c4f745b67d1e0f1a91b44/22978/Image2.30.jpg 538w\"\n        sizes=\"(max-width: 538px) 100vw, 538px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.30: Export Persistent Cache</p>\n<h4 id=\"managing-the-persistent-cache\">Managing the Persistent Cache</h4>\n<h5 id=\"re-initializing-a-persistent-cache\">Re-initializing a Persistent Cache</h5>\n<p>Persistent cache should be re-initialized during off-peak hours, or during scheduled downtime, since it is a CPU-intensive process and during the initialization queries are delegated to the backend data sources which might not be able to handle the load.</p>\n<p>Cache refresh connectors do not need to be stopped to re-initialize the persistent cache.</p>\n<ol>\n<li>\n<p>Deactivate any inter-cluster replication on the cached branch prior to re-initializing. To do so, navigate to the cached branch on the Main Control Panel > Directory Namespace Tab and on the right side, uncheck “Inter-cluster Replication”, then click <strong>Save</strong>. Click <strong>Yes</strong> to apply the changes to the server.</p>\n</li>\n<li>\n<p>With the cached node selected, on the Refresh Settings tab, click <strong>Initialize</strong>.</p>\n</li>\n<li>\n<p>Choose to either initialize the cache by creating an LDIF file or from an existing LDIF file. Typically, you would always use the default option which is to create an LDIF file. The only time you could choose to use an existing file is if you already have an up-to-date LDIF file containing all of the needed entries.</p>\n</li>\n<li>\n<p>Click <strong>OK</strong>. A task is launched to re-initialize the persistent cache. The task can be monitored and managed from the Server Control Panel > Tasks Tab associated with the RadiantOne leader node.</p>\n</li>\n<li>\n<p>Click <strong>OK</strong> to exit the initialization wizard.</p>\n</li>\n<li>\n<p>Click <strong>Save</strong> in the upper right corner.</p>\n</li>\n<li>\n<p>Re-enable Inter-cluster Replication that was deactivated in step 1.</p>\n</li>\n</ol>\n<h5 id=\"re-building-index\">Re-building Index</h5>\n<p>If the cache has already been initialized, and the attribute list for sorted indexes changes (new attributes need to be indexed or removed from the index), you must rebuild the index. From the Main Control Panel -> Directory Namespace Tab, select the persistent cache branch below the Cache node. On the Properties tab on the right side, click the Re-build Index button.</p>\n<h5 id=\"exporting-the-cache\">Exporting the Cache</h5>\n<p>Exporting the cache generates an LDIF formatted file from the cache contents. This can be useful if you want to replicate this cache image across multiple RadiantOne clusters. To export the cached branch, from the Main Control Panel -> Directory Namespace Tab, select the persistent cache branch below the Cache node. On the Properties Tab on the right side, click the Export button. Enter a name, select a type of file (LDIF or LDIFZ which is a zipped and encrypted file) and click <strong>OK</strong>. If you want to use this LDIF file to initialize a cache or Universal Directory store in another cluster, use the Main Control Panel > Settings Tab > Configuration > File Manager to browse to &#x3C;RLI_HOME>/vds_server/ldif/export to download the file. Then, connect to the Main Control Panel in the target environment where you want to use the LDIF file and use the Settings Tab > Configuration > File Manager to navigate to &#x3C;RLI_HOME>/vds_server/ldif/import to upload the LDIF file. When you initialize the cache in the target environment, browse to this location to locate the file to use for initialization.</p>\n<blockquote>\n<p>[!warning]\r\nIf exporting to an LDIFZ file, a security key must be configured. This key is the same as the one used for attribute encryption. Any target server (persistent cache or RadiantOne Universal Directory store) where you want to import this LDIFZ file must use the same security key value. The security key is defined from the Main Control Panel > Settings Tab > Security > Attribute Encryption section. If an LDIFZ encryption key is defined, only the ldifz file type is available when exporting to LDIF from the Main Control Panel > Directory Browser tab.</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 401px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHdgSoX/8QAFhABAQEAAAAAAAAAAAAAAAAAAQAC/9oACAEBAAEFApQDQ3//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAXEAEAAwAAAAAAAAAAAAAAAAAAARHh/9oACAEBAAY/Alyx/8QAGRAAAwADAAAAAAAAAAAAAAAAAAERITGR/9oACAEBAAE/IcDFSI0zfR//2gAMAwEAAgADAAAAEI/v/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8QZ//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ECf/xAAZEAEAAwEBAAAAAAAAAAAAAAABABEhMaH/2gAIAQEAAT8QAHNjsjogvhBlRTWhP//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/ceff596ce3e0fe2f63096f88292a66d1/f6c81/Image2.31.jpg\"\n        srcset=\"/static/ceff596ce3e0fe2f63096f88292a66d1/c1cfe/Image2.31.jpg 275w,\n/static/ceff596ce3e0fe2f63096f88292a66d1/f6c81/Image2.31.jpg 401w\"\n        sizes=\"(max-width: 401px) 100vw, 401px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.31: Exporting an LDIFZ file</p>\n<h5 id=\"testing-persistent-cache-refresh-process\">Testing Persistent Cache Refresh Process</h5>\n<p>To test the persistent cache refresh process, use an LDAP command line utility like the one described below. If the connectors are running, suspend them from the Main Control Panel > PCache Monitoring tab.</p>\n<p>The ldapsearch utility offered in the Sun Resource Kit can be used to force a refresh of the persistent cache based on a specific DN. The command would look similar to the following:</p>\n\n          <codeblockcopytag>ldapsearch -h 10.11.12.91 -p 2389 -D &quot;cn=directory manager&quot; -w &quot;secret&quot; -b &quot;action=synchronizecache,customers=ALFKI,dv=northwind,o=vds&quot; -s base (objectclass=*)</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ldapsearch -h 10.11.12.91 -p 2389 -D \"cn=directory manager\" -w \"secret\" -b \"action=synchronizecache,customers=ALFKI,dv=northwind,o=vds\" -s base (objectclass=*)</code></pre></div>\n<p>The above command refreshes the single entry identified by the DN of customers=ALFKI,dv=northwind,o=vds. If you want to refresh multiple entries with a single command, you can use a ONE LEVEL or SUBTREE scope. If you wanted to refresh all entries below dv=northwind, the command would be:</p>\n\n          <codeblockcopytag>ldapsearch -h 10.11.12.91 -p 2389 -D &quot;cn=directory manager&quot; -w &quot;secret&quot; -b &quot;action=synchronizecache,dv=northwind,o=vds&quot; -s one (objectclass=*)</codeblockcopytag>\n          \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ldapsearch -h 10.11.12.91 -p 2389 -D \"cn=directory manager\" -w \"secret\" -b \"action=synchronizecache,dv=northwind,o=vds\" -s one (objectclass=*)</code></pre></div>\n<p>Each parameter of the command is described below.</p>\n<p>-h is the RadiantOne server name or IP address.</p>\n<p>-p is the LDAP port RadiantOne is listening on.</p>\n<p>-D is the user to connect to RadiantOne as.</p>\n<p>-w is the password for the user you are connecting with.</p>\n<p>-b is the DN for the entry in the persistent cache that you want refreshed (if a base scope). If a one level, or sub tree scope is used, then -b is the starting point in the persistent cache to start refreshing from.</p>\n<p>-s is the scope of the search which should be base, one or sub.</p>\n<p>(objectclass=*) is the filter.</p>\n<p>Modify the above command to match your requirement. Keep the following in mind.</p>\n<ul>\n<li>\n<p>Always connect to RadiantOne as the directory manager</p>\n</li>\n<li>\n<p>Replace the DN with your own (always start with action=synchronizecache,)</p>\n</li>\n</ul>\n<p>To test, first modify the information in the underlying source. The persistent cache should not reflect any change. Next, execute the ldapsearch command mentioned above. Now, the persistent cache should reflect the new entry. Be sure to check all log files if the persistent cache did not get refreshed properly.</p>\n<h5 id=\"logging-persistent-cache-refreshes\">Logging Persistent Cache Refreshes</h5>\n<p>If the change log has been enabled for RadiantOne, then all changes affecting the persistent cache are logged there. Otherwise, all activity to the persistent cache is logged into a branch in the RadiantOne namespace with a root suffix of cn=cacherefreshlog. This branch only stores changes that affect persistent cache branches.</p>\n<p>Logging of persistent cache changes into the cn=cacherefreshlog is always enabled and different log levels can be configured. The log level is set on the Main Control Panel > Settings Tab > Logs section > Changelog sub-section. Select the drop-down list next to the Persistent Cache Refresh Log option on the right side and choose a log level. The log levels are:</p>\n<ul>\n<li>\n<p>Error – logs only errors that occur when trying to refresh the persistent cache. This is the default.</p>\n</li>\n<li>\n<p>Status – logs the status (and the DN that was refreshed) when refreshes are made to the persistent cache.</p>\n</li>\n<li>\n<p>All – logs all refreshes to the persistent cache including the changes that occurred.</p>\n</li>\n</ul>\n<p>Entries remain in the cn=cacherefreshlog for a default of 3 days. This is configurable and defined in the Main Control Panel > Settings Tab > Logs section > Changelog sub-section, Changelog and Journal Stores Max Age property. This property is shared by the following internal stores.</p>\n<ul>\n<li>\n<p>cn=changelog</p>\n</li>\n<li>\n<p>cn=cacherefreshlog</p>\n</li>\n<li>\n<p>cn=replicationjournal</p>\n</li>\n<li>\n<p>cn=localjournal</p>\n</li>\n<li>\n<p>cn=tombstone</p>\n</li>\n<li>\n<p>cn=clustermonitor</p>\n</li>\n<li>\n<p>cn=queue</p>\n</li>\n<li>\n<p>cn=dlqueue</p>\n</li>\n</ul>\n<p>Typically, if the changelog has been enabled then error log level is used for the persistent cache refresh log. For more information, please see Persistent Cache Log Setting in the RadiantOne System Administration Guide.</p>\n<h5 id=\"detecting-persistent-cache-update-errors\">Detecting Persistent Cache Update Errors</h5>\n<p>If an entry in the persistent cache fails to be updated, the entry in the cache refresh log is tagged with a status attribute of 2.</p>\n<p>An example of a failed cache refresh log entry can be seen in the figure below.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 483px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHbFuIGD//EABkQAAIDAQAAAAAAAAAAAAAAAAACARARIf/aAAgBAQABBQJTDBZ7X//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAQEBAAAAAAAAAAAAAAAAABABAv/aAAgBAQAGPwKun//EABoQAAMAAwEAAAAAAAAAAAAAAAABERAxUSH/2gAIAQEAAT8h2K8qwjhZPBax/9oADAMBAAIAAwAAABBTD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQACAgMAAAAAAAAAAAAAAAEAESExEHGB/9oACAEBAAE/ECaCLXbRTiAFUfIyFZYmjrj/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"An image showing \"\n        title=\"\"\n        src=\"/static/c53da3011ceb7ac29495b3950dfb6e0d/81888/Image2.32.jpg\"\n        srcset=\"/static/c53da3011ceb7ac29495b3950dfb6e0d/c1cfe/Image2.32.jpg 275w,\n/static/c53da3011ceb7ac29495b3950dfb6e0d/81888/Image2.32.jpg 483w\"\n        sizes=\"(max-width: 483px) 100vw, 483px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Figure 2.32: Persistent Cache Refresh Log Entry</p>\n<p>If the problem resulting in the update error has been fixed, you can manually reissue the update request with a base search on the entry using the targetDN attribute in the persistent cache refresh log. Using the example shown above, the entry in persistent cache is Employee=1,Category=employees,dc=csaa. Therefore, the command to refresh this entry in cache would look similar to the following:</p>\n<p>ldapsearch -h 10.11.12.91 -p 2389 -D \"cn=directory manager\" -w \"secret\" -b \"action=synchronizecache,Employee=1,Category=employees,dc=csaa\" -s base (objectclass=*)</p>\n<blockquote>\n<p>[!warning]\r\nIf there are many failed entries in the persistent cache refresh log, meaning that the cache image is significantly different than the backends, it might be more efficient to reinitialize the persistent cache as opposed to trying to fix the failed updates one at a time.</p>\n</blockquote>\n<h5 id=\"deleting-the-persistent-cache\">Deleting the Persistent Cache</h5>\n<p>To delete a persistent cache branch, uncheck the Active checkbox (on the Properties tab for the cached branch), then click Save to apply the changes to the server. Then click <strong>Delete</strong>.</p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{"id":"chapter-2-tuning-tips-for-caching-in-the-radiantone-federated-identity-service"},"children":[{"type":"text","value":"Chapter 2: Tuning Tips for Caching in the RadiantOne Federated Identity Service"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This chapter provides guidelines on how to effectively use caching for optimal performance. The first part covers the different categories and levels of cache along with a quick review of the different use cases that justify a cache deployment. The second part provides details and describes the advantages and trade-off between “in-memory” and “persistent” cache. Finally, a description of cache refresh methods is reviewed. This is an essential and often overlooked aspect of cache management."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Persistent caching is only associated with the RadiantOne Federated Identity module and is irrelevant for "},{"type":"element","tagName":"a","properties":{"href":"04-tuning-tips-radiantone-universal-directory.md"},"children":[{"type":"text","value":"RadiantOne Universal Directory"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"when-and-why-do-you-need-a-cache-with-radiantone-fid"},"children":[{"type":"text","value":"When and why do you need a cache with RadiantOne FID?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are many cases where RadiantOne is leveraged more for its flexibility rather than its pure speed. However, in most critical operations such as identification, authentication, and authorization, it needs to provide guaranteed fast access to information. In fact, in many cases RadiantOne needs to provide read operations that are faster than what can be delivered by the underlying sources. What is meant by “fast”, is a level of performance that is at least 3 to 5 times what can be derived from standard relational databases (RDBMS) – as an example."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"An additional requirement, in some situations, is a fast “write” capability. A typical case is when security information needs to be logged into the directory for audit purposes at authentication time. The problem is that most directories are a lot slower than RDBMS when it comes to write operations. In this case, RadiantOne can forward the writes to faster transactional data stores."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The question then becomes: How can the RadiantOne FID service be faster than the underlying data sources despite the fact that it adds an extra layer of software and one more intermediate TCP/IP hop?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The answer is unambiguous, without caching, the RadiantOne FID service is always slower than the sources it has virtualized. In terms of overhead, the additional TCP/IP hop (an application talks to RadiantOne first and then it talks to the underlying sources) by itself, divides the throughput of the virtualized source by approximately half. If you include the dynamic transformations, the joins, and the reorganization of the underlying namespaces to this overhead (in short, all the value added by RadiantOne through on-the-fly processing), it is difficult to imagine how this service can be faster than the underlying sources with dynamic access alone."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For all the above reasons, a flexible and efficient cache strategy and cache refresh mechanism is an absolute necessity. In most sizeable identity and access management deployments, caching is not only required, but also depending on volume, scalability, resilience to failure, etc…different levels and types of cache (in-memory and/or persistent) are needed."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To better understand the different aspects of performance and cache for RadiantOne, we need to look at the architecture. At a high level, the architecture can be divided into two main layers:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A front-end layer which handles the protocol (LDAP or other standard protocols such as a Web Services, SPML, or SAML)."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A back-end layer that oversees mapping/transforming the result set from the “virtualized” data sources (directories, databases and/or applications)."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The performance of the RadiantOne service depends on a front-end layer that shares most of the logic of an LDAP server and as such can leverage the same optimization strategies. However, performance also depends even more on the back–end layer, which really represents the virtualization. This is where the secret for performance and scalability resides and, where a solid and scalable caching mechanism is indispensable."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"###Front-end performance"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The RadiantOne front-end shares most of the layers of a “classic” LDAP directory and the same “potential” bottlenecks. They are essentially at:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The TCP/IP server (and client) connections"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The first level of query parsing"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"tcpip-connections-and-connection-pooling"},"children":[{"type":"text","value":"TCP/IP Connections and Connection Pooling"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The first bottleneck is common to any TCP/IP based server and not specific to LDAP servers. Even if a server could set aside resources (memory and handles) for an arbitrarily large number of connections, what the server can really support (the effective number of concurrent connections) is dictated by the underlying hardware platform, bandwidth and operating system. Once this level is reached, no matter how powerful the underlying hardware is (in terms of processing throughput), the server is idle and waiting for the establishment of the connections. In this case the only possible optimization at the TCP layer would be by using specific hardware such as TCP offload engines, more bandwidth, better routers and/or scaling out by load balancing."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The latency of a TCP/IP client connection is another point to consider in the terms of performance. The latency of a TCP/IP client connection, compared to the speed of the processor is extremely high. As a result, multiple connections and disconnections hamper the apparent throughput of any directory server. (An easy way to verify this fact is to run the “search rate” utility (as described in "},{"type":"element","tagName":"a","properties":{"href":"05-testing-radiantone-performance.md"},"children":[{"type":"text","value":"Chapter 5"}]},{"type":"text","value":") against any LDAP directory with or without keeping the connection open after each search). With multiple connections/disconnections the search rate of a server drops to a quarter or a third of the normal throughput. At the same time the CPU of the server shows a lot of idle cycles. Most of the time is spent waiting for the establishment or re-establishment of the client TCP/IP connection. Since the RadiantOne service must connect to many distributed sources, it acts as a client to many TCP/IP servers, and so the cumulated latencies could be quite high. The solution to this problem consists in pooling the different connections by class of connected servers to reuse existing connections as much as possible. It is essentially a form of cache for an already open structure needed for a connection. Therefore, support for connection pooling is an important feature for RadiantOne in dynamic access mode (without caching any data at the level of the server). For details on connection pooling, please see "},{"type":"element","tagName":"a","properties":{"href":"03-tuning-tips-for-specific-types-of-backend-data-sources.md"},"children":[{"type":"text","value":"Chapter 3"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"first-level-of-query-parsing"},"children":[{"type":"text","value":"First Level of Query Parsing"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The second issue is the overhead generated by the parsing of incoming queries. Although a lot less expensive than TCP/IP overhead, the parsing time is not negligible. To optimize, RadiantOne couples a query cache with an entry cache. The idea is that by caching a frequently issued query and its result set (entry cache), significant server time can be saved. This strategy works well when information is not too volatile. The cache is equipped with a LRU (least recently used) eviction policy and TTL (time-to-live) marker for both queries and entries."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"However, query cache and entry cache are not the panacea to addressing performance issues. Query cache is relatively blind and based essentially on syntax and not semantics: two queries yielding equivalent results but using a slightly different syntax are represented twice in the cache. Another limitation is the size of these caches. As volume increases, many factors start to negate the value of the approach. The cache refresh strategy is more complex, and latency in case of failure and cold restart (the cache needs to be re-populated before providing its performance boost) can be stumbling blocks. For these reasons, these categories of caches in RadiantOne are used essentially as a performance enhancer rather than the base for server speed. If correctly sized, such a cache brings a 15 to 30% performance boost to a server (unless the whole dataset is quite small and could fit entirely in memory). The next section explains that the key to scalability and sustainable performance for a directory with significant volume rests upon its indexing strategy for entries and access paths."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"back-end-performance"},"children":[{"type":"text","value":"Back-end Performance"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"The “Secret” of LDAP Directory Speed"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The beginning of this chapter referred to the speed of a directory being primarily focused on reads. So, how fast is fast? Between 1500 to 2000 queries per second/per GHZ/per processor (Pentium IV class machine on a Windows Server or Linux) for LDAP (Sun or Netscape 4.x to 5.x) versus 150 to 300 queries per second for a RDBMS (Oracle, DB2, or SQL Server) for a standard entry search with fully indexed queries. The size of an entry for these performance numbers is about 512 bytes, and the number of entries in the LDAP directory was 2 million. These numbers reflect a search operation for identification purposes (login). This performance is quite stable, even if the volume of entries goes up to 80 to 100 million entries. However, the size of an entry is a factor in terms of performance. At 2 KB or more per entry the search rate starts to drop quickly."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The performance secret of an LDAP server when it comes to read and search operations is a relatively simple structure for queries and operations, which yields a much simpler access method and storage strategy (nothing to be compared with the richness and capabilities of SQL, but also none of the optimizations and complexity required of a full RDBMS). Essentially, an LDAP directory can be implemented very efficiently with a classic approach of fully indexed data files based on B+ trees (RDBMS uses the same kind of storage and access methods, however their access plans are a lot more complex, involve a lot of processing, many indexes and optimizations for full support of relational operations)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Due to their relative simplicity, LDAP directories fully benefit from the classic advantages of B+ tree indexing. Searching for an entry based on a fully indexed attribute can be delivered in a guaranteed time and scale quite well. Even without page caching, a B+ tree index can retrieve an indexed attribute (in the worst case) in no more than log N disk accesses, N being the number of entries. This simple and robust structure explains the performance and stability of LDAP directories when it comes to read even with a significant number of entries (100 million entries or more). More importantly, this level of speed can be guaranteed even with a relatively modest amount of main memory, again one of the strong points for B+Trees. However, the story in terms of writes is not as good. Writing is an expensive operation, which does not scale well when the volume of entries increases. If this constraint is added, the fact that an LDAP directory must maintain many indexes (ideally as many as potentially “searchable” attributes), you can see that the number of updates is the key factor that limits the scalability of a classic directory. As is well documented, a directory is optimized for read with a modest amount of writes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"The Different Caching Strategies"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Where are the bottlenecks for the RadiantOne service? As described in this chapter, when it comes to the front-end layer read/search speed, RadiantOne is comparable to a classic directory. The optimizations at this level are also similar. The target is essentially to optimize the TCP/IP connections and to re-use the previous queries and corresponding results sets (Query cache and entry cache - see previous sections) when and where possible."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"The major bottleneck is at the level of the back-end"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"By definition, a federated identity layer does not own any specialized back-end like a classic LDAP server (which as we have seen is the secret to speed and scalability with modest memory requirements). By construction, a federated identity layer needs access to the underlying “virtualized” data sources. Without a caching strategy, a federated identity layer acts simply as a proxy and forwards the calls to the underlying sources. Without caching, even with the best optimization at the front-end, RadiantOne FID can only deliver a fraction of the speed of the underlying sources. If the “virtualized” sources are fast in terms of read operations and if the virtualization overhead is acceptable then dynamic access alone to the source data may be a viable strategy."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"However in most cases (e.g. when databases and/or Web Services are involved and volume is significant), a back-end caching mechanism is a requirement. A complete federated identity layer needs to offer different levels of cache with different cache refresh implementation strategies matching different use cases."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are essentially two forms of cache:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In-memory cache"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Disk-based cache also called “persistent cache”"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Each of these caching mechanisms can be refreshed using different methods."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Cache refresh strategies can be divided into two main categories:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Polling the changes either periodically or based or an expiration of a “time-to-live“ value assigned to a cache entry"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Detecting the change events directly at the sources (triggers or other methods)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"memory-cache"},"children":[{"type":"text","value":"Memory Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In this approach, cached entries are stored solely in memory. In terms of implementation, this approach has the advantage of simplicity. However in practice, this solution may present many potential issues depending on the use case. In most cases, memory cache works when the volume of entries and the complexity of the queries are modest. However, with sizeable volume (and often the flexibility of a federated identity service tends to yield many use cases which quickly add an increased demand in terms of memory) and the variable latencies and volatility (update rates) of the virtualized data sources, it is difficult to guarantee the performance of a memory cache solution. The greatest risks with a memory cache result when the query pattern is not predictable and the data set volume exceeds the size of memory. Furthermore, some categories of directory views are not good candidates for caching because the operation can never guarantee that all possible observable results are retrieved at the right time. If the volatility of the underlying data store is high, and the volume of data is significant, then a memory cache with a time-to-live refresh strategy alone is very difficult to put in place and will not guarantee an accurate “image” or will generate excessive refresh volume negating the advantages of the cache. As a result, providing guaranteed performance is difficult if not impossible. Moreover, as volume increases or when queries needed to build the virtual image are more complex, the latency incurred by accessing the underlying sources just to rebuild the memory cache after a cold restart becomes more and more problematic. As a consequence, memory cache provides performance improvements only in very specific cases. Memory cache needs to be considered more like a partial/incremental improvement boost rather than a complete solution to guaranteed performance."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"persistent-cache"},"children":[{"type":"text","value":"Persistent Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In this approach, images of the virtual entries are stored in the local RadiantOne Universal Directory. This approach allows for fast recovery in case of failure. The whole virtual tree could be cached this way and a large volume of entries can be supported (hundreds of millions entries - essentially no practical limit if combined with partitioning and clusters)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The challenge then becomes how to access this disk cache selectively at the level of each entry and at the same speed than the fastest classic LDAP server. The answer is pretty straightforward even if its implementation is not: build a persistent cache, which is a full LDAP V3 server. All the advantages described for the classic LDAP directory speed apply here. The persistent cache becomes the equivalent of what in the RDBMS world we would call a “materialized” view of a complex directory tree stored in an LDAP format and transparently refreshed by polling or pushing events (triggers or logs) at the level of the data sources. In fact, the complexity here resides essentially in the cache refresh mechanism. The good news is that by leveraging good abstraction and representation (data modeling and metadata) of the different data sources, a completely automated solution is possible. One can say that in this case, a bit paradoxically, good abstraction and virtualization ends up into an always “synchronized” and persistent directory view. The major difference though with classic synchronization resides in the simplicity and the ease of deployment. Virtualization and good data modeling yield an automated solution where transformation, reconciliation, joins, caching, and synchronization is totally transparent to the RadiantOne administrator and reduced to a fairly simple configuration."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The diagram below provides a general “rule of thumb” as to what type of cache to implement."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 492px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 20.363636363636363%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAd0RRX//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAYEAADAQEAAAAAAAAAAAAAAAAAASFRcf/aAAgBAQABPyHaZWLrP//aAAwDAQACAAMAAAAQfA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAADAQEBAAAAAAAAAAAAAAAAAREhUdH/2gAIAQEAAT8QjumiTvAI55H/2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/d7d97183789a760cd34bc9f09f3c5e97/aee3f/Image2.1.jpg","srcSet":["/static/d7d97183789a760cd34bc9f09f3c5e97/c1cfe/Image2.1.jpg 275w","/static/d7d97183789a760cd34bc9f09f3c5e97/aee3f/Image2.1.jpg 492w"],"sizes":"(max-width: 492px) 100vw, 492px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.1: Cache implementation diagram"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Low volatility during the life of the cache (the time to live)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"** Repetitive Queries – a query having exactly the same syntax (same user, same filter, same ACL)\r\n*** Low Volume – The size of the cache as measured by (Nb entries * entry size * 2.5) cannot exceed the amount of memory allocated for cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nFor persistent cache, there is no limitation in terms of number of entries since everything is stored on disk. When fully indexed, the persistent cache provides performance levels comparable to the fastest “classic” LDAP directory and even better performance when it comes to modify operations."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"cache"},"children":[{"type":"text","value":"Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"RadiantOne offers different caching options to accommodate a variety of deployment needs."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Memory Cache (Entry Cache and Query Cache)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Persistent Cache"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The diagram below provides a general “rule of thumb” as to what type of cache to implement."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Low volatility during the life of the cache (the time to live)."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"** Repetitive Queries – a query having exactly the same syntax (same user, same filter, same ACL)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"*** Low Volume – The size of the cache as measured by (Nb entries * entry size * 2.5) cannot exceed the amount of memory allocated for cache."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For persistent cache, there is no limitation in terms of number of entries since everything is stored on disk. When fully indexed, the persistent cache provides performance levels comparable to the fastest “classic” LDAP directory."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"memory-cache-1"},"children":[{"type":"text","value":"Memory Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A memory cache (requires "},{"type":"element","tagName":"a","properties":{"href":"00-preface#expert-mode"},"children":[{"type":"text","value":"Expert Mode"}]},{"type":"text","value":") can be configured for any virtual directory view and there are two different types of memory caching available: "},{"type":"element","tagName":"a","properties":{"href":"#configuring-entry-memory-cache"},"children":[{"type":"text","value":"Entry Memory Cache"}]},{"type":"text","value":" and "},{"type":"element","tagName":"a","properties":{"href":"#configuring-query-cache"},"children":[{"type":"text","value":"Query Memory Cache"}]},{"type":"text","value":". They can be used together or individually."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf you plan on using both entry and query cache on the same view/branch, be aware that the query cache is searched first."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"configuring-entry-memory-cache"},"children":[{"type":"text","value":"Configuring Entry Memory Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This model of caching leverages two types of memory: Main and Virtual. Main memory is the real memory where a certain number of most recently used entries reside. Virtual memory is memory on disk where all entries that exceed the amount allowed in the main memory reside. The swapping of entries from Virtual to Main memory (and vice versa) is managed by RadiantOne."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"First, enable the Entry Memory Cache. In the Main Control Panel > Settings Tab > Server Front End section > Memory Cache sub-section (requires "},{"type":"element","tagName":"a","properties":{"href":"00-preface#expert-mode"},"children":[{"type":"text","value":"Expert Mode"}]},{"type":"text","value":"), on the right side, check the Entry Cache box. Click Save in the top right corner."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf you plan on caching (either entry memory cache or persistent cache) the branch in the tree that maps to an LDAP backend, you must list the operational attributes you want to be in the cache as “always requested”. Otherwise, the entry stored in cache would not have these attributes and clients accessing these entries may need them. For details on how to define attributes as “always requested” please see the RadiantOne System Administration Guide."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Entry cache is for caching every entry (a unique DN) of the specified tree. This kind of cache works well on trees where the volatility (update rate) is low (the likelihood of this data changing during the lifetime of this cache is low). This type of cache is optimized for and should only be used for finding specific entries (e.g. finding user entries during the “identification” phase of authentication) based on unique attributes that have been indexed in the cache setting, and base searches. The attributes you choose to index for the cache are very important because the value needs to be unique across all entries in the cache. For example, if you index the uid attribute, then all entries in the cache must have a unique uid (and be able to be retrieved from the cache based on this value). On the other hand, an attribute like postalcode would not be a good attribute to index (and search for entries based on) because more than one entry could have the same value for postalcode."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nThe DN attribute is indexed by default. DNs are unique for each entry which is the reason why base searches can be optimized with the entry cache."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For example, to populate/pre-fill the entry cache with unique user entries, you can preload with a query like:"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"ldapsearch -h localhost -p 2389 -D “uid=myuser,ou=people,dc=vds” -w secret -b “ou=people,dc=vds” -s sub (uid=*)"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ldapsearch -h localhost -p 2389 -D “uid=myuser,ou=people,dc=vds” -w secret -b “ou=people,dc=vds” -s sub (uid=*)"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"With this type of LDAP search, all entries (containing uid) are stored in the entry memory cache. Therefore, if a client then searched for:"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"ldapsearch -h localhost -p 2389 -D “uid=myuser,ou=people,dc=vds” -w secret -b “ou=people,dc=vds” -s sub (uid=lcallahan)"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ldapsearch -h localhost -p 2389 -D “uid=myuser,ou=people,dc=vds” -w secret -b “ou=people,dc=vds” -s sub (uid=lcallahan)"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The entry could be retrieved from the entry cache and the underlying source would not need to be accessed."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Also, since all DNs in an LDAP tree are unique, base searches can benefit from entry cache. Continuing with the example above, if a client performed a base search on uid=lcallahan,ou=people,dc=vds, the entry could be retrieved from the entry cache."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nEntry Memory Cache works for BASE searches on entries as well as on One Level and Sub Tree searches. However, for One Level and Sub Tree searches, whether the entry is returned from cache depends on whether the filter is \"qualified\" or not. Qualified means that the attribute in the filter is one that is indexed in your cache. Remember, only UNIQUE attributes can be indexed in your cache. You could index something like cn, which is fine if it is unique across all your entries. You cannot however index something like objectclass as more than one entry could be of the same objectclass."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For example, if your entry cache settings indexed the cn attribute, a search like the following (using the ldapsearch command line utility) doesn’t qualify to return the entry from entry cache even though it may be in the cache:"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"ldapsearch -h localhost -p 2389 -D \"cn=directory manager\" -w secret -b \"cn=Laura Callahan,ou=Active Directory,dc=demo\" -s sub (objectclass=*)"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ldapsearch -h localhost -p 2389 -D \"cn=directory manager\" -w secret -b \"cn=Laura Callahan,ou=Active Directory,dc=demo\" -s sub (objectclass=*)"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"However, both of the following searches WOULD return the entry from the memory cache (because one uses a subtree search requesting a filter based on the indexed attribute, and one is a base search):"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"ldapsearch -h localhost -p 2389 -D \"cn=directory manager\" -w secret -b \"cn=Laura Callahan,ou=Active Directory,dc=demo\" -s sub \"(cn=Laura Callahan)\"\n\nldapsearch -h localhost -p 2389 -D \"cn=directory manager\" -w secret -b \"cn=Laura Callahan,ou=Active Directory,dc=demo\" -s base \"(objectclass=*)\""}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ldapsearch -h localhost -p 2389 -D \"cn=directory manager\" -w secret -b \"cn=Laura Callahan,ou=Active Directory,dc=demo\" -s sub \"(cn=Laura Callahan)\"\n\nldapsearch -h localhost -p 2389 -D \"cn=directory manager\" -w secret -b \"cn=Laura Callahan,ou=Active Directory,dc=demo\" -s base \"(objectclass=*)\""}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To configure an entry memory cache, follow the steps below (requires "},{"type":"element","tagName":"a","properties":{"href":"00-preface#expert-mode"},"children":[{"type":"text","value":"Expert Mode"}]},{"type":"text","value":")."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"On the Main Control Panel > Settings Tab > Server Front End section > Memory Cache sub-section, on the right side click Add in the Entry Cache section."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Select a starting point location in the virtual tree. All entries queried below this point are cached. The maximum number of entries allowed in the main memory is specified in the Number of Cache Entries parameter."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Enter values for the Number of Cache Entries, Time to Live, Indexed attributes, and include/exclude filters. Details about these settings can be found below."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 361px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 92.72727272727273%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHurTKiYEoX/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAECIDH/2gAIAQEAAQUCvIWf/8QAFREBAQAAAAAAAAAAAAAAAAAAEAH/2gAIAQMBAT8BKf/EABURAQEAAAAAAAAAAAAAAAAAABAB/9oACAECAQE/ASH/xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAbEAEAAgIDAAAAAAAAAAAAAAABABARITFBcf/aAAgBAQABPyECI5MPsQhTXXbzV//aAAwDAQACAAMAAAAQ88/A/8QAFREBAQAAAAAAAAAAAAAAAAAAEDH/2gAIAQMBAT8QIP/EABURAQEAAAAAAAAAAAAAAAAAABAx/9oACAECAQE/ECj/xAAdEAEAAgICAwAAAAAAAAAAAAABABEhMRBBUWGh/9oACAEBAAE/EPE+xVABol3L2o3T1xtLiQqHo1GuSue25//Z'); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/07c4641abb127b3ade63586d85c16750/59a3c/Image2.2.jpg","srcSet":["/static/07c4641abb127b3ade63586d85c16750/c1cfe/Image2.2.jpg 275w","/static/07c4641abb127b3ade63586d85c16750/59a3c/Image2.2.jpg 361w"],"sizes":"(max-width: 361px) 100vw, 361px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.2: Entry Cache Settings"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Time to Live"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The amount of time that entries should remain in cache. After the time has been reached, the entry is removed from the cache. The next request for the entry is sent to the underlying data store(s). The result of the request is then stored in the memory cache again. This value is specified in minutes. The default value for this parameter is 60 (1 hour)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Indexes"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Enter the attribute names in the cache that should be indexed. The values need to be separated with a comma. The attribute names must represent unique values for all entries across the entire cache. You must only index attributes that have unique values, otherwise the response from the cache can be unpredictable. For example, if you indexed the postalCode attribute, your first request with a filter of (postalCode=94947) may return 50 entries (because the query would be issued to and returned from the underlying source). However, your second request would only return 1 entry (because RadiantOne expects to find only one unique entry in the cache that matches a postalCode=94947, and this is typically the last entry that was added to the cache). If this functionality does not meet your needs, you should review the query cache and persistent cache options."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Include Filter"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Enter a valid LDAP filter here that defines the entries that should be included in the cache. Only entries that match this filter are cached."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As an alternative approach, you can indicate what entries to exclude by using the Exclude filter described below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Exclude Filter"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Enter a valid LDAP filter here that defines the entries that should be excluded from the cache. All entries that match this filter are not cached."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As an alternative approach, you can indicate what entries to include by using the Include filter described above."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Number of Cached Entries"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The total number of entries kept in main memory. The entry cache can expand beyond the main memory and the entries are swapped as needed. The default value for this parameter is 5000. This means that up to 5000 most recently used entries are put in the main memory cache. As the number of entries exceeds 5000, they are stored as virtual memory (memory on disk) and swapped as needed. The default value of 5000 is usually sufficient."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"memory-size-requirements"},"children":[{"type":"text","value":"Memory Size Requirements"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{"id":"for-entries"},"children":[{"type":"text","value":"For Entries"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As a rule of thumb, you should take the average size of one of your entries and multiply by the number of entries you want to store in main memory. Then multiply this total number (the size for all entries) by 2.5. This gives you the amount of main memory you should allocate to store the entries."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"for-indexes"},"children":[{"type":"text","value":"For Indexes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nThis value is the total number of pages for each indexed attribute. The default size is 1000 pages. Which means there are, at most, 1000 index pages for each attribute you have indexed."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For each indexed attribute, the amount of memory consumed per page is calculated by taking the average size of an indexed value x 3 x 64."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"You should keep in mind that dn is always indexed (although it doesn’t appear in the index list). Therefore, the dn attribute by itself consumes the following (assuming the dn is an average of 200 bytes in size):"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"200 x 3 x 64 = 38,400 bytes (approximately 39 KB per index page)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The default of 1000 index pages, consumes about (1000 x 39 KB) 39 MB in memory for the dn attribute."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now, calculate the amount for each attribute you have indexed and add it to the 39 MB."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For example, if you index the attribute uid, and the average uid is 20 characters, you would have 20x3x64 = 3840 byes (approximately 4 KB per index page)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"With 1000 index pages (1000 x 4 KB), about 4 MB in memory is consumed for the uid attribute."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you have 10 attributes indexed (all on average of 20 characters), the total consumption of memory would be about 40 MB + 39 MB (for the dn attribute) for a total of 79 MB."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"total-memory-size-requirements"},"children":[{"type":"text","value":"Total Memory Size Requirements"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Add entry memory cache requirements and index memory cache requirements together to get the total memory size required for your cache."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"configuring-query-cache"},"children":[{"type":"text","value":"Configuring Query Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Query cache is sensitive to syntax. To benefit from the query cache, it must be the exact same query (from the same person, ACI, asking for the same information). This type of caching is good for repetitive queries (of the same nature)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Query cache is only applicable on naming contexts that are not configured as persistent cache."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"First, enable the Query Memory Cache (requires "},{"type":"element","tagName":"a","properties":{"href":"00-preface#expert-mode"},"children":[{"type":"text","value":"Expert Mode"}]},{"type":"text","value":")."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On the Main Control Panel > Settings Tab > Front End section > Memory Cache sub-section, on the right side, check the box in the Query Cache section."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Add"}]},{"type":"text","value":" in the Query Cache section."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Select a starting point location in the RadiantOne namespace. All queries below this point are cached."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Enter a Time to Live (in minutes). This is the amount of time that entries should remain in cache. After the time has been reached, the entry is removed from the cache. The next request for the entry is sent to the underlying data store(s). The result of the request is then stored in the memory cache again. This value is specified in minutes. The default is 60 (1 hour)."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"OK"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Save"}]},{"type":"text","value":" (located in the top right hand corner) to save your settings."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nThe user and ACI information are also part of the query. This is why it was mentioned above that the query cache is sensitive to syntax. If User A issues a query, and then User B issued a query asking for the exact same information, this would count as two queries in the Query Cache."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"populating-the-memory-cache"},"children":[{"type":"text","value":"Populating the Memory Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"entry-cache"},"children":[{"type":"text","value":"Entry Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The entry memory cache is filled as the RadiantOne service receives queries. The first time the server receives a request for an entry, the underlying data store(s) is queried and the entry is returned. The entry is stored in the entry memory cache. The entry remains in cache for the time specified in the Time to Live setting."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"query-cache"},"children":[{"type":"text","value":"Query Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The query memory cache is filled as the RadiantOne service receives queries. The first time the server receives a request, the query is added to the query memory cache, and the underlying data store(s) is queried to retrieve the entries. The entries resulting from the query are also stored in the cache."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"refreshing-the-memory-cache"},"children":[{"type":"text","value":"Refreshing the Memory Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A time-to-live parameter can be set for both the entry cache and the query cache. The time starts when the entry/query is added into memory. Once the time-to-live value is reached, the entry/query is removed from the cache. The next time a query is received for the entry, RadiantOne issues a query to the underlying store(s), retrieves the latest value and the entry is stored in the entry memory cache and/or the query memory cache again."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"You also have the option to flush the entire memory cache from the Main Control Panel > Settings Tab > Server Front End section > Memory Cache section (requires "},{"type":"element","tagName":"a","properties":{"href":"00-preface#expert-mode"},"children":[{"type":"text","value":"Expert Mode"}]},{"type":"text","value":"). On the right side, click on the “Flush All” button next to the type of cache you are interested in clearing."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 491px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 36.36363636363637%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdyhIFf/xAAWEAADAAAAAAAAAAAAAAAAAAAAECH/2gAIAQEAAQUCUP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABgQAAMBAQAAAAAAAAAAAAAAAAABIRFh/9oACAEBAAE/IZ0Q6eo//9oADAMBAAIAAwAAABD8D//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/EEf/xAAYEAEBAQEBAAAAAAAAAAAAAAABEQBBIf/aAAgBAQABPxBaLxzATwwdhRjd/9k='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/077a3e3bb7be60eb66dd58a42f066725/f6c46/Image2.3.jpg","srcSet":["/static/077a3e3bb7be60eb66dd58a42f066725/c1cfe/Image2.3.jpg 275w","/static/077a3e3bb7be60eb66dd58a42f066725/f6c46/Image2.3.jpg 491w"],"sizes":"(max-width: 491px) 100vw, 491px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.3: Memory Cache Settings"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"persistent-cache-1"},"children":[{"type":"text","value":"Persistent Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Persistent cache is the cache image stored on disk. With persistent cache, the RadiantOne service can offer a guaranteed level of performance because the underlying data source(s) do not need to be queried and once the server starts, the cache is ready without having to “prime” with an initial set of queries. Also, you do not need to worry about how quickly the underlying data source can respond. What is unique about the persistent cache is if the RadiantOne service receives an update for information that is stored in the cache, the underlying data source(s) receives the update, and the persistent cache is refreshed automatically. In addition, you have the option of configuring real-time cache refreshes which automatically update the persistent cache image when data changes directly on the backend sources. For more details, please see "},{"type":"element","tagName":"a","properties":{"href":"#options-for-refreshing-the-persistent-cache"},"children":[{"type":"text","value":"Refreshing the Persistent Cache"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf you plan on caching (either entry memory cache or persistent cache) the branch in the tree that maps to an LDAP backend, you must list the operational attributes you want to be in the cache as “always requested”. Otherwise, the entry stored in cache would not have these attributes and clients accessing these entries may need them."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"disk-space-requirements"},"children":[{"type":"text","value":"Disk Space Requirements"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Initialization of a persistent cache happens in two phases. The first phase is to create an LDIF formatted file of the cache contents (if you already have an LDIF file, you have the option to use this existing file as opposed to generating a new one). The second phase is to initialize the cache with the LDIF file. After the first phase, RadiantOne prepares the LDIF file to initialize the cache. Therefore, you need to consider at least these two LDIF files and the amount of disk space to store the entries in cache."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Best practice would be to take four times the size of the LDIF file generated to determine the disk space that is required to initialize the persistent cache. For example, lab tests have shown 50 million entries (1KB or less in size) generates an LDIF file approximately 50 GB in size. So total disk space recommended to create the persistent cache for this example would be 200 GB."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"initializing-persistent-cache"},"children":[{"type":"text","value":"Initializing Persistent Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Persistent cache should be initialized during off-peak hours, or during scheduled downtime, since it is a CPU-intensive process and during the initialization queries are delegated to the backend data sources which might not be able to handle the load."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When initializing persistent cache, two settings you should take into consideration are paging and initializing cache from an encrypted file. These options are described in this section."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf you are using real-time refresh, make sure the cache refresh components are stopped before re-initializing or re-indexing a persistent cache."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"using-paging"},"children":[{"type":"text","value":"Using Paging"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Depending on the complexity of the virtual view, building the persistent cache image can take some time. Since the internal connections used by RadiantOne to build the persistent cache image are subject to the Idle Connection Timeout server setting, the cache initialization process might fail due to the connection being automatically closed by the server. To avoid cache initialization problems, it is recommended to use paging for internal connections. To use paging:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Navigate to the Main Control Panel > Settings tab > Server Front End > Supported Controls."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On the right, check the option to Enable Paged Results."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Save"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Navigate to the Main Control Panel > Settings tab > Server Backend > Internal Connections (requires "},{"type":"element","tagName":"a","properties":{"href":"00-preface#expert-mode"},"children":[{"type":"text","value":"Expert Mode"}]},{"type":"text","value":")."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On the right, check the option for Paged Results Control, page size: 1000."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Save"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"supporting-zipped-and-encrypted-ldif-files"},"children":[{"type":"text","value":"Supporting Zipped and Encrypted LDIF Files"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you are initializing persistent cache using an existing LDIFZ file, the security key used in RadiantOne (for attribute encryption) where the file was exported must be the same security key value used on the RadiantOne server that you are trying to import the file into."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you are creating a new LDIF file to initialize the persistent cache, you have the option to use an LDIFZ file which is a zipped and encrypted file format. This ensures that the data to be cached is not stored in clear in files required for the initialization process."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To use this option, you must have an LDIFZ encryption key configured. The security key is defined from the Main Control Panel > Settings Tab > Security > Attribute Encryption section."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Once the security key has been defined, check the option to “Use .ldifz (zipped and secure format)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 301px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 59.63636363636364%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEDAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7beEoTF//8QAGBAAAgMAAAAAAAAAAAAAAAAAAAECIDH/2gAIAQEAAQUCpLEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRABAAMBAQAAAAAAAAAAAAAAAQARIRCR/9oACAEBAAE/IZTPONLmM0bP/9oADAMBAAIAAwAAABDMD//EABYRAQEBAAAAAAAAAAAAAAAAACEBEP/aAAgBAwEBPxCjn//EABYRAQEBAAAAAAAAAAAAAAAAACEBEP/aAAgBAgEBPxCJn//EABwQAQACAwADAAAAAAAAAAAAAAEAESFRkTFxof/aAAgBAQABPxCm/B2C02dnv6lGjkZrkM0RqNFvRP/Z'); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/34e60315b412b44588ddc21ab52c6998/50ff8/Image2.4.jpg","srcSet":["/static/34e60315b412b44588ddc21ab52c6998/c1cfe/Image2.4.jpg 275w","/static/34e60315b412b44588ddc21ab52c6998/50ff8/Image2.4.jpg 301w"],"sizes":"(max-width: 301px) 100vw, 301px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.4: Using LDIFZ File to Initialize Persistent Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"options-for-refreshing-the-persistent-cache"},"children":[{"type":"text","value":"Options for Refreshing the Persistent Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are four categories of events that can invoke a persistent cache refresh. They are:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When changes occur through RadiantOne."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When changes occur outside of RadiantOne (directly on the backend source)."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Scheduling a periodic refresh of the persistent cache."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Each is described below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"changes-occurring-through-radiantone"},"children":[{"type":"text","value":"Changes Occurring Through RadiantOne"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If RadiantOne receives an update for an entry that is stored in a persistent cache, the following operations occur:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The entry in persistent cache is “locked” pending the update to the underlying source(s)."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The underlying source(s) receives the update from RadiantOne."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Upon successful update of the underlying source(s), RadiantOne updates the entry in the persistent cache."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The modified entry is available in the persistent cache."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"real-time-cache-refresh-based-on-changes-occurring-directly-on-the-backend-sources"},"children":[{"type":"text","value":"Real Time Cache Refresh Based on Changes Occurring Directly on the Backend Source(s)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When a change happens in the underlying source, connectors capture the change and send it to update the persistent cache. The connectors are managed by agents built into RadiantOne and changes flow through a message queue for guaranteed message delivery. The real-time refresh process is outlined below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 330px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 86.18181818181819%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAECAwQF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAQAC/9oADAMBAAIQAxAAAAHrRs1c3QNKEZBP/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEQIRH/2gAIAQEAAQUC02OcHf/EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/ASP/xAAVEQEBAAAAAAAAAAAAAAAAAAARIP/aAAgBAgEBPwFj/8QAFhAAAwAAAAAAAAAAAAAAAAAAADBB/9oACAEBAAY/Aio//8QAHBAAAgICAwAAAAAAAAAAAAAAAAERMUFRECGR/9oACAEBAAE/IZWbE99hUihM9MSJZ9KGeP/aAAwDAQACAAMAAAAQDAh8/8QAFREBAQAAAAAAAAAAAAAAAAAAIHH/2gAIAQMBAT8Qsf/EABURAQEAAAAAAAAAAAAAAAAAACBx/9oACAECAQE/EJH/xAAcEAACAgMBAQAAAAAAAAAAAAABEQAhMUFRgRD/2gAIAQEAAT8QJB3WLb8hhIooCR3U3sqO6XsKhs4xKhldkfoGBP/Z'); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/fcfb987b2f14c90c1e4657e7bc859f1f/4f5c6/Image2.5.jpg","srcSet":["/static/fcfb987b2f14c90c1e4657e7bc859f1f/c1cfe/Image2.5.jpg 275w","/static/fcfb987b2f14c90c1e4657e7bc859f1f/4f5c6/Image2.5.jpg 330w"],"sizes":"(max-width: 330px) 100vw, 330px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.5: Persistent Cache Refresh Architecture"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Persistent Cache Refresh Agents are started automatically once a persistent cache with real-time refresh is configured. Agents can run on any type of RadiantOne cluster node (follower or leaders) and there is only one agent running at any given time in a RadiantOne cluster. The agent doesn't consume a lot of memory, and they are not CPU-intensive, so there is no point in running multiple processes to distribute connectors on multiple nodes. One agent is enough per cluster and makes things simpler."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This type of refresh is described as “Real-time” in the Main Control Panel > Directory Namespace > Cache settings > Cache Branch > Refresh Settings tab (on the right). This is the recommended approach if a real-time refresh is needed."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"periodic-refresh"},"children":[{"type":"text","value":"Periodic Refresh"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In certain cases, if you know the data in the backends does not change frequently (e.g. once a day), you may not care about refreshing the persistent cache immediately when a change is detected in the underlying data source. In this case, a periodic refresh can be used."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you have built your view in either the Context Builder tab or Directory Namespace Tab, you can define the refresh interval after you’ve configured the persistent cache. The option to enable periodic refresh is on the Refresh Settings tab (on the right) for the selected persistent cache node. Once the periodic refresh is enabled, configure the interval using a CRON expression. Click the Assist button if you need help defining the CRON expression."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 974px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 36.72727272727273%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB2wUH/8QAFhAAAwAAAAAAAAAAAAAAAAAAARAS/9oACAEBAAEFAoD/AP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABkQAAMBAQEAAAAAAAAAAAAAAAABIRFhkf/aAAgBAQABPyFd/TKJSpaf/9oADAMBAAIAAwAAABBwD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQADAAMBAAAAAAAAAAAAAAEAESExQbHR/9oACAEBAAE/EADitvn9hdqTJX7Bp5P/2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/13ad91c36b1ed4d17f9deff7eab81bf0/083a5/Image2.6.jpg","srcSet":["/static/13ad91c36b1ed4d17f9deff7eab81bf0/c1cfe/Image2.6.jpg 275w","/static/13ad91c36b1ed4d17f9deff7eab81bf0/67061/Image2.6.jpg 550w","/static/13ad91c36b1ed4d17f9deff7eab81bf0/083a5/Image2.6.jpg 974w"],"sizes":"(max-width: 974px) 100vw, 974px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.6: Periodic Cache Refresh Settings"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"During each refresh interval, the periodic persistent cache refresh is performed based on the following high-level steps:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"RadiantOne generates an LDIF formatted file from the virtual view (bypassing the cache)."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf a backend data source is unreachable, RadiantOne attempts to re-connect one more time after waiting 5 seconds. The number of retries is dictated by the maxPeriodicRefreshRetryCount property defined in "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"/radiantone/<version>/<clusterName>/config/vds_server.conf"}]},{"type":"text","value":" in ZooKeeper."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{"start":2},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"(Optional) If a "},{"type":"element","tagName":"a","properties":{"href":"#add-validation-threshold"},"children":[{"type":"text","value":"validation threshold"}]},{"type":"text","value":" is defined, RadiantOne determines if the threshold defined has been exceeded. If it has, the persistent cache is not refreshed during this cycle."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"RadiantOne compares the LDIF file generated in step 1 to the current cache image and applies changes to the cache immediately as it goes through the comparison."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The periodic persistent cache refresh activity is logged into periodiccache.log. This file can be viewed and downloaded from Server Control Panel > Log Viewer. For details on this log, see the Logging and Troubleshooting Guide."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The rebuild process can be very taxing on your backends, and each time a new image is built you are putting stress on the data sources. This type of cache refresh deployment works well when the data doesn’t change too frequently and the volume of data is relatively small."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"configuring-persistent-cache-with-periodic-refresh"},"children":[{"type":"text","value":"Configuring Persistent Cache with Periodic Refresh"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Review the section on "},{"type":"element","tagName":"a","properties":{"href":"#periodic-refresh"},"children":[{"type":"text","value":"periodically refreshing the cache"}]},{"type":"text","value":" to ensure the persistent cache is updated to match your needs. If you plan on refreshing the cache image periodically on a defined schedule, this would be the appropriate cache configuration option. This type of caching option leverages the internal RadiantOne Universal Directory storage for the cache image."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To configure persistent cache with Periodic refresh"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On the Directory Namespace tab of the Main Control Panel, click the Cache node."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On the right side, browse to the branch in the RadiantOne namespace that you would like to store in persistent cache and click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"OK"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Create Persistent Cache"}]},{"type":"text","value":". The configuration process begins. Once it completes, click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"OK"}]},{"type":"text","value":" to exit the window."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Refresh Settings"}]},{"type":"text","value":" tab."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Select the Periodic Refresh option."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Enter the "},{"type":"element","tagName":"a","properties":{"href":"#periodic-refresh-cron-expression"},"children":[{"type":"text","value":"CRON expression"}]},{"type":"text","value":" to define the refresh interval."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"(Optional) Define a "},{"type":"element","tagName":"a","properties":{"href":"#delete-validation-threshold"},"children":[{"type":"text","value":"Delete Validation Threshold"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"(Optional) Define an "},{"type":"element","tagName":"a","properties":{"href":"#add-validation-threshold"},"children":[{"type":"text","value":"Add Validation Threshold"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Save"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Initialize"}]},{"type":"text","value":" to start the initialization process."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are two options for initializing the persistent cache: Creating a new LDIF file or initializing from an existing LDIF file. Each is described below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"create-an-ldif-from-a-snapshot"},"children":[{"type":"text","value":"Create an LDIF from a Snapshot"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If this is the first time you’ve initialized the persistent cache, then you should choose this option. An LDIF formatted file is generated from the virtual view and then imported into the local RadiantOne Universal Directory store."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Initialize from an Existing LDIF File"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you’ve initialized the persistent cache before and the LDIF file was created successfully from the backend source(s) (and the data from the backend(s) has not changed since the generation of the LDIF file), then you can choose to use that existing file. The persisting of the cache occurs in two phases. The first phase generates an LDIF file with the data returned from the queries to the underlying data source(s). The second phase imports the LDIF file into the local RadiantOne Universal Directory store. If there is a failure during the second phase, and you must re-initialize the persistent cache, you have the option to choose the LDIF file (that was already built during the first phase) instead of having to re-generate it (as long as the LDIF file generated successfully). You can click browse and navigate to the location of the LDIF. The LDIF files generated are in <RLI_HOME><instance_name>\\ldif\\import."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you have a large data set and generated multiple LDIF files for the purpose of initializing the persistent cache (each containing a subset of what you want to cache), name the files with a suffix of “_2”, “_3”…etc. For example, let’s say the initial LDIF file (containing the first subset of data you want to import) is named cacheinit.ldif. After this file has been imported, the process attempts to find cacheinit_2.ldif, then cacheinit_3.ldif…etc. Make sure all files are located in the same place so the initialization process can find them."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"After you choose to either generate or re-use an LDIF file, click Finish and cache initialization begins. Cache initialization is launched as a task and can be viewed and managed from the Tasks Tab in the Server Control Panel associated with the RadiantOne leader node. Therefore, you do not need to wait for the initialization to finish before exiting the initialization window."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"After the persistent cache is initialized, queries are handled locally by the RadiantOne service and no longer be sent to the backend data source(s). For information about properties associated with persistent cache, please see "},{"type":"element","tagName":"a","properties":{"href":"#persistent-cache-properties"},"children":[{"type":"text","value":"Persistent Cache Properties"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"periodic-refresh-cron-expression"},"children":[{"type":"text","value":"Periodic Refresh CRON Expression"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If periodic refresh is enabled, you must define the refresh interval in this property. For example, if you want the persistent cache refreshed every day at 12:00 PM, the CRON expression is:\r\n0 0 12 1/1 * ? *\r\nClick "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Assist"}]},{"type":"text","value":" if you need help defining the CRON expression."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 407px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 36%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAWEAADAAAAAAAAAAAAAAAAAAAAEBH/2gAIAQEAAQUCVP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAAMAAAAAAAAAAAAAAAAAAAAQMf/aAAgBAQAGPwJQ/8QAFxABAQEBAAAAAAAAAAAAAAAAAREAQf/aAAgBAQABPyGZYWLiut//2gAMAwEAAgADAAAAEPAP/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8QZ//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ECf/xAAYEAEAAwEAAAAAAAAAAAAAAAABABFxIf/aAAgBAQABPxAHJdYAwBdGpP/Z'); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/c131e18862496130c8cb2d88ff0a549b/fabf6/Image2.7.jpg","srcSet":["/static/c131e18862496130c8cb2d88ff0a549b/c1cfe/Image2.7.jpg 275w","/static/c131e18862496130c8cb2d88ff0a549b/fabf6/Image2.7.jpg 407w"],"sizes":"(max-width: 407px) 100vw, 407px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.7: CRON Expression Editor"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"delete-validation-threshold"},"children":[{"type":"text","value":"Delete Validation Threshold"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For details on how the periodic persistent cache refresh process works, see "},{"type":"element","tagName":"a","properties":{"href":"#periodic-refresh"},"children":[{"type":"text","value":"Periodic Refresh"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"You can define a threshold to validate the generated LDIF file/image prior to RadiantOne executing the cache refresh process. The threshold is a percentage of the total entries."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To define a granular threshold for delete operations, indicate the percentage in the Delete Validation Threshold. For example, if Delete Validation Threshold contains a value of 50, it means if the generated LDIF image contains at least 50% fewer entries than the current cache image, the periodic persistent cache refresh is aborted for the current refresh cycle."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If a validation threshold is configured, the threshold is checked."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"add-validation-threshold"},"children":[{"type":"text","value":"Add Validation Threshold"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For details on how the periodic persistent cache refresh process works, see "},{"type":"element","tagName":"a","properties":{"href":"#periodic-refresh"},"children":[{"type":"text","value":"Periodic Refresh"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"You can define a threshold to validate the generated LDIF file/image prior to RadiantOne executing the cache refresh process. The threshold is a percentage of the total entries."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To define a granular threshold for add operations, indicate the percentage in the Add Validation Threshold. For example, if Add Validation Threshold contains a value of 50, it means if the generated LDIF image contains 50% more entries than the current cache image, the periodic persistent cache refresh is aborted for the current refresh cycle."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"configuring-persistent-cache-with-real-time-refresh"},"children":[{"type":"text","value":"Configuring Persistent Cache with Real-Time Refresh"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you plan on automatically refreshing the persistent cache as changes happen on the backend data sources, this would be the recommended cache configuration option. This type of caching option leverages the RadiantOne Universal Directory storage for the cache image."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you choose a real-time refresh strategy, there are two terms you need to become familiar with:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Cache Dependency – cache dependencies are all objects/views related to the view that is configured for persistent cache. A cache dependency is used by the cache refresh process to understand all the different objects/views that need to be updated based on changes to the backend sources."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Cache Refresh Topology – a cache refresh topology is a graphical representation of the flow of data needed to refresh the cache. The topology includes an object/icon that represents the source (the backend object where changes are detected from), the queue (the temporary storage of the message), and the cache destination. Cache refresh topologies can be seen from the Main Control Panel > PCache Monitoring tab."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Cache dependencies and the refresh topology are generated automatically during the cache configuration process."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you have deployed multiple nodes in a cluster, to configure and initialize the persistent cache, you must be on the current RadiantOne leader node. To find out the leader status of the nodes, go to the Dashboard tab > Overview section in the Main Control Panel and locate the node with a yellow triangle icon."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To configure persistent cache with real-time refresh:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Go to the Directory Namespace Tab of the Main Control Panel associated with the current RadiantOne leader node."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click the Cache node."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On the right side, browse to the branch in the RadiantOne namespace that you would like to store in persistent cache and click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"OK"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nFor proxy views of LDAP backends, you must select the root level to start the cache from. Caching only a sub-container of a proxy view is not supported."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{"start":4},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click Create Persistent Cache. The configuration process begins. Once it completes, click OK to exit the window."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On the Refresh Settings tab, select the Real-time refresh option."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf your virtual view is joined with other virtual views you must cache the secondary views first. Otherwise, you are unable to configure the real-time refresh and will see the following message. A Diagnostic button is also shown and provides more details about which virtual views require caching."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 385px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 34.90909090909091%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB25MthH//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwGq/8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAGRAAAQUAAAAAAAAAAAAAAAAAABARYZGh/9oACAEBAAE/IbHnE//aAAwDAQACAAMAAAAQ89//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPxCI/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8QpT//xAAYEAEBAQEBAAAAAAAAAAAAAAAhAQARYf/aAAgBAQABPxDjXwQ0rjiQW7//2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/f5043d9b63fe4007f74fe26bf0e54cea/47ca8/Image2.8.jpg","srcSet":["/static/f5043d9b63fe4007f74fe26bf0e54cea/c1cfe/Image2.8.jpg 275w","/static/f5043d9b63fe4007f74fe26bf0e54cea/47ca8/Image2.8.jpg 385w"],"sizes":"(max-width: 385px) 100vw, 385px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.8: Caching secondary views message"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{"start":6},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Configure any needed connectors. Please see the section titled "},{"type":"element","tagName":"a","properties":{"href":"#configuring-source-connectors"},"children":[{"type":"text","value":"Configuring Source Connectors"}]},{"type":"text","value":" for steps."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Save"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On the Refresh Settings tab, click Initialize to initialize the persistent cache."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are two options for initializing a persistent cache. Each is described below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Create an LDIF File"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If this is the first time you’ve initialized the persistent cache, choose this option. An LDIF formatted file is generated from the virtual view and then imported into the cache."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"**Using an Existing LDIF **"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you’ve initialized the persistent cache before and the LDIF file was created successfully from the backend source(s) (and the data from the backend(s) has not changed since the generation of the LDIF file), then you can choose this option to use that existing file. The persisting of the cache occurs in two phases. The first phase generates an LDIF file with the data returned from the queries to the underlying data source(s). The second phase imports the LDIF file into the local RadiantOne Universal Directory store. If there is a failure during the second phase, and you must re-initialize the persistent cache, you have the option to choose the LDIF file (that was already built during the first phase) instead of having to re-generate it (as long as the LDIF file generated successfully). You can click browse and navigate to the location of the LDIF. The LDIF files generated are in "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"<RLI_HOME>\\<vds_server>\\ldif\\import"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you have a large data set and generated multiple LDIF files for the purpose of initializing the persistent cache (each containing a subset of what you want to cache), name the files with a suffix of “_2”, “_3”…etc. For example, let’s say the initial LDIF file (containing the first subset of data you want to import) is named cacheinit.ldif. After this file has been imported, the process attempts to find cacheinit_2.ldif, then cacheinit_3.ldif…etc. Make sure all files are located in the same place so the initialization process can find them."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{"start":9},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"OK"}]},{"type":"text","value":". The cache initialization process begins. The cache initialization is performed as a task and can be viewed and managed from the Tasks Tab in the Server Control Panel associated with the RadiantOne leader node. Therefore, you do not need to wait for the initialization to finish before exiting the initialization window."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The view(s) is now in the persistent cache. Queries are handled locally by RadiantOne and are no longer sent to the backend data source(s). Real-time cache refresh has been configured. For information about properties associated with persistent cache, please see "},{"type":"element","tagName":"a","properties":{"href":"#persistent-cache-properties"},"children":[{"type":"text","value":"Persistent Cache Properties"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"configuring-source-connectors"},"children":[{"type":"text","value":"Configuring Source Connectors"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Configuring connectors involves deciding how you want to detect changes from your backend(s). By default, all "},{"type":"element","tagName":"a","properties":{"href":"#directory-connectors"},"children":[{"type":"text","value":"directory connectors"}]},{"type":"text","value":" and "},{"type":"element","tagName":"a","properties":{"href":"#custom-connectors"},"children":[{"type":"text","value":"custom connectors"}]},{"type":"text","value":" (only custom connectors included in the RadiantOne install) are configured and started immediately without further configuration. For databases, configure the connector to use the desired change detection mechanism."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nAll connectors leverage the connection pooling settings defined from the Main Control Panel > Settings tab. In other words, the connector opens a connection to the data source to pick up changes and keeps the connection open so when the next interval passes a new connection does not need to be created."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{"id":"database-connectors"},"children":[{"type":"text","value":"Database Connectors"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For database backends (JDBC-accessible), the change detection options are:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"#db-changelog"},"children":[{"type":"text","value":"Changelog"}]},{"type":"text","value":" – This connector type relies on a database table that contains all changes that have occurred on the base tables (that the RadiantOne virtual view is built from). This typically involves having triggers on the base tables that write into the log/changelog table. However, an external process may be used instead of triggers. The connector picks up changes from the changelog table based on a specified interval which is 10 seconds by default."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"#db-timestamp"},"children":[{"type":"text","value":"Timestamp"}]},{"type":"text","value":" – This connector type has been validated against Oracle, SQL Server, MySQL, MariaDB, PostgreSQL, and Apache Derby. The database table must have a primary key defined for it and an indexed column that contains a timestamp/date value. This value must be maintained and modified accordingly for each record that is updated."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For Oracle databases, the timestamp column type must be one of the following: \"TIMESTAMP\", \"DATE\", \"TIMESTAMP WITH TIME ZONE\", \"TIMESTAMP WITH LOCAL TIME ZONE\"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For SQL Server database, the timestamp column type must be one of the following: \"SMALLDATETIME\", \"DATETIME\", \"DATETIME2\""}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For MYSQL or MariaDB databases, the timestamp column type must be one of the following: \"TIMESTAMP\", \"DATETIME\""}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For PostgreSQL databases, the timestamp column type must be one of the following: \"TIMESTAMP\", \"timestamp without time zone” (equivalent to timestamp), “TIMESTAMPTZ”, “timestamp with time zone” (equivalent to timestamptz)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For Derby databases, the timestamp column type must be: \"TIMESTAMP\""}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The DB Timestamp connector leverages the timestamp column to determine which records have changed since the last polling interval. This connector type does not detect delete operations. If you have a need to detect and propagate delete operations from the database, you should choose a different connector type like DB Changelog or DB Counter."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"#db-counter"},"children":[{"type":"text","value":"Counter"}]},{"type":"text","value":" - This connector type is supported for any database table that has an indexed column that contains a sequence-based value that is automatically maintained and modified for each record that is added/updated. This column must be one of the following types: BIGINT, DECIMAL, INTEGER, or NUMERIC. If DECIMAL or NUMERIC are used, they should be declared without numbers after the dot: DECIMAL(6,0) not as DECIMAL(6,2). The DB Counter connector leverages this column to determine which records have changed since the last polling interval. This connector type can detect delete operations as long as the table has a dedicated “Change Type” column that indicates one of the following values: insert, update, delete. If the value is empty or something other than insert, update, or delete, an update operation is assumed."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf none of these options are useable with your database, use a periodic cache refresh instead of real-time."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{"id":"db-changelog"},"children":[{"type":"text","value":"DB Changelog"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"RadiantOne can generate the SQL scripts which create the configuration needed to support the DB Changelog Connector. The scripts can be generated in the Main Control Panel. The following scripts are generated."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"create_user.sql – Reminds you to have your DBA manually create a user account to be associated with the connector."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"create_capture.sql - Creates the log table and the triggers on the base table."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"drop_capture.sql - Drops the triggers and the log table."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"Note: for some databases the file is empty."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"drop_user.sql - Drops the log table user and schema."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Note: for some databases the file is empty."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"connector-configuration"},"children":[{"type":"text","value":"Connector Configuration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This section describes generating and executing the scripts in the Main Control Panel. The following steps assume the database backend has a changelog table that contains changed records that need to be updated in the persistent cache. The changelog table must have two key columns named RLICHANGETYPE and RLICHANGEID. RLICHANGETYPE must indicate insert, update or delete, dictating what type of change was made to the record. RLICHANGEID must be a sequence-based, auto-incremented INTEGER that contains a unique value for each record. The DB Changelog connector uses RLICHANGEID to maintain a cursor to keep track of processed changes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To configure DB Changelog connector:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nThese instructions assume you want to apply the SQL scripts immediately and you already have a user account in the database to use for the connector."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"From the Main Control Panel > Directory Namespace Tab, select the configured persistent cache branch below the Cache node."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"On the right side, select the Refresh Settings tab."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"When the Real-time refresh type is selected, the connectors appear in a table below. Select a connector and click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Configure"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Select DB Changelog from the Connector Type drop-down list."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"5.Enter the log table name using the proper syntax for your database (e.g. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"<USER>"}]},{"type":"text","value":"."},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"<TABLE>_LOG)"}]},{"type":"text","value":". If you used "},{"type":"element","tagName":"a","properties":{"href":"#log-table-name-syntax"},"children":[{"type":"text","value":"RadiantOne to generate the SQL scripts"}]},{"type":"text","value":" for configuring the changelog components in the database, you can view the scripts to see the exact table name. Otherwise, contact your DBA for the log table name."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nChange the value for this property only if you are creating the log table manually and the capture connector does not calculate the log table name correctly. Be sure to use the "},{"type":"element","tagName":"a","properties":{"href":"#log-table-name-syntax"},"children":[{"type":"text","value":"correct syntax"}]},{"type":"text","value":" if you change the value."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{"start":6},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Indicate the user name and password for the connector’s dedicated credentials for connecting to the log table. If you do not have the user name and password, contact your DBA for the credentials. An example is shown below."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 64.72727272727272%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAd1OgSSf/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAECESEx/9oACAEBAAEFAsH4iK1Dvv8A/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQMBAT8BV//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABsQAAMBAAMBAAAAAAAAAAAAAAABESExQVGx/9oACAEBAAE/IUngnQTN+FZybCjUynB//9oADAMBAAIAAwAAABDw7//EABYRAQEBAAAAAAAAAAAAAAAAAAERAP/aAAgBAwEBPxBIx0b/xAAXEQADAQAAAAAAAAAAAAAAAAAAASER/9oACAECAQE/EFaaj//EABoQAQEBAQADAAAAAAAAAAAAAAERADFBUWH/2gAIAQEAAT8QbaMQuH2FzPnb8ZpOHA5voaLbU7v/2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/c0f14ec575e498b90d1e10cd2ce16fc3/b966c/Image2.9.jpg","srcSet":["/static/c0f14ec575e498b90d1e10cd2ce16fc3/c1cfe/Image2.9.jpg 275w","/static/c0f14ec575e498b90d1e10cd2ce16fc3/67061/Image2.9.jpg 550w","/static/c0f14ec575e498b90d1e10cd2ce16fc3/b966c/Image2.9.jpg 624w"],"sizes":"(max-width: 624px) 100vw, 624px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.9: DB Changelog Connector Configuration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{"start":7},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Next"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When the connector has been configured, click Next again."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Select "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Apply Now"}]},{"type":"text","value":". Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Next"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nSelecting Apply Now creates and executes the SQL scripts. If you choose to apply later, the scripts can be downloaded to be reviewed and applied by the DBA directly on the database server."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Next"}]},{"type":"text","value":" and then click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Finish"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"After all connectors are configured, click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Save"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nThe Execute DB Configure Scripts and Execute DB Deconfigure Scripts buttons become available when you finish configuring the connector. Execute DB Configure Scripts runs create_capture.sql. Execute DB Deconfigure Scripts runs drop_capture.sql. The location that RadiantOne looks for these scripts in cannot be changed."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 478px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 47.63636363636364%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQCBf/EABQBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAe4hIXMiv//EABkQAAMAAwAAAAAAAAAAAAAAAAABEQMQMv/aAAgBAQABBQLUKysx8f/EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/Aaf/xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPwGH/8QAFxAAAwEAAAAAAAAAAAAAAAAAABAxQf/aAAgBAQAGPwJaUq//xAAcEAACAgIDAAAAAAAAAAAAAAAAAWGRESFBUYH/2gAIAQEAAT8h306HlrnwUrE6ydY7aZ2f/9oADAMBAAIAAwAAABA03//EABYRAQEBAAAAAAAAAAAAAAAAAAABIf/aAAgBAwEBPxBmx//EABYRAQEBAAAAAAAAAAAAAAAAAAABIf/aAAgBAgEBPxBs1//EABsQAQACAwEBAAAAAAAAAAAAAAEAESFBUbFx/9oACAEBAAE/EO/hhMbRvYpmH1hqO7tGo90REq3K3uf/2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/3b45d000341279a3f2aae8422b0e4c16/74f5b/Image2.10.jpg","srcSet":["/static/3b45d000341279a3f2aae8422b0e4c16/c1cfe/Image2.10.jpg 275w","/static/3b45d000341279a3f2aae8422b0e4c16/74f5b/Image2.10.jpg 478w"],"sizes":"(max-width: 478px) 100vw, 478px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.10: The Execute DB Configure and Deconfigure buttons"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{"start":12},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Go to Main Control Panel > PCache Monitoring tab to start connectors, configure "},{"type":"element","tagName":"a","properties":{"href":"#connector-properties"},"children":[{"type":"text","value":"connector properties"}]},{"type":"text","value":" and manage and monitor the persistent cache refresh process."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf you make changes to the DB Changelog Connector configuration, restart the connector on the PCache Monitoring tab. Select the icon representing the database backend and click Stop. Then click Start to restart it."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"log-table-name-syntax"},"children":[{"type":"text","value":"Log Table Name Syntax"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Proper syntax for the Log Table Name must include both the schema name and the table name separated with a period. Values for this property may contain quote marks as required by the database. In most cases, the double quote mark (“) is used, but some databases use a single quote (‘) or back quote (`). The following examples explain the property’s syntax and usage."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Example 1:\r\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"For Postgres, if the schema is rli_con, and log table name is test_log, the property should be one of the following."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nBy default, Postgres uses lower-case table names."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"rli_con.test_log\r\nor with optional quoting:\r\n\"rli_con\".\"test_log\""}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Example 2:\r\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"For SQL Server, if the schema is RLI_CON, and log table name is TEST_LOG, the property should be one of the following."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nBy default, many databases, including SQL Server, use upper-case table names."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"RLI_CON.TEST_LOG "}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"RLI_CON.TEST_LOG "}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Or with optional quoting:"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"\"RLI_CON\".\"TEST_LOG\""}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"\"RLI_CON\".\"TEST_LOG\""}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!note]\r\nIf this name is the same as the log name in the database, leave the property empty."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Example 3:\r\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"If schema and/or table name contain mixed-case characters, they must be quoted. For example, if the schema is Rli_Con, and log table name is Test_Log, the property should be as follows."}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"\"Rli_con\".\"Test_log\""}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"\"Rli_con\".\"Test_log\""}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{"id":"db-timestamp"},"children":[{"type":"text","value":"DB Timestamp"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The following steps assume your backend database table has a primary key defined and contains a timestamp column. The timestamp column name is required for configuring the connector. The timestamp column database types supported are described in the "},{"type":"element","tagName":"a","properties":{"href":"#database-connectors"},"children":[{"type":"text","value":"Database Connectors"}]},{"type":"text","value":" section."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nThis connector type does not detect delete operations. If you need to detect delete operations from the database, you should choose a different connector type."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"From the Main Control Panel > Directory Namespace Tab, select the configured persistent cache branch below the Cache node."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On the right side, select the Refresh Settings tab."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When the Real-time refresh type is selected, the connectors appear in a table below. Select a connector and click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Configure"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Select DB Timestamp from the Connector Type drop-down list."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Indicate the column name in the database table that contains the timestamp. An example is shown below."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 539px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 33.09090909090909%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAd6CQH//xAAXEAADAQAAAAAAAAAAAAAAAAAAAQIx/9oACAEBAAEFAh4qP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABcQAQEBAQAAAAAAAAAAAAAAAAEAIUH/2gAIAQEAAT8hMnqBO3//2gAMAwEAAgADAAAAEHw//8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAx/9oACAEDAQE/EHIb/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAx/9oACAECAQE/EDZL/8QAFxABAQEBAAAAAAAAAAAAAAAAAREAcf/aAAgBAQABPxCBMIzQC6tK6b//2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/f327511c7abb3a2195bfe7cc4a378ed0/4a972/Image2.11.jpg","srcSet":["/static/f327511c7abb3a2195bfe7cc4a378ed0/c1cfe/Image2.11.jpg 275w","/static/f327511c7abb3a2195bfe7cc4a378ed0/4a972/Image2.11.jpg 539w"],"sizes":"(max-width: 539px) 100vw, 539px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.11: DB Timestamp Connector Configuration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{"start":6},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"OK"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"After all connectors are configured, click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Save"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The connectors are started automatically once they are configured."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Go to Main Control Panel > PCache Monitoring tab to configure connector properties and manage and monitor the persistent cache refresh process."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf you need to make changes to the timestamp column name, manually restart the connector and reset the cursor. This can be done from the PCache Monitoring tab. Select the icon representing the database backend and click Stop. Then click Start to restart it. Then click Reset Cursor."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{"id":"db-counter"},"children":[{"type":"text","value":"DB Counter"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The following steps assume your database backend table contains an indexed column that contains a sequence-based value that is automatically maintained and modified for each record that is added, updated or deleted. The DB Counter connector uses this column to maintain a cursor to keep track of processed changes. The counter column database types supported are described in the "},{"type":"element","tagName":"a","properties":{"href":"#database-connectors"},"children":[{"type":"text","value":"Database Connectors"}]},{"type":"text","value":" section."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"From the Main Control Panel > Directory Namespace Tab, select the configured persistent cache branch below the Cache node."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On the right side, select the Refresh Settings tab."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When the Real-time refresh type is selected, the connectors appear in a table below. Select a connector and click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Configure"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Select DB Counter from the Connector Type drop-down list."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Enter a value in the Change Type Column field. This value should be the database table column that contains the information about the type of change (insert, update or delete). If the column doesn’t have a value, an update operation is assumed."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Enter the column name in the database table that contains the counter. An example is shown below."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 404px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 50.909090909090914%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHdFVKkhf/EABgQAAIDAAAAAAAAAAAAAAAAAAABAhAx/9oACAEBAAEFAh3LEf/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABsQAAIBBQAAAAAAAAAAAAAAAAABERAhMVFh/9oACAEBAAE/IUlo4Ipc8mJ//9oADAMBAAIAAwAAABDPz//EABYRAQEBAAAAAAAAAAAAAAAAAAEQIf/aAAgBAwEBPxBwn//EABYRAQEBAAAAAAAAAAAAAAAAAAEQIf/aAAgBAgEBPxA1n//EABoQAQADAAMAAAAAAAAAAAAAAAEAESExQVH/2gAIAQEAAT8QtNiAAocwCaFy31mBoemYVZs//9k='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/89e8617c97009b560e647ad76531e0ab/24ff0/Image2.12.jpg","srcSet":["/static/89e8617c97009b560e647ad76531e0ab/c1cfe/Image2.12.jpg 275w","/static/89e8617c97009b560e647ad76531e0ab/24ff0/Image2.12.jpg 404w"],"sizes":"(max-width: 404px) 100vw, 404px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.12: DB Counter Connector Configuration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{"start":7},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"OK"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"After all connectors are configured, click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Save"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The connectors are started automatically once they are configured."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Go to Main Control Panel > PCache Monitoring tab to configure connector properties and manage and monitor the persistent cache refresh process."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf you need to make changes to the Counter Column name, manually restart the connector and reset the cursor. This can be done from the PCache Monitoring tab. Select the icon representing the database backend and click Stop. Then click Start to restart it. Then click Reset Cursor."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{"id":"database-connector-failover"},"children":[{"type":"text","value":"Database Connector Failover"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This section describes the failover mechanism for the database connectors."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nThe backend servers must be configured for multi-master replication. Please check the vendor documentation for assistance with configuring replication for your backends."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The database connectors leverage the failover server that has been configured for the data source. When you configure a data source for your backend database, select a failover database server from the drop-down list. The failover server must be configured as a RadiantOne data source. See the screen shot below for how to indicate a failover server for the Data Sources from the Main Control Panel."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHbpcgf/8QAFRABAQAAAAAAAAAAAAAAAAAAACH/2gAIAQEAAQUCRH//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwGI/8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAGRAAAwADAAAAAAAAAAAAAAAAABEhAXHw/9oACAEBAAE/IcJ05DQ//9oADAMBAAIAAwAAABD/AN//xAAWEQADAAAAAAAAAAAAAAAAAAAAARH/2gAIAQMBAT8QbhT/xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQIBAT8QykP/xAAaEAEAAwADAAAAAAAAAAAAAAABABExQXGB/9oACAEBAAE/EBkKo4nQhHofJ//Z'); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/aac137cad0f812f04825c1f1e2ed85ba/b966c/Image2.14.jpg","srcSet":["/static/aac137cad0f812f04825c1f1e2ed85ba/c1cfe/Image2.14.jpg 275w","/static/aac137cad0f812f04825c1f1e2ed85ba/67061/Image2.14.jpg 550w","/static/aac137cad0f812f04825c1f1e2ed85ba/b966c/Image2.14.jpg 624w"],"sizes":"(max-width: 624px) 100vw, 624px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.14: Configuring Failover Servers for the Backend Database"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If a connection cannot be made to the primary server, the connector tries to connect to the failover server configured in the data source. If a connection to both the primary and failover servers fails, the retry count goes up. The connector repeats this process until the value configured in "},{"type":"element","tagName":"a","properties":{"href":"#max-retries-on-connection-error-for-database-connectors"},"children":[{"type":"text","value":"Max Retries on Connection Error"}]},{"type":"text","value":" is reached. There is no automatic failback, meaning once the primary server is back online, the connector doesn’t automatically go back to it."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{"id":"re-configuring-database-connectors"},"children":[{"type":"text","value":"Re-configuring Database Connectors"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"By re-configuring the connector, you can change the connector type."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The connector can be re-configured from the Main Control Panel > Directory Namespace Tab. Navigate below the Cache node and select the persistent cache branch configured for auto-refresh. On the right side, select the Refresh Settings tab. Select the connector you want to re-configure and choose Configure."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To change the connector user password, for a connector currently using DB Changelog, enter the user name and password in the Credentials section."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 359px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 63.63636363636363%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB3WkkisP/xAAYEAADAQEAAAAAAAAAAAAAAAAAAQIQEf/aAAgBAQABBQIe0+SrP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAQEBAAAAAAAAAAAAAAAAAAEQIP/aAAgBAQAGPwLCz//EABoQAAMBAAMAAAAAAAAAAAAAAAABMSEQEVH/2gAIAQEAAT8hSXhhQWqcZxDsUP/aAAwDAQACAAMAAAAQrB//xAAWEQEBAQAAAAAAAAAAAAAAAAAAETH/2gAIAQMBAT8QxX//xAAVEQEBAAAAAAAAAAAAAAAAAAAQMf/aAAgBAgEBPxCn/8QAGRABAQEAAwAAAAAAAAAAAAAAAREAIYGh/9oACAEBAAE/EHrwcCh4xKIMMcsUzZmtJ3v/2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/b4f303aae4294c121456c065e47a5802/f86e9/Image2.15.jpg","srcSet":["/static/b4f303aae4294c121456c065e47a5802/c1cfe/Image2.15.jpg 275w","/static/b4f303aae4294c121456c065e47a5802/f86e9/Image2.15.jpg 359w"],"sizes":"(max-width: 359px) 100vw, 359px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.15: Editing DB Changelog Connector Configuration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To change the detection mechanism from DB Changelog to another method, select the type from the Connector Type drop-down menu. Enter values as needed for the properties specific to the new connector type and click Next. Click Next in the confirmation window to confirm that you want the connector reconfigured. Click Next to confirm that the connector has been reconfigured. Click Finish."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{"id":"directory-connectors"},"children":[{"type":"text","value":"Directory Connectors"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For directory backends (LDAP-accessible including RadiantOne Universal Directory and Active Directory), the default connectors are configured and started automatically. Go to Main Control Panel > PCache Monitoring tab to configure connector properties and manage and monitor the persistent cache refresh process."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf you are using a persistent cache on a proxy view of a local RadiantOne Universal Directory store, or a nested persistent cache view (a cached view used in another cached view), the connector type is noted as HDAP Trigger. This is a special trigger mechanism that publishes the changes directly into the queue to automatically invoke the refresh to all associated persistent cache layers. This change detection mechanism doesn’t require a connector process (or agents). If a RadiantOne service is virtualizing an external (non-local) RadiantOne Universal Directory store, and a persistent cache is configured for the view, this is considered an “LDAP backend” and the refresh connector can be configured for either changelog or persistent search (whatever is enabled/supported on the remote RadiantOne server) as described below."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{"id":"ldap-directories"},"children":[{"type":"text","value":"LDAP Directories"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For LDAP backends that support both Changelog and Persistent Search, you can configure the connector from the Main Control Panel -> Directory Namespace Tab. Navigate below the Cache node and select the persistent cache branch configured for auto-refresh. On the right side, select the Refresh Settings tab. Select the connector you want to configure and choose Configure. Choose either the LDAP option (for Changelog) or Persistent Search and click OK."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 452px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 29.454545454545457%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAd2CQH//xAAWEAEBAQAAAAAAAAAAAAAAAAAAATH/2gAIAQEAAQUCXI//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAVEAEBAAAAAAAAAAAAAAAAAAAAIf/aAAgBAQAGPwJFf//EABoQAAICAwAAAAAAAAAAAAAAAAABESExUWH/2gAIAQEAAT8hrQ76DuMJP//aAAwDAQACAAMAAAAQD/8A/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAEx/9oACAEDAQE/ELiP/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAEx/9oACAECAQE/EJqv/8QAGRABAAIDAAAAAAAAAAAAAAAAAQAhETFR/9oACAEBAAE/EBMKdQ2ZKmnron//2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/8e941729f4e14a53060b02ada9a0fe0b/56a76/Image2.16.jpg","srcSet":["/static/8e941729f4e14a53060b02ada9a0fe0b/c1cfe/Image2.16.jpg 275w","/static/8e941729f4e14a53060b02ada9a0fe0b/56a76/Image2.16.jpg 452w"],"sizes":"(max-width: 452px) 100vw, 452px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.16: LDAP Directory Connector Types"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Changelog"}]},{"type":"text","value":" - the connector leverages a changelog that has been enabled on the backend directory. The connector picks up changes from the cn=changelog naming context based on a polling interval. The changelog must be enabled in the backend directory. Please check with your directory vendor for instructions on how to enable the changelog."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Persistent Search"}]},{"type":"text","value":" - Any LDAP directory that offers a persistent search mechanism can use the Persistent Search connector type. Novell eDirectory is an example of an LDAP source that supports persistent search. Others include Red Hat Directory, IBM TDS, RadiantOne Universal Directory and CA Directory. The connector issues a persistent search and gets notified by the directory server when information changes. If the connector is shut down (either deliberately or due to failure), the delete operations that occurred in the directory are lost. Once the connector is back online there is no way to detect the delete operations that occurred while it was down. The only exception to this is for IBM TDS directories. It stores deleted entries and the capture connector is able to read them, and based on timestamp, determine if the change occurred while the connector was offline."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{"id":"active-directory"},"children":[{"type":"text","value":"Active Directory"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are three change detection mechanisms: USNChanged, DirSync and Hybrid. If you are virtualizing and detecting changes from a Global Catalog, then you must use the USNChanged changed connector because the DirSync and Hybrid connectors cannot detect change events on sub-domains."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The flowchart below helps to decide which change detection mechanism to use."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 97.45454545454545%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAEDAgX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAH3kpUGWgdA/8QAGBAAAgMAAAAAAAAAAAAAAAAAEEEAARH/2gAIAQEAAQUCLeR0P//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEABj8CH//EABoQAAIDAQEAAAAAAAAAAAAAAAERABAxIVH/2gAIAQEAAT8hG7Bu0E3IE3InlACr/9oADAMBAAIAAwAAABBjwDz/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAeEAEAAgEEAwAAAAAAAAAAAAABABFRECExYUFxkf/aAAgBAQABPxAF93q5Qe9cXxLMkwjvMFgr3mA8D5AHh5iNxp//2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/82f2c944189d20d46ac87dd9975e81c4/b966c/Image2.17.jpg","srcSet":["/static/82f2c944189d20d46ac87dd9975e81c4/c1cfe/Image2.17.jpg 275w","/static/82f2c944189d20d46ac87dd9975e81c4/67061/Image2.17.jpg 550w","/static/82f2c944189d20d46ac87dd9975e81c4/b966c/Image2.17.jpg 624w"],"sizes":"(max-width: 624px) 100vw, 624px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.17: Selecting a Active Directory Change Detection Mechanism"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"The Active Directory DirSync"}]},{"type":"text","value":" capture connector retrieves changes that occur to entries by passing a cookie that identifies the directory state at the time of the previous DirSync search. The first time the DirSync capture connector is started, it stores a cookie in a cursor file. At the next polling interval, the connector performs a DirSync search to detect changes by sending the current cookie. To use the DirSync control, the Bind DN connecting to the directory must have the DS-Replication-Get-Changes extended right, which can be enabled with the “Replicating Directory Changes” permission, on the root of the partition being monitored. By default, this right is assigned to the Administrator and LocalSystem accounts on domain controllers."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nTo detect delete events, the service account used by RadiantOne to connect to the backend Active Directory (configured in the connection string of the RadiantOne data source) must have permissions to search the tombstone objects. Usually, a member of the Administrators group is sufficient. However, some Active Directory servers may require a member of the Domain Admins group. Check with your Active Directory administrator to determine the appropriate credentials required."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf you are virtualizing and detecting changes from a Global Catalog, then you must use the Active Directory USNChanged changed connector because the DirSync connector cannot detect change events on sub-domains."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The Active Directory USNChanged capture connector keeps track of changes based on the uSNChanged attribute for the entry. Based on a configured polling interval, the connector connects with the user and password configured in the connection string/data source and checks the list of changes stored by Active Directory. The connector internally maintains the last processed change number (uSNChanged value) and this allows for the recovery of all changes that occur even if the connector is down (deliberately or due to failure)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If capturing the sequence of events is critical, use the DirSync connector instead of USNChanged because it processes events in the order in which they occur instead of prioritizing and processing inserts and updates before deletes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"By default, the connector is set to DirSync. To change, select the connector in the table and click Configure. Then select the desired change detection method from the drop-down list."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 602px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 37.090909090909086%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAEDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHbkKQn/8QAFxAAAwEAAAAAAAAAAAAAAAAAAAECEv/aAAgBAQABBQKXLGbP/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8BZ//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAQEBAAAAAAAAAAAAAAAAACEAEP/aAAgBAQAGPwIjP//EABgQAAMBAQAAAAAAAAAAAAAAAAABETFR/9oACAEBAAE/IavDhjomtNqpzD//2gAMAwEAAgADAAAAEHff/8QAFhEBAQEAAAAAAAAAAAAAAAAAEQAB/9oACAEDAQE/EMGk3//EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAgEBPxCNf//EABkQAQEBAQEBAAAAAAAAAAAAAAERACFBYf/aAAgBAQABPxAV9CKnu7ZB9Gg+VI9//9k='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/b1f3b2b66f3a47a6f73f8e88be8713ea/39e41/Image2.18.jpg","srcSet":["/static/b1f3b2b66f3a47a6f73f8e88be8713ea/c1cfe/Image2.18.jpg 275w","/static/b1f3b2b66f3a47a6f73f8e88be8713ea/67061/Image2.18.jpg 550w","/static/b1f3b2b66f3a47a6f73f8e88be8713ea/39e41/Image2.18.jpg 602w"],"sizes":"(max-width: 602px) 100vw, 602px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.18: Active Directory Connector Type Configuration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The Active Directory hybrid capture connector uses a combination of the uSNChanged and DirSync change detection mechanisms. The first time the connector starts, it gets a new cookie and the highest uSNchanged number. When the connector gets a new change (modify or delete), it makes an additional search using the DN of the entry and fetches the entry from AD. The fetched entry contains the uSNChanged attribute, so the connector updates the cursor values for both for the cookie and the last processed uSNchanged number."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf you are virtualizing and detecting changes from a Global Catalog, then you must use the Active Directory USNChanged changed connector because the Hybrid connector cannot detect change events on sub-domains."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When the connector restarts, uSNChanged detection catches the entries that have been modified or deleted while the connector was stopped. The LDAP search uses the last processed uSNChanged number to catch up. After the connector processes all entries, it requests a new cookie from Active Directory (not from the cursor) and switches to DirSync change detection."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"RadiantOne Universal Directory Stores"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you are using a persistent cache on a proxy view of a local RadiantOne Universal Directory store, or a nested persistent cache view (a cached view used in another cached view), the connector type is noted as HDAP (trigger) automatically and cannot be changed. This is a special trigger mechanism that publishes changes directly into the queue to invoke the persistent cache refresh."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 21.09090909090909%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3KEB/8QAFhAAAwAAAAAAAAAAAAAAAAAAABAR/9oACAEBAAEFAlT/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAXEAADAQAAAAAAAAAAAAAAAAAAARAx/9oACAEBAAE/IRZH/9oADAMBAAIAAwAAABDzz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABkQAQADAQEAAAAAAAAAAAAAAAEAEZExcf/aAAgBAQABPxBKLO+xaihSjJ//2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/b99ed9e6bee864412afbd46312928c11/b966c/Image2.19.jpg","srcSet":["/static/b99ed9e6bee864412afbd46312928c11/c1cfe/Image2.19.jpg 275w","/static/b99ed9e6bee864412afbd46312928c11/67061/Image2.19.jpg 550w","/static/b99ed9e6bee864412afbd46312928c11/b966c/Image2.19.jpg 624w"],"sizes":"(max-width: 624px) 100vw, 624px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.19: HDAP Trigger Connector Type"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"#connector-properties"},"children":[{"type":"text","value":"Connector properties"}]},{"type":"text","value":" can be edited from the Main Control Panel > PCache Monitoring tab. Click the icon representing the source in the topology to display the configuration section and view/edit properties."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 41.454545454545446%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3aEB/8QAFhAAAwAAAAAAAAAAAAAAAAAAEBEh/9oACAEBAAEFAgp//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAGBAAAwEBAAAAAAAAAAAAAAAAAAERIVH/2gAIAQEAAT8hnENYKEp//9oADAMBAAIAAwAAABCAD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQEBAAMBAAAAAAAAAAAAAAERACExUXH/2gAIAQEAAT8QCBF+4agX2aYAocqd7//Z'); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/57ef648882ee22c6f912a89ef312988a/b966c/Image2.20.jpg","srcSet":["/static/57ef648882ee22c6f912a89ef312988a/c1cfe/Image2.20.jpg 275w","/static/57ef648882ee22c6f912a89ef312988a/67061/Image2.20.jpg 550w","/static/57ef648882ee22c6f912a89ef312988a/b966c/Image2.20.jpg 624w"],"sizes":"(max-width: 624px) 100vw, 624px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.19: Connector Properties"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Directory Connector Failover"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This section describes the failover mechanism for the LDAP, Persistent Search and Active Directory connectors."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nThe backend servers must be configured for multi-master replication. Please check the vendor documentation for assistance with configuring replication for your backends."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The directory connectors leverage the failover servers that have been configured for the data source. When you configure a data source for your backend directory, you need to indicate the list of failover servers in order of priority. When the connector fails over, it uses the failover servers in the order they are listed. See the screen shot below for how to indicate a failover server for the Data Sources from the Main Control Panel."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 48.72727272727273%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHtspKSP//EABgQAAMBAQAAAAAAAAAAAAAAABARIQAB/9oACAEBAAEFAo5lwIf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAIEH/2gAIAQEABj8CIv8A/8QAGhAAAgMBAQAAAAAAAAAAAAAAAREAMWEQQf/aAAgBAQABPyHwKq4H1kwEQJDiCgOf/9oADAMBAAIAAwAAABB8P//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQACAwADAAAAAAAAAAAAAAEAESExUUFx0f/aAAgBAQABPxCzRFBsleuxYQVtIcSz5RoQbDZNoT0IeZ//2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/d13fa40e6db6137bb6568ae0c9cf77d7/b966c/Image2.21.jpg","srcSet":["/static/d13fa40e6db6137bb6568ae0c9cf77d7/c1cfe/Image2.21.jpg 275w","/static/d13fa40e6db6137bb6568ae0c9cf77d7/67061/Image2.21.jpg 550w","/static/d13fa40e6db6137bb6568ae0c9cf77d7/b966c/Image2.21.jpg 624w"],"sizes":"(max-width: 624px) 100vw, 624px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.21: Configuring Failover Servers for the Backend Directory"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If a connection cannot be made to the primary server and the maximum number of retry attempts has been exhausted, the connector connects to the failover servers in the order they are listed. There is no automatic failback, meaning once the primary server is back online, the connector doesn’t automatically go back to it."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This failover mechanism is supported for Active Directory, OpenDJ, Oracle Directory Server Enterprise Edition (Sun Directory v7), Oracle Unified Directory (OUD). In addition, any LDAP directory implementing cn=changelog and replicationCSN attribute or the persistent search control is also supported."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nWhen the Active Directory DirSync connector fails over to another DC replica, the current cursor (cookie) is used. The connector may receive all objects and attributes from the replica instead of just the delta from its last request. Therefore, you may notice the number of entries published by the connector is more than you were expecting. This behavior is dictated by the Active Directory server and is out of the control of the connector. Keep this in mind when you define the Max Retries and Retry Intervals for the connector properties. The smaller the numbers of retries, the higher the chance the connector will fail over and possibly receive all objects and attributes (a full sync) from the domain controller."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For the Active Directory USNChanged connector, the failover logic leverages the Active Directory replication vectors [replUpToDateVector], and the failover servers configured at the level of the RadiantOne data source associated with Active Directory, to determine which server(s) the connector switches to in case of failure. Since the replication vector contains all domains, in addition to some possibly retired domains, the connector narrows down the list of possible failover candidates to only the ones listed as failover servers in the RadiantOne data source associated with the Active Directory backend. If there are no failover server defined for the data source, all domains in the replication vector are possible candidates for failover."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nWhen defining the RadiantOne data source associated with Active Directory, do not use Host Discovery or Load Balancers. You must use the fully qualified machine names for the primary server and failover servers. Do not use IP addresses. Also, it is highly recommended that you list your desired failover servers at the level of the data source. Not only does this make the failover logic more efficient, but it also avoids delays in synchronization."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[replUpToDateVector] definition: The non-replicated attribute replUpToDateVector is an optional attribute on the naming context root of every naming context replica. If this vector is unavailable, the connector is suspended."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The ReplUpToDateVector type is a tuple with the following fields:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"uuidDsa: The invocation ID of the DC that assigned usnHighPropUpdate."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"usnHighPropUpdate: A USN at which an update was applied on the DC identified by uuidDsa."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"timeLastSyncSuccess: The time at which the last successful replication occurred from the DC identified by uuidDsa; for replication latency reporting only."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[replUpToDateVector] example:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"01ca6e90-7d20-4f9c-ba7b-823a72fc459e @ USN 2210490 @ Time 2005-08-21 15:54:21"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"1d9bb4b6-054a-440c-aedf-7a3f28837e7f @ USN 26245013 @ Time 2007-02-27 10:17:33"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"24980c9d-39fa-44d7-a153-c0c5c27f0577 @ USN 4606302 @ Time 2006-08-20 23:33:09"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"At run-time, the connector retrieves the entire list of servers defined in the replication vector and reduces the number of possible failover candidates based on failover servers defined in the RadiantOne data source. The list of potential failover servers is stored at each polling interval. When the current server fails, the connector decides to switch to the closest candidate by selecting the server with the maximum timestamp from the up-to-dateness vector. The capture connector’s cursor will be assigned the value from the up-to-dateness vector for the failover server. If the closest candidate fails as well, the connector tries with a second closest candidate and so on."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nDue to the lack of Active Directory replication for the USNChanged attribute, some changes could be missed or replayed on failover."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For the AD Hybrid connector, the failover process starts when the number of exceptions exceeds either the Maximum Retries on Error or Maximum Retries on Connection Error value. The failover servers are specified in the data source associated with Active Directory. The Active Directory up-to-date vector is used to determine the failover server and the value of the new cursor. If the up-to-date vector is unavailable from the current server, failover is not possible. If this happens, verify that AD replication is correctly configured. After the failover server is found, uSNChanged detection catches the entries that have been modified or deleted since the connector’s failure. The LDAP search uses the last processed uSNChanged number to catch up."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nDue to the lack of Active Directory replication for the USNChanged attribute, some changes could be missed or replayed on failover."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"After the connector processes all entries, it requests a new cookie from Active Directory and switches to DirSync change detection."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{"id":"custom-connectors"},"children":[{"type":"text","value":"Custom Connectors"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The following custom data sources support Real-time persistent cache refresh. For all other custom data sources, use a "},{"type":"element","tagName":"a","properties":{"href":"#periodic-refresh"},"children":[{"type":"text","value":"periodic cache refresh"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Any source that supports SCIM v1 or v2 (e.g. scimclient and scimclient2 custom data sources)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Azure Active Directory (e.g. default mgraph custom data source)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Okta Universal Directory (e.g. default oktaclient custom data source)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The custom connectors are configured and started automatically. Go to Main Control Panel > PCache Monitoring tab to configure "},{"type":"element","tagName":"a","properties":{"href":"#connector-properties"},"children":[{"type":"text","value":"connector properties"}]},{"type":"text","value":" and manage and monitor the persistent cache refresh process. Click the icon representing the custom data source in the topology to display the configuration section and view/edit properties."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 37.81818181818182%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3QUH/8QAFxAAAwEAAAAAAAAAAAAAAAAAABARIf/aAAgBAQABBQLFD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABgQAQADAQAAAAAAAAAAAAAAAAEAEVFB/9oACAEBAAE/IaHIhhKZP//aAAwDAQACAAMAAAAQ8A//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAbEAACAgMBAAAAAAAAAAAAAAAAAREhMWGR0f/aAAgBAQABPxBVIaoT8BQ4cR//2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/564496d30ff9e719963ec59d8ccd3ae4/b966c/Image2.22.jpg","srcSet":["/static/564496d30ff9e719963ec59d8ccd3ae4/c1cfe/Image2.22.jpg 275w","/static/564496d30ff9e719963ec59d8ccd3ae4/67061/Image2.22.jpg 550w","/static/564496d30ff9e719963ec59d8ccd3ae4/b966c/Image2.22.jpg 624w"],"sizes":"(max-width: 624px) 100vw, 624px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.22: Custom Connector Properties"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Custom connectors don’t have built-in failover logic. The web service target must handle failover and this is typically achieved with a web server/HTTP load balancer."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{"id":"connector-properties"},"children":[{"type":"text","value":"Connector Properties"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The following properties are for real-time persistent cache refresh connectors. Not all properties are applicable for every type of backend. The description indicates the type of backend the property is used for."}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Property"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Description"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Polling Interval"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"This property indicates the amount of time (in milliseconds) the connector should wait before querying the source to check for changes. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is applicable to all connectors except HDAP triggers. The default value is 10,000 ms (10 seconds)."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Size Limit"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"This property indicates the number of entries the connector collects from the source in a single request. However, even if the connector picks up multiple entries, they are processed and published to the queue one at a time. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is applicable to all connectors except HDAP triggers. The default value is 1000."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Log Level"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Log Level – OFF: Used to turn logging off. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Log level – FATAL: Severe errors that cause premature termination. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Log level – ERROR: Other runtime errors or unexpected conditions. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Log level – WARN: Use of deprecated APIs, poor use of API. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Log level – INFO: Interesting runtime events. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Log level – DEBUG: Detailed information on the flow through the system. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Log level – TRACE: Most detailed information. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Log location: "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"<RLI_HOME>\\logs\\sync_agent\\<naming_context>__<baseDN>__<data_source>\\connector.log"}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is applicable to all connectors except HDAP triggers. The default value is INFO."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Max Retries On Error"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"If the connector is unable to connect to the source to pick up changes for any reason other than a connection error, it tries to reconnect. Maximum Retries on Error is the total number of times the connector tries reconnecting. The frequency of the reconnect attempt is based on the Retry Interval on Error property. After all attempts have been tried, the connector failover logic is triggered. If there are no backends available to connect to, the agent automatically redeploys the connector until a connection to the backend can be made."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is applicable to all connectors except HDAP triggers. The default value is 5."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Retry Interval on Error"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Used in conjunction with the Max Retries on Error property. This is the amount of time (in milliseconds) the connector waits before it attempts to pick up changes from the source after an error has occurred."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is applicable to all connectors except HDAP triggers. The default value is 10,000 ms (10 seconds)."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Max Retries on Connection Error"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"For Database Connectors - If the connector is unable to connect to the primary backend server, it tries to connect to the failover server. If the connector cannot connect to the primary or failover servers because of a connection error, it tries to connect again later. Maximum Retries on Connection Error is the total number of times the connector tries reconnecting. A failed attempt to connect to both the primary and failover server is considered a single retry. The frequency of the reconnect attempt is based on the Retry Interval on Connection Error property. If there are no backends available to connect to, the agent automatically redeploys the connector until a connection to the backend can be made."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"For Directory Connectors - If the connector is unable to connect to the primary backend server because of a connection error, it tries to connect again later. Maximum Retries on Connection Error is the total number of times the connector tries reconnecting. The frequency of the reconnect attempt is based on the Retry Interval on Connection Error property. After all attempts have been tried, the connector failover logic is triggered. If there are no backends available to connect to, the agent automatically redeploys the connector until a connection to the backend can be made."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is applicable to all connectors except HDAP triggers. The default value is 5."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Retry Interval on Connection Error"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Used in conjunction with the Max Retries on Connection Error property. This is the amount of time (in milliseconds) the connector waits before trying to establish a connection to the source if there was a connection problem during the previous attempt. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is applicable to all connectors except HDAP triggers. The default value is 10,000 ms (10 seconds)."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"LDAP Filter"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"To further condition the entries that are published, you can indicate the desired criteria in the LDAP Filter property. This is a post filter, used to qualify which entries are published by the connector. You must enter a valid LDAP filter in the property."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property can be used to avoid publishing unwanted information."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If a captured entry matches the criteria indicated in the LDAP filter property, it is published by the connector. If it doesn’t, the entry is not published. Information about the skipped entries is in the connector log (with log level set to DEBUG). "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If the captured change type is delete, and not enough information is known about the entry, the LDAP filter is not used and the entry is published by the connector. For example, if the LDAP filter property contained a value of (l=Novato) and the captured entry did not contain an “l” attribute, the LDAP filter is not applied and the entry is published. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If the captured change type is not delete (e.g. insert, update, move…etc.), and not enough information is known about the entry, the LDAP filter is still used and the entry is not published. For example, if the LDAP filter property contained a value of (l=Novato) and the captured entry did not contain an “l” attribute, the LDAP filter is still applied and the entry is not published by the connector."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is only applicable to Active Directory, LDAP and Persistent Search connectors. The default value is blank (no specific filter)."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property also plays a role in recovering changes that happen while a connector is stopped. The LDAP filter is added to the (internal) default filter used to further condition the entries to capture. For example, if the \"LDAP Filter\" property = "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" (|(objectclass=myProvider)(objectclass=myPerson)(objectclass=mySubscriber)), then, the following LDAP filter is used by the connector to capture changes that were missed while the connector was stopped:"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"(&(|(modifyTimestamp>=20211014212817.215Z)(createTimestamp>=20211014212817.215Z))(|(objectclass=myProvider)(objectclass=myPerson)(objectclass=mySubscriber))) "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Note - If a change is made to this property while the connector is running, it must be restarted for the new value to take effect."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Excluded Branches"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"To further condition the entries that are published, you can indicate branch(es) to exclude. In the Excluded Branches property, enter one or more suffixes associated with entries that should not be published in the message by the connector. Click “Enter” to accept the value and to be able to enter another suffix. You can use the “x” next to the suffix to remove it."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 371px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 16%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAADABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB34hQH//EABYQAAMAAAAAAAAAAAAAAAAAAAABEP/aAAgBAQABBQKI/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAFhABAQEAAAAAAAAAAAAAAAAAABEx/9oACAEBAAE/IYjD/9oADAMBAAIAAwAAABAAD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAAICAwAAAAAAAAAAAAAAAAABESExYZH/2gAIAQEAAT8QaW4shvrMZ//Z'); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/c8e10133112a457d6f32186f8a15bc18/bfbf0/excluded-branches.jpg","srcSet":["/static/c8e10133112a457d6f32186f8a15bc18/c1cfe/excluded-branches.jpg 275w","/static/c8e10133112a457d6f32186f8a15bc18/bfbf0/excluded-branches.jpg 371w"],"sizes":"(max-width: 371px) 100vw, 371px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If the changed entry DN contains a suffix that matches the excluded branches value, or is a change in the exact entry that is listed (e.g. CN=CFS users,DC=seradiant,DC=dom), this entry is not published by the connector. Otherwise, the entry is published. This can avoid publishing unwanted information."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"Note – If both included and excluded branches are used, an entry must satisfy the conditions defined in both settings to be included in the message. The included branches condition(s) is checked first. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If you set this value using the vdsconfig command line utility on Windows, separate the branches with a comma. E.g. C:\\radiantone\\vds\\bin>vdsconfig.bat set-connector-property -connectorname o_sead_pcache_proxy__dc_seradiant_dc_dom__seradiantad -propertyid excludedBranches "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" -propertyvalue “[\"cn=users,dc=seradiant,dc=dom\",\"cn=domain groups,dc=seradiant,dc=dom\"]” "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is only applicable to Active Directory, LDAP and Persistent Search connectors. The default value is blank (no excluded branches). "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If a change is made to this property while the connector is running, the new value is taken into account once the connector re-initializes (happens automatically every 20 seconds)."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Included Branches"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"To further condition the entries that are published, you can indicate branch(es) to include. In the Included Branches property, enter one or more suffixes associated with entries that should be published by the connector. Click “Enter” to accept the value and to be able to enter another suffix. You can use the “x” next to the suffix to remove it. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 358px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 15.636363636363637%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAADABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB34BUH//EABYQAAMAAAAAAAAAAAAAAAAAAAABEP/aAAgBAQABBQKI/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAFhABAQEAAAAAAAAAAAAAAAAAABEx/9oACAEBAAE/IYjD/9oADAMBAAIAAwAAABBzz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABkQAQADAQEAAAAAAAAAAAAAAAEAESFhkf/aAAgBAQABPxBALWynfZkz/9k='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/1573e71ec5e506571d0e06f65e41b724/af061/included-branches.jpg","srcSet":["/static/1573e71ec5e506571d0e06f65e41b724/c1cfe/included-branches.jpg 275w","/static/1573e71ec5e506571d0e06f65e41b724/af061/included-branches.jpg 358w"],"sizes":"(max-width: 358px) 100vw, 358px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If the changed entry DN contains a suffix that matches the included branches value, or is a change in the exact entry that is listed (e.g. CN=All Users,DC=seradiant,DC=com), this entry is published by the connector. Otherwise, the entry is not published. This can avoid publishing unwanted information. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Note - if both included and excluded branches are used, an entry must satisfy the conditions defined in both settings to be included in the message. The included branches condition(s) is checked first. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If you set this value using the vdsconfig command line utility on Windows, separate the branches with a comma. E.g. C:\\radiantone\\vds\\bin>vdsconfig.bat set-connector-property -connectorname o_sead_pcache_proxy__dc_seradiant_dc_dom__seradiantad -propertyid includedBranches -propertyvalue “[\"cn=users,dc=seradiant,dc=dom\",\"cn=domain groups,dc=seradiant,dc=dom\"]”** "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is only applicable to Active Directory, LDAP and Persistent Search connectors. The default value is blank (no included branches). "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If a change is made to this property while the connector is running, the new value is taken into account once the connector re-initializes (happens automatically every 20 seconds)."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"SQL Filter"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"SQL filter is a post filter used to evaluate entries captured by the connector. Only changes that match the filter are published by the connector. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"A SQL filter is either a single expression or several single expressions joined by binary operators and brackets ( ). Possible binary operators are: "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"-\tAND "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" - OR "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" -NOT "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Some examples of valid SQL Filters are: "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"- ID='5' "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" - ID='5' AND NAME='ALLEN' "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" -\tID='5' AND NAME='ALLEN' OR CITY='SAN FRANCISCO' "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" -\tID='5' AND (NAME='ALLEN' OR CITY='SAN FRANCISCO') "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" - NAME LIKE 'AL%' "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" -\tNAME LIKE 'ALLE_' "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If the SQL Filter syntax entered into the property is not correct, an error is logged by the connector and it continues working without applying the SQL Filter (all changes are published). "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is only applicable for the DB Changelog, DB Counter, and DB Timestamp connectors. The default value is blank (no specific filter)."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Force Sequential Counters (true/false)"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"This property accepts a value of true or false and dictates how the connector treats entries it picks up from the LOG table that have non-sequential change IDs. The default is true meaning that if the connector detects a non-sequential change ID for an entry in the LOG table, it behaves as if there is an error (non-connection error) and the retry logic based on the Max Retries on Error and Retry Interval on Error properties takes effect. Sometimes rows in the log table are not written in the order of the change ID, and if the connector doesn’t wait for the entries to have sequential IDs, some changes could be missed. The connector waits for the length of time specified in the Retry Interval on Error property and then tries to get the changed entries in the database again. After the maximum number of retries (indicated in the Max Retries on Error property) is exhausted, if it still detects non-sequential change IDs, the connector stops. Set “Force Sequential Counters” to false before restarting the connector to have the connector ignore non-sequential change IDs. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" If the connector should ignore non-sequential change IDs, and process all changes immediately, set the property to false."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is only applicable to the DB Changelog and DB Counter connectors. The default value is true."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Processing Delay"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"This property can be used if there is a need for a delay in the processing of changes by the connector. For example, if there are two or more processes that update the source table at the same time, and they take about 2 minutes each to run, the processing delay can be set at anywhere between 4-6 minutes. This delays the processing and makes sure the connector captures all changes coming from both processes. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" The property value is in seconds, and the default value is 0. If the value is set to <=0, it means that the property is ignored by the connector. If the value is set to be more than 0, then only the entries between last_cursor and current_time – processing_delay are processed by the connector. If an invalid, non-numeric value is set for this property, the connector stops. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is only applicable to the DB Timestamp connector."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Skip catch-up process (true/false)"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"If this option is set to false, when the connector starts, it tries to pick up all changes that happened since the last time it successfully processed any changes (this information is maintained in the connector’s cursor file). This is based on changenumber. If this option is set to true, the connector sends out only the changes that happen after it has started. All changes that happened while the connector was stopped are ignored. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" The property is applicable to the Persistent Search connector only. The default value is false."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Switch to Primary Server (in Polling Intervals)"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"This option, working in conjunction with the Polling Interval property, allows you to configure how often, if at all, the connector attempts to switch back to the primary server after failover. To configure the connector to attempt to switch to the primary server, set Switch to Primary Server to a value of 4 or greater. You can set the value to less than 4, but attempting to connect back to the primary server can be time consuming and therefore not recommended to do frequently. For example, if this value is set to 1, the connector makes an attempt every polling interval. If the Switch to Primary Server value is 3, the connector makes an attempt every third polling interval. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" To disable attempts to reconnect to the primary server, set this value to zero. This is the default value. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" Changes made to this property’s value while the connector is running are immediately taken into account. When the connector starts or restarts and the property value is 1 or higher, the connector attempts to switch to the primary server immediately. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" This property is applicable to the LDAP changelog connectors only."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Failover Algorithm [1-4]"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"This option is relevant for the LDAP changelog connector type."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" When a failover happens, the changelog capture connector attempts to find a new cursor. Since this process is inexact, and changenumber sequence can vary across some replica servers, some events may be replayed or lost. The changelog connector maintains a cursor that indicates information related to the last change processed by the connector along with information about possible replica servers in case failover is needed. During failover, the connector searches the changelog of the replica servers and determines minimum and maximum changenumbers across them. Assume that the last processed changenumber stored by the connector is 100 and there are 2 replica servers defined for the backend. During failover, the connector determines the current changenumbers for each of the replicas by searching their changelogs. Assume that replica 1 has changenumber 99 and replica 2 has changenumber 97. When the connector needs to failover, it must decide whether to start processing changes using changenumber 100 (its current last processed change), 97 (changenumber from replica 2), or 99 (changenumber from replica 1). "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" The Failover Algorithm property allows you to determine how the cursor value gets set during failover, and ultimately determine the quantity of events that are replayed. The property supports values between 1 and 4. The meaning of each is outlined in the table below. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 436px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 58.18181818181818%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAv/EABYBAQEBAAAAAAAAAAAAAAAAAAECA//aAAwDAQACEAMQAAABsfmjWVDgf//EABsQAAICAwEAAAAAAAAAAAAAAAECABEDEBIj/9oACAEBAAEFAkA4pZSzGPOtf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQIBAT8Bb0p//8QAGBAAAwEBAAAAAAAAAAAAAAAAAAJBcRD/2gAIAQEABj8CXCEFzv8A/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAER8FGR/9oACAEBAAE/IXbSwYI2R5Ygi4f/2gAMAwEAAgADAAAAELQP/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAwEBPxBLCH//xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQIBAT8Q2tb/xAAbEAEAAgIDAAAAAAAAAAAAAAABABFRcSFB4f/aAAgBAQABPxB8aVi61E2l4ZgciSlvlO2oYk//2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/3e10e17ce37bc8fc5033ea3b73da75f1/4c32f/failover-algorithm.jpg","srcSet":["/static/3e10e17ce37bc8fc5033ea3b73da75f1/c1cfe/failover-algorithm.jpg 275w","/static/3e10e17ce37bc8fc5033ea3b73da75f1/4c32f/failover-algorithm.jpg 436w"],"sizes":"(max-width: 436px) 100vw, 436px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{"id":"resetting-connector-cursor--detect-new-only"},"children":[{"type":"text","value":"Resetting Connector Cursor – Detect New Only"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Capture connectors use a cursor to maintain information about the last processed changes. This allows the connectors to capture only changes that have happened since the last time they checked for changes. When the real-time persistent cache refresh connectors start, they automatically attempt to capture all changes that have happened since the last time they checked. If the real-time persistent cache refresh process has been stopped for an extended period of time, you might not want them to attempt to capture all changes since the last time they checked. In this case, you can reset the cursor for the connector. From the Main Control Panel > PCache Monitoring tab, select the real-time refresh topology and the topology displays. Click the icon representing the capture connector and the Runtime details are displayed on the right. Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Reset Cursor"}]},{"type":"text","value":" to clear the cursor value and trigger the connector to behave as if it is the first time connecting to the source to collect changes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"persistent-cache-properties"},"children":[{"type":"text","value":"Persistent Cache Properties"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Once a persistent cache is configured, properties can be managed from the Main Control Panel > Directory Namespace tab > Cache node. Select the configured persistent cache branch and the properties are available on the right."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"non-indexed-attributes"},"children":[{"type":"text","value":"Non-indexed Attributes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the Indexed Attributes list is empty, all attributes are indexed by default (except binary ones). Also, the following “internal” ones won’t be indexed either: \"creatorsName\", \"createTimestamp\", \"modifiersName\", \"modifyTimestamp\", \"cacheCreatorsName\", \"cacheCreateTimestamp\", \"cacheModifiersName\", \"cacheModifyTimestamp\", \"uuid\", \"vdsSyncState\", \"vdsSyncHist\", \"ds-sync-generation-id\", \"ds-sync-state\", \"ds-sync-hist\", \"vdsSyncCursor\", \"entryUUID\", \"userpassword”. Any additional attributes that you do not want indexed should be added to the Non Indexed Attributes list on the Properties tab for the selected persistent cache branch."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you change the non-indexed attributes, you must re-build the index. You can do this from the Properties tab by clicking "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Re-build Index"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"sorted-attributes"},"children":[{"type":"text","value":"Sorted Attributes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This is a comma-separated list of attributes to be used in association with Virtual List Views (VLV) or sort control configured for RadiantOne. These sorted indexes are managed internally in the persistent cache and kept optimized for sorting. They are required if you need to sort the search result or to execute a VLV query on the persistent cache branch."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you need to support VLV, the VLV/Sort control must be enabled in RadiantOne. For details on this control, please see the RadiantOne System Administration Guide."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you change the sorted attributes, you must re-build the index. You can do this from the Properties tab by clicking "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Re-build Index"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"encrypted-attributes"},"children":[{"type":"text","value":"Encrypted Attributes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Attribute encryption protects sensitive data while it is stored in RadiantOne. You can specify that certain attributes of an entry are stored in an encrypted format. This prevents data from being readable while stored in persistent cache, backup files, and exported LDIF files. Attribute values are encrypted before they are stored in persistent cache, and decrypted before being returned to the client, as long as the client is authorized to read the attribute (based on ACLs defined in RadiantOne), is connected to the RadiantOne service via SSL, and not a member of the special group containing members not allowed to get these attributes (e.g. cn=ClearAttributesOnly,cn=globalgroups,cn=config). For details on this special group, please see the RadiantOne System Administration Guide."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nDefine a security encryption key from the Main Control Panel > Settings Tab > Security section > Attribute Encryption prior to configuring encrypted attributes. For steps on defining key generation, see the RadiantOne System Administration Guide."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On the Properties Tab for the selected persistent cache, enter a comma-separated list of attributes to store encrypted in the Encrypted Attributes property. Attributes listed in the Encrypted Attributes property are added to the Non-indexed attribute list by default. This means these attributes are not searchable by default. Indexing encrypted attributes is generally not advised as the index itself is less secure than the attribute stored in the persistent cache. However, if you must be able to search on the encrypted attribute value, it must be indexed. Only “exact match/equality” index is supported for encrypted attributes. To make an encrypted attribute searchable, remove the attribute from the list of nonindexed attributes and then click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Re-build Index"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"extension-attributes"},"children":[{"type":"text","value":"Extension Attributes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Extension Attributes are new attributes (meaning these attributes don’t exist anywhere yet) that are associated with a cached virtual entry. This is primarily used to accommodate the storage of application-specific attributes that you want to store locally as opposed to the backend(s) you are virtualizing. Extension attributes should be used as an alternative to Extended Joins in scenarios where the virtual view is stored in persistent cache and then needs replicated out to RadiantOne Universal Directory stores in other clusters."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Extension attributes are stored locally and RadiantOne handles the lifecycle of these attributes accordingly. Once a persistent cache is defined, list the attribute names (comma-separated) in the Extension Attributes property. The attribute names must be unique and not overlap with attributes coming from and being cached from existing backends. The example below has an extension attribute named lastLogin. Applications can write to this attribute and RadiantOne handles the write locally without delegating anything to the backend."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 899px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 68.36363636363636%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd1yySg//8QAFhABAQEAAAAAAAAAAAAAAAAAERAg/9oACAEBAAEFAoOP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxAAAwEAAAAAAAAAAAAAAAAAECBBkf/aAAgBAQAGPwIXU//EABoQAQACAwEAAAAAAAAAAAAAAAEAERBBYZH/2gAIAQEAAT8h1L5Eq3woErH/2gAMAwEAAgADAAAAEDPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAMBAAMAAAAAAAAAAAAAAQARQSGBofD/2gAIAQEAAT8QG6JuMOqmiAXAHpnLDxKfEqp//9k='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/4bf496f7587ef88b94dd9c8391d54aff/2d452/Image2.23.jpg","srcSet":["/static/4bf496f7587ef88b94dd9c8391d54aff/c1cfe/Image2.23.jpg 275w","/static/4bf496f7587ef88b94dd9c8391d54aff/67061/Image2.23.jpg 550w","/static/4bf496f7587ef88b94dd9c8391d54aff/2d452/Image2.23.jpg 899w"],"sizes":"(max-width: 899px) 100vw, 899px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.23: Extension Attributes for Persistent Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For consistency of the RadiantOne LDAP schema, define the extension attributes as part of the schema, generally associated with an auxiliary object class. For details on extending the schema, see the RadiantOne System Administration Guide."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Extension Attributes are replicated to other clusters in deployment scenarios where inter-cluster replication is enabled and a replica of a persistent cache is maintained as a RadiantOne Universal Directory store in the target cluster(s)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When using extension attributes for cached virtual views of LDAP directory backends, you must configure invariant attribute(s). See the following section for more details."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"invariant-attributes"},"children":[{"type":"text","value":"Invariant Attributes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To guarantee extension attributes are linked to their respective underlying entries and moved properly should modRDN/modDN events occur in the backend source, invariant attribute(s) must be defined. The invariant attribute is the unique identifier in the backend directory. Below are some invariant attributes used in common LDAP directories."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"objectGUID (Active Directory)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"entryUUID (Oracle Unified Directory, OpenDJ, unboundID)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"nsUniqueID (Sun/ODSEE)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ibm-entryUUID (IBM)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"UUID (RadiantOne Universal Directory)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For the example shown below, the persistent cached view is from an Active Directory backend. RadiantOne manages the lifecycle of the attribute named lastLogin and this attribute is stored directly in the cache. The invariant attribute is set to objectGUID which is the unique identifier for the users in the backend Active Directory. If the entry in the backend is moved, the invariant attribute ensures RadiantOne handles the move of the associated cached extension attributes properly."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 899px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 68.36363636363636%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd1yySg//8QAFhABAQEAAAAAAAAAAAAAAAAAERAg/9oACAEBAAEFAoOP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxAAAwEAAAAAAAAAAAAAAAAAECBBkf/aAAgBAQAGPwIXU//EABoQAQACAwEAAAAAAAAAAAAAAAEAERBBYZH/2gAIAQEAAT8h1L5Eq3woErH/2gAMAwEAAgADAAAAEBPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAICAwAAAAAAAAAAAAAAAQARIUFhofD/2gAIAQEAAT8QG6JvTDKpogF0A6ZwGWU8Sqn/2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/0a8fd86f0d0f6fa43cdb027ed5c7652a/2d452/Image2.24.jpg","srcSet":["/static/0a8fd86f0d0f6fa43cdb027ed5c7652a/c1cfe/Image2.24.jpg 275w","/static/0a8fd86f0d0f6fa43cdb027ed5c7652a/67061/Image2.24.jpg 550w","/static/0a8fd86f0d0f6fa43cdb027ed5c7652a/2d452/Image2.24.jpg 899w"],"sizes":"(max-width: 899px) 100vw, 899px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.24: Invariant Attribute for Persistent Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"inter-cluster-replication"},"children":[{"type":"text","value":"Inter-cluster Replication"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This option should be enabled if you want to support replication between this persistent cache branch and a RadiantOne Universal Directory store in a different cluster."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If inter-cluster replication is enabled, a replication journal is used to store changes that happen on the persistent cache branch. The replication journal is associated with the default LDAP data source defined as replicationjournal and root naming context named cn=replicationjournal. The RadiantOne leader node in the cluster associated with the persistent cache, publishes changes into the replication journal. The RadiantOne leader nodes in all other clusters (that are configured for inter-cluster replication) pick up changes from the replication journal to update their local replica. Persistent caches usually only publish changes into the replication journal (for other RadiantOne Universal Directory replicas in other clusters). There are some cases where persistent cache can accept changes from other clusters."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nChanges that haven’t been picked up from the replicationjournal for 3 days are automatically purged."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"accept-changes-from-replicas"},"children":[{"type":"text","value":"Accept Changes from Replicas"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For limited use cases where the only type of modify operations that client applications perform is updates to existing entries (no adds or deletes), the persistent cache can subscribe to these events. If the persistent cache should process attribute updates from RadiantOne Universal Directory replicas in other clusters, enable the Accept Changes from Replicas option and list the acceptable attributes in the Updateable Attributes from Replicas property."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nPersistent Cache stores can only accept modification operations from RadiantOne Universal Directory replicas. Add and delete operations are currently not supported. Therefore, proper ACLs should be configured for the RadiantOne Universal Directory replicas to prevent the addition and deletion of entries."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nThis is an advanced setting, consult with a Radiant Logic Solution Architect to get assistance on the needed architecture and usage."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"updateable-attributes-from-replicas"},"children":[{"type":"text","value":"Updateable Attributes from Replicas"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A comma-separated list of attribute names that the persistent cache should accept changes for. Only changes made to these attributes are processed by the persistent cache. All other changes published in the replication journal from the RadiantOne Universal Directory replicas are ignored by the persistent cache. If an updateable attribute is associated with an extension attribute in the persistent cache, the attribute update is handled locally. If an updateable attribute is sourced from a backend data source, the update is forwarded to the appropriate backend and the cache image is refreshed after the backend update is successful. If the backend update fails, the current persistent cache image is considered the reference and is published to the replication journal to override the images in the RadiantOne Universal Directory replicas in all other clusters."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nPersistent Cache stores can only accept modification operations from RadiantOne Universal Directory replicas. Add and delete operations are currently not supported. Therefore, proper ACLs should be configured for the RadiantOne Universal Directory replicas to prevent the addition and deletion of entries."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nThis is an advanced setting, consult with a Radiant Logic Solution Architect to get assistance on the needed architecture and usage."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"use-cache-for-authentication"},"children":[{"type":"text","value":"Use Cache for Authentication"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The default behavior of the RadiantOne service for processing bind requests for users located in a persistent cache branch is to delegate the credentials checking to the authoritative backend source. If the password in the backend is encrypted using one of the algorithms supported by RadiantOne, and the passwords are stored in the cache, you can configure the service to authenticate the user locally against the password in cache instead of delegating the credentials checking to the backend. To enable this behavior, check the Use Cache for Authentication option on the configured cache branch. This option is not applicable in scenarios where the passwords are not stored in the persistent cache. For an example use case where this option could be applicable, please see "},{"type":"element","tagName":"a","properties":{"href":"07-deployment-architecture#backends-inaccessible-by-all-sites"},"children":[{"type":"text","value":"Authoritative Backends Inaccessible by All Sites"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"By default, if the Use Cache for Authentication option is enabled and the entry in persistent cache has a password, RadiantOne checks the password against the local value and the user is authenticated or not based on this comparison. If the entry in persistent cache doesn’t have a password, RadiantOne delegates the credentials checking to the backend data source. There are two options to override this default behavior: Local Bind Only or Delegate on Failure."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 10.90909090909091%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAACABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG4AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAYEAACAwAAAAAAAAAAAAAAAAAAARAxQf/aAAgBAQABPyHB1H//2gAMAwEAAgADAAAAEAPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAFhABAQEAAAAAAAAAAAAAAAAAAAEx/9oACAEBAAE/EJpTMf/Z'); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/ee5d3b554026aa87807a3cc70088d47d/b966c/Image2.25.jpg","srcSet":["/static/ee5d3b554026aa87807a3cc70088d47d/c1cfe/Image2.25.jpg 275w","/static/ee5d3b554026aa87807a3cc70088d47d/67061/Image2.25.jpg 550w","/static/ee5d3b554026aa87807a3cc70088d47d/b966c/Image2.25.jpg 624w"],"sizes":"(max-width: 624px) 100vw, 624px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.25: Authentication Options"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Each option is described in more details below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Local Bind Only – If this option is enabled and the user entry in cache either has no password or the bind fails, RadiantOne does not delegate the credentials checking to the backend. It determines if the user authentication fails based on the local comparison."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Delegate on Failure – If this option is enabled and the user entry in cache has a password but the local checking fails, RadiantOne delegates the credentials checking to the backend. If the credentials checking fails against the backend, an unsuccessful bind response is returned to the client. If the credentials checking succeeds against the backend, a successful bind response is returned to the client."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Enable Password Policy Enforcement - If you are storing user passwords in cache and you are using the cache for authentication, you can also choose to have RadiantOne enforce password policies (as opposed to delegating password checking to the backend directory and having it enforce password policies). Enable this option and then define the password policy to enforce. For details on password policies, see the RadiantOne System Administration Guide."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When you enable the password policy enforcement on a persistent cache, the userPassword attribute is automatically added to the Extension Attribute property and you have the option to enable Password Write Back. If Password Write Back is enabled, and a modify request for the password is sent to RadiantOne, it tries to update the password in the backend. In some circumstances, having two levels of password policies can result in inconsistencies between the cache image and the underlying backend(s). These circumstances are outlined in the table below."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Password Change Event"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Password Writeback Enabled?"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Expected Behavior"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Password update via a Modify Request sent to RadiantOne"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"No"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"The password is updated in the persistent cache if it complies with the persistent cache password policy. Otherwise the password update fails. "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" "},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":" The password update is not sent to the backend. If the update to the persistent cache succeeds, the password in the persistent cache will be different than the one in the backend."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Password update via a Modify Request sent to RadiantOne"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Yes"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"The password update is sent to the backend. If the password update fails in the backend, the password in the persistent cache is not updated. If the password update succeeds in the backend, the password is updated in the persistent cache."}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Password is updated directly in the backend (outside of RadiantOne)"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Through the persistent cache refresh process, the password is updated in the persistent cache. If the account was locked in the persistent cache due to a password policy enforced at the cache layer, it will be unlocked by the cache refresh process after a successful password update in the backend. Password strength defined in the persistent cache password policy is not enforced since the password change originated from the backend."}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"active"},"children":[{"type":"text","value":"Active"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Check the Active option if you want to Activate this naming context. Uncheck the Active option to deactivate the cache. If a persistent cache is deactivated, RadiantOne issues queries to the backend(s) when processing client requests."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"full-text-search"},"children":[{"type":"text","value":"Full-text Search"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Persistent cache branches can support full text searches. This offers additional flexibility for clients as they can search data in the RadiantOne namespace based on text (character) data. These types of searches are no longer linked to specific attributes as the characters requested could be found in any attribute value. An entry is returned if any attribute in the entry contains the character string(s) requested by the client."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Clients issue full text searches similar to the way they issue LDAP searches. The only difference is the filter contains "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"(fulltext=<value>)"}]},{"type":"text","value":" where "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"<value>"}]},{"type":"text","value":" would be the text they are interested in. As an example, if a client was interested in the text John Doe as an exact phrase, the search filter sent to RadiantOne would be (fulltext= “John Doe”) where the phrase is encapsulated in double quotes. If the phrase in the filter is not encapsulated in double quotes it means the client wants any entries that have attribute values that contain the character string John OR Doe."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The part of the filter that contains the piece related to the full text search can also be combined with other “standard” LDAP operators. As an example, a filter could be something like (&(uid=sjones)(fulltext=”John Doe”)). This would return entries that contain a uid attribute with the value sjones AND any other attribute that contains the exact character string John Doe."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you want the persistent cache to support full text searches, check the Full-Text Search option and click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Save"}]},{"type":"text","value":". If you add the support for full text searches, click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Re-build Index"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"optimize-linked-attributes"},"children":[{"type":"text","value":"Optimize Linked Attributes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Linked attributes are attributes that allow relationships between objects. A typical example would be isMemberOf/uniqueMember for user/groups objects. A group has members (uniqueMember attribute) which is the forward link relationship. Those members have an isMemberOf attribute which is the back link (to the group entry) relationship. Other examples of linked attributes are:"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"manager/directReports\naltRecipient/altRecipientBL\ndLMemRejectPerms/dLMemRejectPermsBL\ndLMemSubmitPerms/dLMemSubmitPermsBL\nmsExchArchiveDatabaseLink/msExchArchiveDatabaseLinkBL\nmsExchDelegateListLink/msExchDelegateListBL\npublicDelegates/publicDelegatesBL\nowner/ownerBL"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"manager/directReports\naltRecipient/altRecipientBL\ndLMemRejectPerms/dLMemRejectPermsBL\ndLMemSubmitPerms/dLMemSubmitPermsBL\nmsExchArchiveDatabaseLink/msExchArchiveDatabaseLinkBL\nmsExchDelegateListLink/msExchDelegateListBL\npublicDelegates/publicDelegatesBL\nowner/ownerBL"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The most common back link/forward link relationship is between group and user objects. A list of groups a user is a member of can be calculated automatically by RadiantOne and returned in the membership attribute of the user entry. The most common back link attributes are in the drop-down list. However, you can manually enter any attribute name you want. This is configured on the Main Control Panel, click Settings > Interception > Special Attributes Handling > Linked Attributes setting (on the right)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the Target Base DN (back link attribute location) and the Source Base DN (forward link attribute location) in the Linked Attributes setting is a persistent cached branch, the computation of the references can be optimized in order to return client requests for the back link attribute at high speed. To enable this optimization, follow the steps below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf your linked attributes are for users and groups (both branches located in persistent cache), and you enable the Optimize Linked Attributes setting, and must support nested groups, only one user location per persistent cache store is supported. For example, in the Linked Attributes setting, having a Target Base DN location configured for ou=people1,dc=myhdap and ou=people2,dc=myhdap (both in the same dc=myhdap persistent cache store) is not supported. In this case, you should configure a single user location as dc=myhdap as a shared parent for both containers."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"It is assumed you have configured and initialized your persistent cache, and configured the Linked Attributes in Special Attributes Handling. If you have not, please do so prior to continuing with the steps below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 343px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 59.63636363636364%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB2rCRBxP/xAAXEAADAQAAAAAAAAAAAAAAAAABEBEA/9oACAEBAAEFAgqNH//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABoQAAEFAQAAAAAAAAAAAAAAAAEAEBEhMcH/2gAIAQEAAT8h1dsZo4gAxoC//9oADAMBAAIAAwAAABB7P//EABYRAQEBAAAAAAAAAAAAAAAAAAABIf/aAAgBAwEBPxCNf//EABYRAQEBAAAAAAAAAAAAAAAAAAABIf/aAAgBAgEBPxCsf//EAB0QAQACAQUBAAAAAAAAAAAAAAEAESExQVFhcdH/2gAIAQEAAT8Q1Dd8qCJiBSWzDl8hNCjiVOon/9k='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/8f4757535013efda5f9eff70bacb365c/4f01a/Image2.29.jpg","srcSet":["/static/8f4757535013efda5f9eff70bacb365c/c1cfe/Image2.29.jpg 275w","/static/8f4757535013efda5f9eff70bacb365c/4f01a/Image2.29.jpg 343w"],"sizes":"(max-width: 343px) 100vw, 343px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.29: Back Link Attribute Name in Special Attribute Handling"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Select the Optimize Linked Attributes option on the Properties tab for the selected persistent cache branch on the Main Control Panel > Directory Namespace tab > Cache section. The defined linked attribute is added to the Extension Attributes List for the persistent cache."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Save"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"You can either rebuild the index, or reinitialize the persistent cache. Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Re-build Index"}]},{"type":"text","value":" or "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Initialize"}]},{"type":"text","value":". The back link attribute is always returned to clients even when not requested unless Hide Operational Attributes is enabled in RadiantOne (in which case it is only returned when a client explicitly requests it). For details on the Hide Operational Attributes setting, please see the RadiantOne System Administration Guide."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf a persistent cache has optimizations associated with it, deactivating it will interfere with queries associated with the linked attributes and they will not return properly. If you no longer need a cache, delete it instead of deactivating it."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"persistent-cache-universally-unique-identifier-uuid"},"children":[{"type":"text","value":"Persistent Cache Universally Unique Identifier (UUID)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The Universally Unique Identifier (UUID) attribute is a reserved, internal attribute that is assigned to each entry and can guarantee uniqueness across space and time."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When adding entries into a persistent cache (LDAP ADD operations) from an LDIF file, if there are UUID attributes they are ignored by RadiantOne during import. RadiantOne generates a unique value for each entry based on the specifications in RFC 4122."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When initializing with an LDIF file (LDIF INIT), if the entry has a UUID attribute, RadiantOne keeps it. If the entry does not have a UUID attribute, RadiantOne generates a unique value for each entry based on the specifications in RFC 4122."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"UUID is an operational attribute meaning that if a client wants this attribute, they must explicitly ask for it in the search request sent to RadiantOne."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When exporting a persistent cache store to an LDIF file, you have the option to export the UUID attribute or not. The UUID attribute should be exported into LDIF if you plan on using this export to initialize a RadiantOne Universal Directory store, a replica for inter-cluster replication. Otherwise, the UUID attribute generally should not be exported. To export a persistent cache store and include the UUID attributes, check the Export for Replication option in the export window."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 538px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 42.90909090909091%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7qcJRmH/xAAZEAABBQAAAAAAAAAAAAAAAAAQAAECETL/2gAIAQEAAQUCFsJZX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAAIDAAAAAAAAAAAAAAAAAAABICEx/9oACAEBAAY/Ai2aof/EABkQAQACAwAAAAAAAAAAAAAAAAEAERAxYf/aAAgBAQABPyGiKBdB3IboT//aAAwDAQACAAMAAAAQ/wD/AP/EABYRAQEBAAAAAAAAAAAAAAAAAAEQIf/aAAgBAwEBPxBwn//EABYRAQEBAAAAAAAAAAAAAAAAAAEQIf/aAAgBAgEBPxA1n//EABsQAAIDAAMAAAAAAAAAAAAAAAABETFBEJGx/9oACAEBAAE/EIE6nIGZBWskiSuzjyFD/9k='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/107ecd4ba74c4f745b67d1e0f1a91b44/22978/Image2.30.jpg","srcSet":["/static/107ecd4ba74c4f745b67d1e0f1a91b44/c1cfe/Image2.30.jpg 275w","/static/107ecd4ba74c4f745b67d1e0f1a91b44/22978/Image2.30.jpg 538w"],"sizes":"(max-width: 538px) 100vw, 538px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.30: Export Persistent Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{"id":"managing-the-persistent-cache"},"children":[{"type":"text","value":"Managing the Persistent Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"re-initializing-a-persistent-cache"},"children":[{"type":"text","value":"Re-initializing a Persistent Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Persistent cache should be re-initialized during off-peak hours, or during scheduled downtime, since it is a CPU-intensive process and during the initialization queries are delegated to the backend data sources which might not be able to handle the load."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Cache refresh connectors do not need to be stopped to re-initialize the persistent cache."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Deactivate any inter-cluster replication on the cached branch prior to re-initializing. To do so, navigate to the cached branch on the Main Control Panel > Directory Namespace Tab and on the right side, uncheck “Inter-cluster Replication”, then click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Save"}]},{"type":"text","value":". Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Yes"}]},{"type":"text","value":" to apply the changes to the server."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"With the cached node selected, on the Refresh Settings tab, click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Initialize"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Choose to either initialize the cache by creating an LDIF file or from an existing LDIF file. Typically, you would always use the default option which is to create an LDIF file. The only time you could choose to use an existing file is if you already have an up-to-date LDIF file containing all of the needed entries."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"OK"}]},{"type":"text","value":". A task is launched to re-initialize the persistent cache. The task can be monitored and managed from the Server Control Panel > Tasks Tab associated with the RadiantOne leader node."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"OK"}]},{"type":"text","value":" to exit the initialization wizard."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Save"}]},{"type":"text","value":" in the upper right corner."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Re-enable Inter-cluster Replication that was deactivated in step 1."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"re-building-index"},"children":[{"type":"text","value":"Re-building Index"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the cache has already been initialized, and the attribute list for sorted indexes changes (new attributes need to be indexed or removed from the index), you must rebuild the index. From the Main Control Panel -> Directory Namespace Tab, select the persistent cache branch below the Cache node. On the Properties tab on the right side, click the Re-build Index button."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"exporting-the-cache"},"children":[{"type":"text","value":"Exporting the Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Exporting the cache generates an LDIF formatted file from the cache contents. This can be useful if you want to replicate this cache image across multiple RadiantOne clusters. To export the cached branch, from the Main Control Panel -> Directory Namespace Tab, select the persistent cache branch below the Cache node. On the Properties Tab on the right side, click the Export button. Enter a name, select a type of file (LDIF or LDIFZ which is a zipped and encrypted file) and click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"OK"}]},{"type":"text","value":". If you want to use this LDIF file to initialize a cache or Universal Directory store in another cluster, use the Main Control Panel > Settings Tab > Configuration > File Manager to browse to <RLI_HOME>/vds_server/ldif/export to download the file. Then, connect to the Main Control Panel in the target environment where you want to use the LDIF file and use the Settings Tab > Configuration > File Manager to navigate to <RLI_HOME>/vds_server/ldif/import to upload the LDIF file. When you initialize the cache in the target environment, browse to this location to locate the file to use for initialization."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf exporting to an LDIFZ file, a security key must be configured. This key is the same as the one used for attribute encryption. Any target server (persistent cache or RadiantOne Universal Directory store) where you want to import this LDIFZ file must use the same security key value. The security key is defined from the Main Control Panel > Settings Tab > Security > Attribute Encryption section. If an LDIFZ encryption key is defined, only the ldifz file type is available when exporting to LDIF from the Main Control Panel > Directory Browser tab."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 401px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHdgSoX/8QAFhABAQEAAAAAAAAAAAAAAAAAAQAC/9oACAEBAAEFApQDQ3//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAXEAEAAwAAAAAAAAAAAAAAAAAAARHh/9oACAEBAAY/Alyx/8QAGRAAAwADAAAAAAAAAAAAAAAAAAERITGR/9oACAEBAAE/IcDFSI0zfR//2gAMAwEAAgADAAAAEI/v/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8QZ//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ECf/xAAZEAEAAwEBAAAAAAAAAAAAAAABABEhMaH/2gAIAQEAAT8QAHNjsjogvhBlRTWhP//Z'); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/ceff596ce3e0fe2f63096f88292a66d1/f6c81/Image2.31.jpg","srcSet":["/static/ceff596ce3e0fe2f63096f88292a66d1/c1cfe/Image2.31.jpg 275w","/static/ceff596ce3e0fe2f63096f88292a66d1/f6c81/Image2.31.jpg 401w"],"sizes":"(max-width: 401px) 100vw, 401px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.31: Exporting an LDIFZ file"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"testing-persistent-cache-refresh-process"},"children":[{"type":"text","value":"Testing Persistent Cache Refresh Process"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To test the persistent cache refresh process, use an LDAP command line utility like the one described below. If the connectors are running, suspend them from the Main Control Panel > PCache Monitoring tab."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The ldapsearch utility offered in the Sun Resource Kit can be used to force a refresh of the persistent cache based on a specific DN. The command would look similar to the following:"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"ldapsearch -h 10.11.12.91 -p 2389 -D \"cn=directory manager\" -w \"secret\" -b \"action=synchronizecache,customers=ALFKI,dv=northwind,o=vds\" -s base (objectclass=*)"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ldapsearch -h 10.11.12.91 -p 2389 -D \"cn=directory manager\" -w \"secret\" -b \"action=synchronizecache,customers=ALFKI,dv=northwind,o=vds\" -s base (objectclass=*)"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The above command refreshes the single entry identified by the DN of customers=ALFKI,dv=northwind,o=vds. If you want to refresh multiple entries with a single command, you can use a ONE LEVEL or SUBTREE scope. If you wanted to refresh all entries below dv=northwind, the command would be:"}]},{"type":"text","value":"\n\n          "},{"type":"element","tagName":"codeblockcopytag","properties":{},"children":[{"type":"text","value":"ldapsearch -h 10.11.12.91 -p 2389 -D \"cn=directory manager\" -w \"secret\" -b \"action=synchronizecache,dv=northwind,o=vds\" -s one (objectclass=*)"}]},{"type":"text","value":"\n          \n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ldapsearch -h 10.11.12.91 -p 2389 -D \"cn=directory manager\" -w \"secret\" -b \"action=synchronizecache,dv=northwind,o=vds\" -s one (objectclass=*)"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Each parameter of the command is described below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"-h is the RadiantOne server name or IP address."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"-p is the LDAP port RadiantOne is listening on."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"-D is the user to connect to RadiantOne as."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"-w is the password for the user you are connecting with."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"-b is the DN for the entry in the persistent cache that you want refreshed (if a base scope). If a one level, or sub tree scope is used, then -b is the starting point in the persistent cache to start refreshing from."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"-s is the scope of the search which should be base, one or sub."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"(objectclass=*) is the filter."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Modify the above command to match your requirement. Keep the following in mind."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Always connect to RadiantOne as the directory manager"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Replace the DN with your own (always start with action=synchronizecache,)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To test, first modify the information in the underlying source. The persistent cache should not reflect any change. Next, execute the ldapsearch command mentioned above. Now, the persistent cache should reflect the new entry. Be sure to check all log files if the persistent cache did not get refreshed properly."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"logging-persistent-cache-refreshes"},"children":[{"type":"text","value":"Logging Persistent Cache Refreshes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the change log has been enabled for RadiantOne, then all changes affecting the persistent cache are logged there. Otherwise, all activity to the persistent cache is logged into a branch in the RadiantOne namespace with a root suffix of cn=cacherefreshlog. This branch only stores changes that affect persistent cache branches."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Logging of persistent cache changes into the cn=cacherefreshlog is always enabled and different log levels can be configured. The log level is set on the Main Control Panel > Settings Tab > Logs section > Changelog sub-section. Select the drop-down list next to the Persistent Cache Refresh Log option on the right side and choose a log level. The log levels are:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Error – logs only errors that occur when trying to refresh the persistent cache. This is the default."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Status – logs the status (and the DN that was refreshed) when refreshes are made to the persistent cache."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"All – logs all refreshes to the persistent cache including the changes that occurred."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Entries remain in the cn=cacherefreshlog for a default of 3 days. This is configurable and defined in the Main Control Panel > Settings Tab > Logs section > Changelog sub-section, Changelog and Journal Stores Max Age property. This property is shared by the following internal stores."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"cn=changelog"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"cn=cacherefreshlog"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"cn=replicationjournal"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"cn=localjournal"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"cn=tombstone"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"cn=clustermonitor"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"cn=queue"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"cn=dlqueue"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Typically, if the changelog has been enabled then error log level is used for the persistent cache refresh log. For more information, please see Persistent Cache Log Setting in the RadiantOne System Administration Guide."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"detecting-persistent-cache-update-errors"},"children":[{"type":"text","value":"Detecting Persistent Cache Update Errors"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If an entry in the persistent cache fails to be updated, the entry in the cache refresh log is tagged with a status attribute of 2."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"An example of a failed cache refresh log entry can be seen in the figure below."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 483px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHbFuIGD//EABkQAAIDAQAAAAAAAAAAAAAAAAACARARIf/aAAgBAQABBQJTDBZ7X//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAQEBAAAAAAAAAAAAAAAAABABAv/aAAgBAQAGPwKun//EABoQAAMAAwEAAAAAAAAAAAAAAAABERAxUSH/2gAIAQEAAT8h2K8qwjhZPBax/9oADAMBAAIAAwAAABBTD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQACAgMAAAAAAAAAAAAAAAEAESExEHGB/9oACAEBAAE/ECaCLXbRTiAFUfIyFZYmjrj/2Q=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"An image showing ","title":"","src":"/static/c53da3011ceb7ac29495b3950dfb6e0d/81888/Image2.32.jpg","srcSet":["/static/c53da3011ceb7ac29495b3950dfb6e0d/c1cfe/Image2.32.jpg 275w","/static/c53da3011ceb7ac29495b3950dfb6e0d/81888/Image2.32.jpg 483w"],"sizes":"(max-width: 483px) 100vw, 483px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Figure 2.32: Persistent Cache Refresh Log Entry"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the problem resulting in the update error has been fixed, you can manually reissue the update request with a base search on the entry using the targetDN attribute in the persistent cache refresh log. Using the example shown above, the entry in persistent cache is Employee=1,Category=employees,dc=csaa. Therefore, the command to refresh this entry in cache would look similar to the following:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ldapsearch -h 10.11.12.91 -p 2389 -D \"cn=directory manager\" -w \"secret\" -b \"action=synchronizecache,Employee=1,Category=employees,dc=csaa\" -s base (objectclass=*)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[!warning]\r\nIf there are many failed entries in the persistent cache refresh log, meaning that the cache image is significantly different than the backends, it might be more efficient to reinitialize the persistent cache as opposed to trying to fix the failed updates one at a time."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{"id":"deleting-the-persistent-cache"},"children":[{"type":"text","value":"Deleting the Persistent Cache"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To delete a persistent cache branch, uncheck the Active checkbox (on the Properties tab for the cached branch), then click Save to apply the changes to the server. Then click "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Delete"}]},{"type":"text","value":"."}]}],"data":{"quirksMode":false}},"fileAbsolutePath":"/home/runner/work/developer-site/developer-site/.cache/gatsby-source-git/r1-saas/documentation/deployment-and-tuning-guide/02-tuning-tips-for-caching-in-radiantone.md","frontmatter":{"title":"Deployment and Tuning Guide"},"headings":[{"id":"chapter-2-tuning-tips-for-caching-in-the-radiantone-federated-identity-service","value":"Chapter 2: Tuning Tips for Caching in the RadiantOne Federated Identity Service","depth":1},{"id":"when-and-why-do-you-need-a-cache-with-radiantone-fid","value":"When and why do you need a cache with RadiantOne FID?","depth":2},{"id":"tcpip-connections-and-connection-pooling","value":"TCP/IP Connections and Connection Pooling","depth":4},{"id":"first-level-of-query-parsing","value":"First Level of Query Parsing","depth":4},{"id":"back-end-performance","value":"Back-end Performance","depth":3},{"id":"memory-cache","value":"Memory Cache","depth":4},{"id":"persistent-cache","value":"Persistent Cache","depth":3},{"id":"cache","value":"Cache","depth":2},{"id":"memory-cache-1","value":"Memory Cache","depth":3},{"id":"configuring-entry-memory-cache","value":"Configuring Entry Memory Cache","depth":4},{"id":"memory-size-requirements","value":"Memory Size Requirements","depth":5},{"id":"for-entries","value":"For Entries","depth":6},{"id":"for-indexes","value":"For Indexes","depth":5},{"id":"total-memory-size-requirements","value":"Total Memory Size Requirements","depth":3},{"id":"configuring-query-cache","value":"Configuring Query Cache","depth":3},{"id":"populating-the-memory-cache","value":"Populating the Memory Cache","depth":4},{"id":"entry-cache","value":"Entry Cache","depth":5},{"id":"query-cache","value":"Query Cache","depth":5},{"id":"refreshing-the-memory-cache","value":"Refreshing the Memory Cache","depth":4},{"id":"persistent-cache-1","value":"Persistent Cache","depth":3},{"id":"disk-space-requirements","value":"Disk Space Requirements","depth":4},{"id":"initializing-persistent-cache","value":"Initializing Persistent Cache","depth":4},{"id":"using-paging","value":"Using Paging","depth":5},{"id":"supporting-zipped-and-encrypted-ldif-files","value":"Supporting Zipped and Encrypted LDIF Files","depth":5},{"id":"options-for-refreshing-the-persistent-cache","value":"Options for Refreshing the Persistent Cache","depth":4},{"id":"changes-occurring-through-radiantone","value":"Changes Occurring Through RadiantOne","depth":5},{"id":"real-time-cache-refresh-based-on-changes-occurring-directly-on-the-backend-sources","value":"Real Time Cache Refresh Based on Changes Occurring Directly on the Backend Source(s)","depth":4},{"id":"periodic-refresh","value":"Periodic Refresh","depth":5},{"id":"configuring-persistent-cache-with-periodic-refresh","value":"Configuring Persistent Cache with Periodic Refresh","depth":4},{"id":"create-an-ldif-from-a-snapshot","value":"Create an LDIF from a Snapshot","depth":4},{"id":"periodic-refresh-cron-expression","value":"Periodic Refresh CRON Expression","depth":5},{"id":"delete-validation-threshold","value":"Delete Validation Threshold","depth":5},{"id":"add-validation-threshold","value":"Add Validation Threshold","depth":5},{"id":"configuring-persistent-cache-with-real-time-refresh","value":"Configuring Persistent Cache with Real-Time Refresh","depth":4},{"id":"configuring-source-connectors","value":"Configuring Source Connectors","depth":5},{"id":"database-connectors","value":"Database Connectors","depth":3},{"id":"db-changelog","value":"DB Changelog","depth":6},{"id":"connector-configuration","value":"Connector Configuration","depth":5},{"id":"log-table-name-syntax","value":"Log Table Name Syntax","depth":5},{"id":"db-timestamp","value":"DB Timestamp","depth":6},{"id":"db-counter","value":"DB Counter","depth":6},{"id":"database-connector-failover","value":"Database Connector Failover","depth":6},{"id":"re-configuring-database-connectors","value":"Re-configuring Database Connectors","depth":6},{"id":"directory-connectors","value":"Directory Connectors","depth":6},{"id":"ldap-directories","value":"LDAP Directories","depth":6},{"id":"active-directory","value":"Active Directory","depth":6},{"id":"custom-connectors","value":"Custom Connectors","depth":6},{"id":"connector-properties","value":"Connector Properties","depth":6},{"id":"resetting-connector-cursor--detect-new-only","value":"Resetting Connector Cursor – Detect New Only","depth":6},{"id":"persistent-cache-properties","value":"Persistent Cache Properties","depth":4},{"id":"non-indexed-attributes","value":"Non-indexed Attributes","depth":5},{"id":"sorted-attributes","value":"Sorted Attributes","depth":5},{"id":"encrypted-attributes","value":"Encrypted Attributes","depth":5},{"id":"extension-attributes","value":"Extension Attributes","depth":5},{"id":"invariant-attributes","value":"Invariant Attributes","depth":5},{"id":"inter-cluster-replication","value":"Inter-cluster Replication","depth":5},{"id":"accept-changes-from-replicas","value":"Accept Changes from Replicas","depth":5},{"id":"updateable-attributes-from-replicas","value":"Updateable Attributes from Replicas","depth":5},{"id":"use-cache-for-authentication","value":"Use Cache for Authentication","depth":5},{"id":"active","value":"Active","depth":5},{"id":"full-text-search","value":"Full-text Search","depth":5},{"id":"optimize-linked-attributes","value":"Optimize Linked Attributes","depth":5},{"id":"persistent-cache-universally-unique-identifier-uuid","value":"Persistent Cache Universally Unique Identifier (UUID)","depth":4},{"id":"managing-the-persistent-cache","value":"Managing the Persistent Cache","depth":4},{"id":"re-initializing-a-persistent-cache","value":"Re-initializing a Persistent Cache","depth":5},{"id":"re-building-index","value":"Re-building Index","depth":5},{"id":"exporting-the-cache","value":"Exporting the Cache","depth":5},{"id":"testing-persistent-cache-refresh-process","value":"Testing Persistent Cache Refresh Process","depth":5},{"id":"logging-persistent-cache-refreshes","value":"Logging Persistent Cache Refreshes","depth":5},{"id":"detecting-persistent-cache-update-errors","value":"Detecting Persistent Cache Update Errors","depth":5},{"id":"deleting-the-persistent-cache","value":"Deleting the Persistent Cache","depth":5}]},"toc":{"html":"<ul>\n<li><a href=\"00-preface.md\">Preface</a></li>\n<li><a href=\"01-global-tuning.md\">Chapter 1: Global Tuning</a></li>\n<li><a href=\"02-tuning-tips-for-caching-in-radiantone.md\">Chapter 2: Tuning Tips for Caching in the RadiantOne Federate Identity Service</a></li>\n<li><a href=\"03-tuning-tips-for-specific-types-of-backend-data-sources.md\">Chapter 3: Tuning Tips for Specific Types of Backend Data Sources in the RadiantOne Federate Identity Service</a></li>\n<li><a href=\"04-tuning-tips-radiantone-universal-directory.md\">Chapter 4: Tuning Tips for RadiantOne Universal Directory</a></li>\n<li><a href=\"05-testing-radiantone-performance.md\">Chapter 5: Testing RadiantOne Performance</a></li>\n<li><a href=\"06-starting-and-stopping-components-and-services.md\">Chapter 6: Starting and Stopping Components and Services</a></li>\n<li><a href=\"07-deployment-architecture.md\">Chapter 7: Deployment Architectures</a></li>\n</ul>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"00-preface.md"},"children":[{"type":"text","value":"Preface"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"01-global-tuning.md"},"children":[{"type":"text","value":"Chapter 1: Global Tuning"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"02-tuning-tips-for-caching-in-radiantone.md"},"children":[{"type":"text","value":"Chapter 2: Tuning Tips for Caching in the RadiantOne Federate Identity Service"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"03-tuning-tips-for-specific-types-of-backend-data-sources.md"},"children":[{"type":"text","value":"Chapter 3: Tuning Tips for Specific Types of Backend Data Sources in the RadiantOne Federate Identity Service"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"04-tuning-tips-radiantone-universal-directory.md"},"children":[{"type":"text","value":"Chapter 4: Tuning Tips for RadiantOne Universal Directory"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"05-testing-radiantone-performance.md"},"children":[{"type":"text","value":"Chapter 5: Testing RadiantOne Performance"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"06-starting-and-stopping-components-and-services.md"},"children":[{"type":"text","value":"Chapter 6: Starting and Stopping Components and Services"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"07-deployment-architecture.md"},"children":[{"type":"text","value":"Chapter 7: Deployment Architectures"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fileAbsolutePath":"/home/runner/work/developer-site/developer-site/.cache/gatsby-source-git/r1-saas/documentation/deployment-and-tuning-guide/TOC.md","frontmatter":{"title":"Deployment and Tuning Guide"}},"rootToc":{"fileAbsolutePath":"/home/runner/work/developer-site/developer-site/.cache/gatsby-source-git/r1-saas/home-pages/TOC.md","frontmatter":{"title":"Homepages TOC"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":""},"children":[{"type":"text","value":"Knowledge"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"developer.md"},"children":[{"type":"text","value":"Developer"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},"pageContext":{"slug":"deployment-and-tuning-guide/02-tuning-tips-for-caching-in-radiantone","dir":"documentation/deployment-and-tuning-guide/02-tuning-tips-for-caching-in-radiantone.md","absolutePath":"/home/runner/work/developer-site/developer-site/.cache/gatsby-source-git/r1-saas/documentation/deployment-and-tuning-guide/02-tuning-tips-for-caching-in-radiantone.md","tocRegex":"/(r1-saas)/(documentation/)(deployment-and-tuning-guide/)?(02-tuning-tips-for-caching-in-radiantone.md/)?(TOC.md)/ig","rootTocRegex":".*/(gatsby-source-git)\\/(r1-saas)\\/(home-pages)\\/(TOC.md)/ig"}},"staticQueryHashes":["2295405308","63159454","808649686"],"slicesMap":{}}